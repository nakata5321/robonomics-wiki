(window.webpackJsonp=window.webpackJsonp||[]).push([[282],{ZbFX:function(n,e,o){"use strict";o("iJZR")},iJZR:function(n,e,o){},wQbG:function(n,e,o){"use strict";o.r(e);o("hByQ"),o("rB9j"),o("TeQF"),o("yq1k"),o("JTJg"),o("SYor");var t={data:function(){return{isActive:!1,isFocused:!1,search:""}},computed:{toggleClasses:function(){return{active:this.isActive}},searchResults:function(){var n=this;return this.search.length>2?this.$static.allDocPage.edges.filter((function(e){return(e.node.title.toLowerCase().includes(n.search.toLowerCase().trim())||e.node.content.toLowerCase().includes(n.search.toLowerCase().trim()))&e.node.path.includes("/"+n.$store.state.locale+"/")&e.node.path!=n.$route.matched[0].path+"/"})):""}},methods:{focusIn:function(){document.querySelector(".search-container").classList.add("active")},focusOut:function(){document.querySelector(".search-container").classList.remove("active")}},watch:{"$route.path":function(n,e){document.querySelector(".search-container").classList.remove("active")}}},a=(o("ZbFX"),o("KHd+")),s=o("Kw5r"),i=s.a.config.optionMergeStrategies.computed,r={allDocPage:{edges:[{node:{id:"02d946260be0219336908112b186b2e7",title:"Market messages",path:"/docs/ru/market-messages/",content:"\nMarket messages is used for exchange **Demand** and **Offer** information. It also used for delivery **Result** messages with liability execution reports.\n\n> This is spec for Robonomics `Generation 5`.\n\n- Currently for message delivery is used [IPFS PubSub](https://ipfs.io/blog/25-pubsub/) broadcaster.\n- IPFS PubSub **topic** is set according to *Lighthouse [ENS](https://ens.domains/) name*.\n\n## Messages content\n\nRobonomics market message use [JSON](https://www.json.org/) data format.\n\n\n### Demand\n\n| Field | ROS Type | Description |\n|-------------- |-------------------------  |------------------------------------------------ |\n| model | [ipfs_common/Multihash](/docs/ipfs-common-messages#ipfs_commonmultihashmsg) | CPS behavioral model identifier |\n| objective | [ipfs_common/Multihash](/docs/ipfs-common-messages#ipfs_commonmultihashmsg) | CPS behavioral model parameters in rosbag file |\n| token | [ethereum_common/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) | Operational token address |\n| cost | [ethereum_common/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg) | CPS behavioral model execution cost |\n| lighthouse | [ethereum_common/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) | Lighthouse contract address |\n| validator | [ethereum_common/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) | Observing network address |\n| validatorFee  | [ethereum_common/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg) | Observing network fee |\n| deadline | [ethereum_common/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg) | Deadline block number |\n| nonce | [ethereum_common/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg) | Robonomics message counter |\n| sender | [ethereum_common/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) | Message sender address |\n| signature | std_msgs/UInt8[] | Sender’s Ethereum signature |\n\n### Offer\n\n| Field             | ROS Type                  | Description                                       |\n|---------------    |-------------------------  |------------------------------------------------   |\n| model             | [ipfs_commom/Multihash](/docs/ipfs-common-messages#ipfs_commonmultihashmsg)     | CPS behavioral model identifier                   |\n| objective         | [ipfs_commom/Multihash](/docs/ipfs-common-messages#ipfs_commonmultihashmsg)     | CPS behavioral model parameters in rosbag file    |\n| token             | [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg)   | Operational token address                         |\n| cost              | [ethereum_commom/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg)   | CPS behavioral model execution cost               |\n| validator         | [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg)   | Observing network address                         |\n| lighthouse        | [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg)   | Lighthouse contract address                       |\n| lighthouseFee     | [ethereum_commom/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg)   | Liability creation fee                            |\n| deadline          | [ethereum_commom/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg)   | Deadline block number                             |\n| nonce             | [ethereum_commom/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg)   | Robonomics message counter                        |\n| sender            | [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg)   | Message sender address                            |\n| signature         | std_msgs/UInt8[]          | Sender’s Ethereum signature                       |\n\n### Result\n\n| Field         | ROS Type                  | Description                       |\n|-----------    |-------------------------  |---------------------------------- |\n| liability     | [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg)   | Liability contract address        |\n| result        | [ipfs_commom/Multihash](/docs/ipfs-common-messages#ipfs_commonmultihashmsg)     | Liability result multihash        |\n| success       | std_msgs/Bool             | Is liability executed successful  |\n| signature     | std_msgs/UInt8[]          | Sender’s Ethereum signature       |\n\n## Messages signing\n\nBefore signing the messages is packed using [abi.encodePacked](https://solidity.readthedocs.io/en/latest/abi-spec.html#non-standard-packed-mode\n) solidity finction and hashed by Keccak_256.\n\n```\n   demandHash = keccak256(abi.encodePacked(\n        _model\n      , _objective\n      , _token\n      , _cost\n      , _lighthouse\n      , _validator\n      , _validator_fee\n      , _deadline\n      , IFactory(factory).nonceOf(_sender)\n      , _sender\n      ));\n```\n\n**`nonce` parameter is counted by factory smart contract and incremented for each created liability smart contract.**\n\nMessage hash are signed using Ethereum ``secp256k1`` [signature](https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign).\n"}},{node:{id:"557de6c7b71d3b43b60bf282c8d9ba29",title:"Playground Overview",path:"/docs/ru/playground-overview/",content:"\nRobonomics allows to use robots as autonomous agents that receive commands from a human or another robot and do some useful work, storing a report of their actions in Blockchain. The interaction between the robot and the Robonomics platform is quite simple with a [Robonomics IO](/docs/rio-overview).\n## What Robots You Can Control\nThe playground section contains examples of connecting different robots to Robonomics which everyone can try to repeat step by step. In this section you can try to control:\n* [an Unmanned Aerial Vehicle](/docs/iris-drone/)\n* [a Mars Rover](/docs/connect-mars-curiosity-rover-under-robonomics-parachain-control/)\n* [a Manipulator](/docs/kuka/)\n* [an industrial Baxter Robot](/docs/baxter2/)\n\nSince all robots are available as simulation models, you don't need any special hardware. So you can try to connect the robot to Robonomics Network right now.\n## How Do You Control the Robot\nAll of our Demos are launched in a local network, however you can connect a robot to the live networks in the same way.\n\nAll Demos in this section follow a similar scenario. You [create an account](/docs/create-account-in-dapp/) for the robot and send him some units for paying transactions. Then the user sends an `ON/OFF` transaction to the robot's address, the robot receives it and starts working. After the job is done the telemetry is saved in IPFS and the file hash is sent to datalog. So at any time you can see how the robot performed its work.\n## Connect Your Own Robot\nIn addition you can create your own control package for any ROS-compatitable device with [this](/docs/connect-any-ros-compatitable-robot-under-robonomics-parachain-control-1/) instruction.\n\n"}},{node:{id:"2f29c23a14ebe65b6b55f6f2fe61d0ff",title:"R&D на базе Робономики",path:"/docs/ru/r-and-d-based-on-robonomics-network/",content:"\nЗа 4 года участники проекта Робономика выполнили 13 R&D проектов в процессе написания текущей версии платформы Робономика. Ознакомьтесь со списком опробованных нами сценариев применения web3+robotics:\n\n### Запуск дрона под контролем децентрализованного компьютера.\n2016 год - успешное испытание в полевых условиях совместимости 3DR X8 дронов с программным обеспечением Drone Employee. На видео - человек отправляет транзакцию квадрокоптеру через Ethereum Blockchain.\n\nhttps://www.youtube.com/watch?v=V_3rcP2Duv0&t=1s\n\n### Управление флотом дронов в децентрализованной сети.\n[Распределенное небо](https://airmarket.io/wp-content/uploads/2018/09/Distributed-Sky-Whitepaper-v3.0.pdf) является основой системы управления движением беспилотных самолетов (UTM). Проект использует глобальную сеть компьютеров для обработки и хранения идентификационных данных, трафика и другой конфиденциальной информации, а также использует криптографию для обеспечения безопасности и масштабируемости процесса. На видео - агент Drone Passport в действии.\n\nhttps://www.youtube.com/watch?v=yxGTOkGkBJ8\n\n### Токенизация данных от IoT устройств.\nЧетвертая промышленная революция знаменует собой полную интеграцию CPS в массовое производство и оказание услуг. Машины не ведут пустых разговоров, они честны в своей работе и могут быть независимой стороной, предоставляющей информацию, на основе алгоритмического анализа которой сама сеть может создавать ценности.\nЦенности, основанные на труде машин, будут гораздо интереснее для нового поколения, чем другие, эмиссия которых построена на любом другом принципе. Дополнительная информация доступна [здесь](https://blog.aira.life/tokenization-and-the-4th-industrial-revolution-3208022be747)\n\n### Цифровые рынки для роботов.\n\n### Управление индустриальной зоной с помощью капитала.\n[В данной статье](https://ieeexplore.ieee.org/abstract/document/8525391) представлена архитектура протокола связи для современных производственных процессов и бизнеса на основе киберфизических систем - Индустрии 4.0. Основное внимание уделяется одному из ключевых направлений этой концепции - экономическим автономным агентам, то есть роботам или умным вещам, которые могут принимать экономические решения независимо. Агенты начинают полноценно участвовать в бизнес-процессах, поэтому важно автоматизировать их и обеспечить формальную и безопасную связь между множеством разнородных агентов с учетом экономической составляющей отрасли. В статье показано, как организовать экономическое взаимодействие между агентами с помощью одноранговой сети на основе децентрализованной технологии Blockchain и смарт-контрактов. Более подробную информацию об Индустрии 4.0 можно найти в видео ниже.\n\nhttps://www.youtube.com/watch?v=yuxOF_z70us\n\n### Дроны, сенсоры и блокчейн для контроля качества воды на Волге.\nВ рамках [этого проекта](https://github.com/airalab/drone_on_volga) было реализовано предложение услуги дроном через веб-приложение. Как правило, результатом оказания услуги является информация о положении дрона, скорости движения, параметры качества воды и другие важные сведения.\nСеть Робономики используется для связи с роботом. Граждане или правительственные чиновники могут заказывать услуги, совершая платеж в криптовалюте через веб-сайт. Сеть Робономики построена на платформе блокчейна Ethereum и протоколе IPFS, Адреса файлов в IPFS хранятся в блокчейне без возможности фальсификации.\nНиже - видео об экспериментах с водным дроном.\n\nhttps://www.youtube.com/watch?v=Mtqm5y6Bolo\n\n### Гражданские сенсорные сети.\nВ августе 2018 года компания Airalab при поддержке Smart Distribution (дистрибьютор Libelium в России) [создала мониторинговую сеть в жилом районе Тольятти](https://www.libelium.com/libeliumworld/success-stories/preventing-asthsma-sensor-network-air-quality-pm10-dust-in-play-area/). Цель заключалась в создании основы для внедрения сети мониторинга качества воздуха в особо уязвимых районах (школы, детские площадки, дома престарелых, больницы и т.д.), которая может предоставить местным властям информацию для принятия мер по защите своих граждан.\nПример использования датчика показан на видео. Исходный код можно найти [здесь](https://github.com/airalab/sensors-connectivity).\n\nhttps://www.youtube.com/watch?v=shqey3tmNUk\n\n### Робот-художник Gaka-chu.\nСовременные технологии делают жизнь человека более комфортной и увлекательной, освобождая время для размышлений и экспериментов. Именно серия размышлений о статичности отрасли привела команду разработчиков к идее проведения эксперимента, демонстрирующего автономное преобразование производства для конкретного типа продукта.\nТаким экспериментом стал [робот-художник](https://github.com/airalab/robot_painter/) - маленький неуклюжий манипулятор KUKA, живущий в большом мире серьезных промышленных роботов. И его зовут Gaka-Chu. Почему? Из-за любви к рисованию: «гака» по-японски - «художник». А «чу» добавили из-за необъяснимой любви к покемонам.\n\nhttps://youtu.be/xSD_lsrAA0I\n\n### Выпуск зеленых сертификатов на основе данных от ВИЭ.\nКонцептуальная цель [DAO IPCI](https://ipci.io/ru/) - предоставить единое пространство, общую среду, инструменты и экосистему, которая является универсальной, надежной, простой в использовании, позволяющей множеству заинтересованных сторон, включая предприятия и людей, регистрировать количественные воздействия и количественные обязательства, инвестировать в проекты по смягчению негативного воздействия на окружающую среду, компенсировать углеродный след, получать и продавать результаты смягчения этих последствий, присоединяться к существующим программам или запускать новые. Исходный код доступен [здесь](https://github.com/DAO-IPCI/DAO-IPCI).\n\nhttps://www.youtube.com/watch?v=q9plB0TjUnw&list=PLLepqB9oh7WvUVzbeaiwQojrip2tLPA6P\n\n### Торговля машин за место на дороге.\nНаша цель состояла в том, чтобы разработать [децентрализованную систему](https://github.com/khssnv/mobi_grand_challenge) для переговоров о дорожном пространстве, где автономные транспортные средства могут оплачивать маршруты и полосу движения. Мы считаем, что рыночный подход может быть использован для решения проблемы перегрузки на дорогах.\n\nhttps://youtu.be/JFQTknMZOYg\n\n### Блокчейн в задачах химической промышленности.\nИзначально была поставлена следующая задача: разработать [систему контроля качества](https://github.com/Vourhey/chemistry-quality-control) для производства определенного химического продукта. Почему здесь так важен контроль качества? Основное действующее вещество этого химического продукта - диоксид хлора. В высоких концентрациях он опасен для здоровья. А если концентрация ниже нормы, то этот химический продукт бесполезен.\nА при чем здесь Блокчейн? Блокчейн помогает укрепить доверие к производственной компании. Потребитель знает, что никто не может изменить информацию в цепочке блоков. Это означает, что производственная компания не может подделать результаты аудита.\n\n### Контроль износа оборудования  участниками цепочки обеспечения на основе данных от IoT.  \n\n### Робот, как услуга в сервисной робототехнике.\nРобономика - это готовая к работе платформа с открытым исходным кодом, которую вы можете использовать для подключения вашего робота в качестве услуги для конечных пользователей, это называется ['Робот-как-услуга'](https://blog.aira.life/how-can-you-hire-a-robot-176ba29da565). Робономика поддерживает технологии Web3, которые осуществляют обмен технической и экономической информацией между людьми и машинами. Робономика - это чисто технический проект с открытым исходным кодом.\n\nhttps://www.youtube.com/watch?v=IEgvXcj3nSo\n"}},{node:{id:"5922f7ab6a5688e09512c16082972dce",title:"Lesson 4, Robonomics parachain in practice",path:"/docs/ru/wschool2021-robonomics-parachain-in-practice/",content:"import Asciinema from '~/components/Asciinema.vue'\n\nRobonomics parachain is not a general purpose parachain on Polkadot ecosystem. The target of Robonomics\nis building economy of machines, the parachain in this scope of aims helps to integrate Polkadot ecosystem\nwith IoT, Smart Cities and Industry 4.0 concepts.\n\n## Requirements\n\n* Docker, please [install it](https://docs.docker.com/engine/install/).\n* Polkadot-launch, please [install it](https://github.com/paritytech/polkadot-launch#install).\n\n## Launch the relay\n\nThe relay chain is a core of Polkadot, it provides [shared security](https://wiki.polkadot.network/docs/en/learn-security)\nfor all child parachains and implements message passing mechanics for them. Let's launch local instance of Rococo (polkadot testnet)\nrelay chain with two robonomics-based parachains as a childs. I'll use prepared [Docker image tag: \"winter-school-2\"](https://hub.docker.com/layers/robonomics/robonomics/winter-school-2/images/sha256-92f4795262f3ded3e6a153999d2777c4009106a7d37fd29969ebf1c3a262dc85?context=explore) but all source code of examples\navailable in [Robonomics GitHub](https://github.com/airalab/robonomics/tree/master/scripts/polkadot-launch).\n\n<Asciinema vid=\"419Jrg22ziFfMFPZlh2WtiLvg\"/>\n\nIt could take a time, but be partient. As result you should have three chain instances at ports:\n\n* `9944` - local rococo relay chain.\n* `9988` - robonomics parachain with `id=100`\n* `9989` - robonomics parachain with `id=200`\n\nIf you use remote server, you need to create some ssh tunnels on local machine:\n```\nssh -f -N -L 9944:127.0.0.1:9944 root@REMOTE_SERVER_IP\nssh -f -N -L 9988:127.0.0.1:9988 root@REMOTE_SERVER_IP\nssh -f -N -L 9989:127.0.0.1:9989 root@REMOTE_SERVER_IP\n```\nAfter that, you can use `ws://127.0.0.1:9944`, `ws://127.0.0.1:9988`and `ws://127.0.0.1:9989` in https://parachain.robonomics.network/\n\n![relay](https://ipfs.io/ipfs/QmR9Tj86yPkrXQsSwereJwqDxsZgkAdySB16G4SMHrhpBu/upcoming.png)\n\nSome time ago parachains should be registered.\n\n![relay2](https://ipfs.io/ipfs/QmR9Tj86yPkrXQsSwereJwqDxsZgkAdySB16G4SMHrhpBu/parachains.png)\n\nAnd start to produce blocks.\n\n![relay3](https://ipfs.io/ipfs/QmR9Tj86yPkrXQsSwereJwqDxsZgkAdySB16G4SMHrhpBu/parachains2.png)\n\nAs next step let's create HRMP channel to pass messages between parachains. I'll use `sudo` module call on relay chain page.\n\n![hrmp](https://ipfs.io/ipfs/QmR9Tj86yPkrXQsSwereJwqDxsZgkAdySB16G4SMHrhpBu/hrmp.png)\n\nWhen channel created, the XCM calls is available. Let's use `datalogXcm` pallet - a XCM version of `datalog` pallet.\n\n![datalogXcmSend](https://ipfs.io/ipfs/QmR9Tj86yPkrXQsSwereJwqDxsZgkAdySB16G4SMHrhpBu/datalogXcmSend.png)\n\nAs result message on second parachain will call `datalog` pallet and write data on chain.\n\n![datalogXcmRecv](https://ipfs.io/ipfs/QmR9Tj86yPkrXQsSwereJwqDxsZgkAdySB16G4SMHrhpBu/datalogXcmRecv.png)\n\nAs result, this example demonstrate how XCM could be used for cross chain usage of standard robonomics pallets.\n"}},{node:{id:"b61cd25ef2aa518313eb6a03ee50f720",title:"Lesson 3, Robonomics IO in practice",path:"/docs/ru/wschool2021-robonomics-io-in-practice/",content:'import Asciinema from \'~/components/Asciinema.vue\'\n\n## Requirements\n\n* the Docker is required, please [install](https://docs.docker.com/engine/install/) it first.\n* the [Nova SDS011](https://aqicn.org/sensor/sds011) sensor is *optional*.\n\n### SDS011 check (optional)\n\nIf you have connected SDS011 sensor then please check that it presented in `/dev` and have correct access rights.\n\n<Asciinema vid="WCFcx8C6M8e52UKDNei1xZloU"/>\n\n## Quick start\n\nWhen docker is installed let\'s launch robonomics docker image from [Official repository](https://hub.docker.com/r/robonomics/robonomics). I\'ll use `winter-school` tag during this lesson.\n\n<Asciinema vid="wM43jozIVfcRmt52ENrJ6yPlH"/>\n\nWhen docker image is ready let\'s try to read a data using `robonomics io` command (optiona if you have SDS011 device).\n\n<Asciinema vid="iztt22tKGaV8wq3cMXY1oUEYv"/>\n\nIf you have no SDS011 sensor then feel free to use virtual SDS011 sensor available in the same docker container via `vsds011.sh`. And everywhere in folloding command please use it as transparent replacement for physical sensor.\n\n<Asciinema vid="GCkSiJBA1DgpLAAHiMhIOSpgG"/>\n\nThe Robonomics IO subsystem have two kind of commands:\n\n* `read` - get data from device that support read access;\n* `write` - write data into device that support write access.\n\nSome devices support them both, in that case devices presented in both command arguments.\n\n> For example, virtual device `ipfs` supports `read` data from IPFS by hash as same as `write` data into IPFS.\n\nFull list of supported devices is possible to get running `robonomics io read` or `robonomics io write` without arguments.\n\n## IPFS access\n\nOn next step runned IPFS daemon is required. For this purpose let\'s run init IPFS and run daemon on dedicated\nterminal tab.\n\n<Asciinema vid="ir6ziXSBUDrRltTmNxg7sdXVY"/>\n\nWhen daemon launched is possible to connect docker image in separate tab and use `robonomics io` for writing and reading a data.\n\n<Asciinema vid="ZtwcmpB9Lhum2Sc221QmNwHG4"/>\n\nThe output forwarding is also works here, that means it\'s possible to forward SDS011 sensor data into IPFS using `|` (pipe) symbol in console. Let\'s try to do it.\n\n<Asciinema vid="XS0QESWG7f8ELsQe1bGQllb9O"/>\n\nWhere JSON data from SDS011 forwarded as input for IPFS writer and result is published on stdout.\n\nThis approach permits engineer extrimely quickly make a simple program just combine a primitive readers and writers from `robonomics io` tools.\n\n```bash\nrobonomics io read sds011 | gz | robonomics io write pubsub my-sensor-data\n```\n\n## Robonomics Datalog\n\n> The target of Robonomics [Datalog](https://crates.robonomics.network/robonomics_protocol/datalog/index.html) is data blockchainization. This pallet provides function to store custom data on blockchain to make it immutable, impossible to change in future.\n\nFor the final part of this lesson runned robonomics node is required. Development mode is preffered because of quick block time and already distributed balances on preset accounts. Let\'s launch it on separate terminal tab in the same container.\n\n<Asciinema vid="QnN9l0sdaZZOyK9ah0DntvCXt"/>\n\nThen private seed also required as argument for `datalog` device. This seed is used to sign transaction and presents account as a sender. Let\'s generate it using embedded `robonomics key` command.\n\n<Asciinema vid="4Cdfl9F0GgjNWv1c1ZcTBBktF"/>\n\nSave generated address and seed on safe place for use it later.\n\nCurrently address balance is zero and the network don\'t permits to send transactions from this address. To fix it let\'s transfer a bit of tokens from `Alice` account. I\'ll use Robonomics Portal on https://parachain.robonomics.network connected to local node with address `ws://127.0.0.1:9944`.\n\n![portal transfer](https://ipfs.io/ipfs/QmbpArfthyor5wFWRexgPAyjK7GaFduasc1eoReaf9TpJg/tran.png)\n\nAnd then `datalog` device could be used for saving any data on blockchain. The key `-s` is used to set secret seed of account. Account should have non-zero balance to send transactions.\n\n<Asciinema vid="FzERH9TmFB8oRuas8ZU202Pv8"/>\n\nIf every thing is correct the you should see `Datalog` event on `Explorer` page of Robonomics portal.\n\n![portal datalog](https://ipfs.io/ipfs/QmbpArfthyor5wFWRexgPAyjK7GaFduasc1eoReaf9TpJg/datalog.png)\n\nThe final step is a bit complex but it\'s good to try use all knowledge of this lesson. Let\'s make a simple program\nthat collects data from SDS011 sensor (or file), pack it into IPFS and then send `datalog` transaction to save hash on blockchain.\n\n```\nSDS011 -> IPFS -> Blockchain\n```\n\nIt\'s easy to implement using Robonomics IO, let\'s do that.\n\n<Asciinema vid="MTpiawGo8DKEn081OozbYb5mU"/>\n\nIf everything well the `Datalog` event with IPFS hash should be presented.\n\n![portal datalog complex](https://ipfs.io/ipfs/QmbpArfthyor5wFWRexgPAyjK7GaFduasc1eoReaf9TpJg/datalog_complex.png)'}},{node:{id:"d0fc95e8d40b0b2edd5dce170db9885c",title:"Lesson 2, Robonomics GitHub overview",path:"/docs/ru/wschool2021-robonomics-github-overview/",content:"\n## Step 1: AIRA Installation on VirtualBox\n\nhttps://youtu.be/ISKilRfY3Ow\n\n## Step 2: Connecting Aira via SSH\n\nhttps://youtu.be/W0rOcRA2sEc\n\n## Step 3: Interact with AIRA\n\nhttps://youtu.be/fhRTF2mddfU"}},{node:{id:"eb860b2d92e7c0308e2c50355c842b57",title:"Robonomics Winter School 2021 introduction",path:"/docs/ru/wschool2021-intro/",content:"\nRobonomics Winter School 2021 is held from 10 to 24 February **online**. It's **free**.\n\nWe are publishing **lessons** online in different ways: text here in Wiki, video on our [YouTube channel](https://www.youtube.com/channel/UCrSiho1uB-1n6F8cZpCLhjQ), announce in [Twitter account](https://twitter.com/AIRA_Robonomics). Please, keep in mind, that video lessons and text lessons are not the same. For the start we plan to publish two language versions: English and Russian. \n\nJoin us, take your steps through the lessons, **discuss and ask questions** in [Discord](https://discord.gg/5UWNGNaAUf).\n\n## Watch opening ceremony\n\nhttps://youtu.be/kQaSwNYHJQ8\n\n## Basic information\n\nTake a look at [page about school](https://robonomics.network/blog/winter-robonomics-school/) on our website. We are collecting there all basic information: shedule, infopartners, links.\n\n## Links, links, links\n\nLets repeat what links do we have for following Robonomics Winter School 2021:\n\n- [Summary on website](https://robonomics.network/blog/winter-robonomics-school/)\n- Wiki for text lessons, YOU ARE HERE 🤓\n- [Video lessons](https://www.youtube.com/channel/UCrSiho1uB-1n6F8cZpCLhjQ)\n- [Fast announce on Twitter](https://twitter.com/AIRA_Robonomics)\n- [Questions, Discussions, Quizes in Discord](https://discord.gg/5UWNGNaAUf)\n\n**Lets start learn Robonomics!**"}},{node:{id:"594be39ba5f64870ee24748a04b9071e",title:"Lesson 5, Connectivity",path:"/docs/ru/wschool2021-connectivity-service/",content:'\n## IoT as a Multiple Pie\n\n* Device Software\n    * FreeRTOS\n    * ESP/Arduino\n    * Single-board computers (RPi, LattePanda etc)\n* Connectivity\n    * IoT Hub\n    * IoT Manager\n* Analytics Services\n    * AWS\n    * Google Cloud IoT Core\n    * ThingsBoard\n\nAs a rule, most are not interested in sensors and servers, but data analytics.\nTo get it, you need to decide which device to use, how to work with it and where to connect\n\n## Device Software\n\nConsider the example of a home weather station. It is necessary to collect data on air pollution (SDS011), temperature and humidity (BME). The ESP8266 microcontroller can handle this task.\n\nRequirements:\n\n* Correctly read data from sensors\n* Have a unique identifier\n* Transfer data to a known server\n* Provide digital signature of data (optional)\n\nYou can find the current firmware [here](https://github.com/LoSk-p/sensors-software/tree/366b19bf447a5fc19220ef89eab0f2440f8db1c2)\n\n## What is Connectivity? \n\nIn the IoT world, connectivity refers to the connection of various IoT devices to the Internet to send data and / or control the device.\n\nWell-known architectural solutions can be roughly divided into 3 groups:\n\n* Fully decentralized. For example, devices are connected by a mesh network. Not suitable for wide area networks due to high hardware requirements\n* Centralized. For example, AWS. Provides a single entry point and ease of connection, but there is a high risk of failure in case of server problems\n* Hybrid. For example, [Robonomics Connectivity](https://github.com/airalab/sensors-connectivity). Provides an address for devices on a "local" network and publishes data to a distributed IPFS message channel\n\n## Comparison of AWS and Robonomics Connectivity\n\n| Management services \t| AWS                               \t|               Robonomics              \t|\n|---------------------\t|-----------------------------------\t|---------------------------------------\t|\n| Transaction type    \t| Technical                         \t| Technical and economic                \t|\n| Security            \t| IT-company cloud control          \t| Polkadot and Ethereum                 \t|\n| Protocol            \t| HTTPS, MQTT                       \t| IPFS, Robonomics                      \t|\n| Ecosystem           \t| Private                           \t| Shared                                \t|\n| Access to DeFi      \t| No                                \t| Yes                                   \t|\n| Costs               \t| Pushing data - $1-2 a sensor      \t| Pushing data - $0                     \t|\n|                     \t| Shadow         - from $10 a month \t| Digital Twin    - $0,01 a transaction \t|\n\n## Installing Connectivity on Aira\n\nhttps://www.youtube.com/watch?v=JbBNMHAzJKM\n\n### Requirements\n\n* [VirtualBox 6.1](https://www.virtualbox.org/wiki/Downloads) and above\n* [Aira OS ova image](https://static.aira.life/ova/airaos-21.03_robonomics-winter-school.ova)\n\nImport Aira image in VirtualBox as described [here](/docs/aira-installation-on-vb/)\n\nSet up a connection over [SSH](/docs/aira-connecting-via-ssh/)\n\nWhen everything is set and you successfully log in via SSH, let\'s clone the main package and build it \n\n```\ngit clone https://github.com/airalab/sensors-connectivity\ncd sensors-connectivity\nnix build -f release.nix\n```\n\nNow let\'s create a copy of the default configuration file for later usage. \nTo learn about all the options check [this article](/docs/configuration-options-description/) out.\nThen launch the package with `roslaunch`\n\n```\ncp config/default.json config/my.json\nsource result/setup.zsh\nroslaunch sensors_connectivity agent.launch config:=$PWD/config/my.json\n```\n\n## Connect Sensor to Connectivity\n\nhttps://www.youtube.com/watch?v=yxqxBk-6bpI\n\n### Requirements\n\n* [Nova SDS011](https://aqicn.org/sensor/sds011) sensor \n* [Yarn Packet Manager](https://yarnpkg.com/getting-started/install)\n\nNow let\'s connect a real sensor, forward USB port to the virtual machine, set up a map and look at our own measurements\n\nFirst, stop the Aira OS if it was running and add a corresponding USB device\n\n![VB USB Forwarding](../images/vb_forward_usb.jpg)\n\nStart the VM, connect via SSH and set `comstation/port` option according to your USB device in the VM. Also enable `comstation` and set your latitude and longitude. In the end `config/my.json` should look like this:\n\n```\n{\n   "general":{\n      "publish_interval":30\n   },\n   "comstation":{\n      "enable":true,\n      "port":"/dev/ttyUSB0",\n      "work_period":0,\n      "geo":"59.944917,30.294558",\n      "public_key":""\n   },\n   "httpstation":{\n      "enable":false,\n      "port":8001\n   },\n   "mqttstation": {\n      "enable": false,\n      "host": "connectivity.robonomics.network",\n      "port": 1883\n   },\n   "luftdaten":{\n      "enable":false\n   },\n   "robonomics":{\n      "enable":true,\n      "ipfs_provider":"/ip4/127.0.0.1/tcp/5001/http",\n      "ipfs_topic":"airalab.lighthouse.5.robonomics.eth"\n   },\n   "datalog":{\n      "enable":false,\n      "path":"",\n      "suri":"",\n      "remote":"wss://substrate.ipci.io",\n      "dump_interval":3600,\n      "temporal_username":"",\n      "temporal_password":""\n   },\n   "dev":{\n      "sentry":""\n   }\n}\n```\n\n> If you don\'t have a real sensor, you can use `sensors-connectivity/utils/virtual-sensor.py` script to emulate one\n> \n> Enable `HTTPStation` and disable `COMStation` by changing the configuration file as:\n> ```\n> {\n>    "general":{\n>       "publish_interval":30\n>    },\n>    "comstation":{\n>       "enable":false,\n>       "port":"/dev/ttyUSB0",\n>       "work_period":0,\n>       "geo":"59.944917,30.294558",\n>       "public_key":""\n>    },\n>    "httpstation":{\n>       "enable":true,\n>       "port":8001\n>    },\n>    ...\n> }\n> ```\n>\n> and launching `utils/virtual-sensor.py` in a dedicated terminal in the VM\n\nSave the file and launch connectivity from `sensors-connectivity` folder:\n\n```\nsource result/setup.zsh\nroslaunch sensors_connectivity agent.launch config:=$PWD/config/my.json\n```\n\nYou should see first measurements in the console output\n\nLook for your IPFS ID in the VM. It appears right after booting the image or via `ipfs id` command. We will need it later.\n\nNow let\'s set up our own instance of the map. On your laptop (not in the VM) clone [this](https://github.com/airalab/sensors.robonomics.network) repository and build the app:\n\n```\ngit clone https://github.com/airalab/sensors.robonomics.network\ncd sensors.robonomics.network\nyarn install\n```\n\nEdit `src/agents.json` file and put your IPFS ID. For example:\n\n```\n[\n  "12D3KooWSCFAD3Lpew1HijniE6oFTuo4jsMwHzF87wNnXkpCRYWn"\n]\n```\n\nLaunch the map:\n\n```\nyarn serve\n```\n\nGo to [http://localhost:8080/](http://localhost:8080/) or the address yarn gave you and look for the sensor.\n\n## Practice\n\n### Trajectory 1. Flash a sensor ESP + SDS011\n\nRequirements:\n\n* ESP8266\n* At least one of sensors SDS011, BME280, HTU21D\n\nUse the [instruction](https://wiki.robonomics.network/docs/connect-sensor-to-robonomics/) to connect a sensor to Robonomics Connectivity. \n\nCheck that your sensor appears on our [map](https://sensors.robonomics.network/#/).\n\n### Trajectory 2. Launch Connectivity\n\nRequirements:\n\n* ROS\n* Python\n* Nix (optional)\n\nBuild and launch [sensors-connectivity](https://github.com/airalab/sensors-connectivity#get-a-package-and-build)\n\n> How it build, install [here](https://wiki.robonomics.network/docs/iot-sensors-connectivity/) and configure [here](https://wiki.robonomics.network/docs/configuration-options-description/)\n\nGeneral scheme of the package:\n\n```\n    station1 \\                        / feeder1\n    station2 -  sensors-connectivity  - feeder2\n    station3 /                        \\ feeder3\n```\n\nThe choice is proposed to implement either a new station, for example, a random number generator, or a new feeder, for example, displaying a string on the screen.\n\nInterface `IStation` [here](https://github.com/airalab/sensors-connectivity/blob/master/src/stations/istation.py#L73).\n\nInterface `IFeeder` [here](https://github.com/airalab/sensors-connectivity/blob/master/src/feeders/ifeeder.py#L5)\n\n'}},{node:{id:"61ad524f06777c580d9eeac4106fcc4f",title:"Lesson 1, Connect robotics to user app",path:"/docs/ru/wschool2021-connect-robotics-to-user-app/",content:"\nhttps://youtu.be/NOQxyojvaao\n\n- [Reference tutorial on Wiki](https://wiki.robonomics.network/docs/get-weather-on-fuji-mountain/)\n- [Dapp](https://dapp.robonomics.network/#/)"}},{node:{id:"cac162909e00f6ed8548f14af8ea4670",title:"Lesson 6.2, Build IoT Dapps For End Users",path:"/docs/ru/wschool2021-build-dapp-interface/",content:'\n![Building User Interface for Decentralized Applications, on top of Robonomics and Polkadot](../images/build-dapp-interface/sum.gif "Building User Interface for Decentralized Applications, on top of Robonomics and Polkadot")\n\n## Introduction\n\nThis tutorial continues the previous lesson, where you have already built simple application and were focused on connecting an account to a node, sending transactions and other vital functions of the dapp. Now we will **build user-friendly interface** for this application.\n\n## Prerequisites\n\nThis tutorial is designed for people who are familiar with **HTML, CSS, JavaScript** a bit and want to learn how to apply these skills for decentralized applications.\n\nFor building your dapp\'s interface you can choose any JavaScript framework which is comfortable for you or even try to build interface without any framework. In Robonomics 2021 we use [Vue.js](https://vuejs.org) as it is quite scalable and easy to use.\n\n## Set up for this tutorial\n\nIf you start with this step and prefer to **learn by doing**, please, follow this to-do list to launch the resulting dapp from the previous lesson:\n\n1. Download a local Robonomics node from [releases page](https://github.com/airalab/robonomics/releases/) that fits your OS. If you do not find your system in the latest release, please, find the most recent version in the previous releases.\n\n2. Launch the Robononomics node in the Developer mode by typing `./robonomics --dev` in your terminal.\n\n3. Download the Polkadot Extension for Chrome or Firefox [here](https://polkadot.js.org/extension/)\n\n4. Clone [this repository](https://github.com/vol4tim/example-robonomics-dapp/).\n\n5. Install [Yarn](https://yarnpkg.com).\n\n6. Install [@vue/cli](https://cli.vuejs.org/guide/installation.html)\n\n7. Start developing dapp with `yarn serve` command in your terminal.\n\n\n**You should get this screen in your browser:**\n\n![Dapp Start](../images/build-dapp-interface/dapp-start.png "Dapp Start")\n\n\n<details>\n\n  <summary>Some additional tips for launching</summary>\n\n  - Make sure your **node is running**:\n    ![Example of running a Robonomics node](../images/build-dapp-interface/robonomics-node-launch.png "Example of running Robonomics node")\n\n  - In **macOS** you may need to change the **access permissions** `chmod +x robonomics`\n\n  - Make sure you allowed **access for Polkadot Extension**:\n    ![Polkadot Extension giving access](../images/build-dapp-interface/polkadot-permission.png "Polkadot Extension giving access")\n\n  - If you have errors in log of the running node and dapp is not loading correctly, please, try to delete data base of dev chain: `sudo rm -rf <YOUR LOCAL PATH>/robonomics/chains/dev/db/` and restart the node. If it does not help, restart your machine.\n\n</details>\n\n## Inspecting the code\n\nLet\'s inspect the structure of the dapp to clear up what and where we can fix in order to change UI.\n\n```\n.\n├── public/\n│   ├── favicon.ico           # Icon for your dapp\n│   └── index.html            # The template file (injects icons links, JavaScript and CSS files for the app)\n├── src/\n│   ├── assets/               # Folder for images and global styles\n│   ├── components/           # Folder with components\n│   │   ├── Datalog.vue       # Tab \'Datalog\' in dapp\n│   │   ├── Demo.vue          # Tab \'Demo\' in dapp\n│   │   ├── Launch.vue        # Tab \'Launch\' in dapp\n│   ├── utils/                # Folder with important for app js functions (we will touch api.js in this tutorial)\n│   ├── App.vue               # The root of our app, contains HTML, CSS, JS for the whole page. In fact it is Vue Component also\n│   ├── main.js               # The app’s entry file, we will import here global styles\n├── ...                       # There are config files and dependencies files, that we will not change mannually\n├── README.md                 # You can write here any instructions for your dapp\n\n```\n\n> **The code of this tutorial is in this [repository](https://github.com/positivecrash/wscool21-ui-dapp)**\n\n## CSS-in-JS VS. Global stylesheets\n\nIn this tutorial I show how to change the interface of a small dapp from scratch without any stable library of UI components. So I will import and create not only different Vue components, but also write my own styles.\n\nIf your application is big or your project has the whole bunch of dapps, in future you\'d better look for building library of components specifically for your project to make UI more organized and efficient ([for example, here is a tool for organizing components](https://storybook.js.org)). Or if you are okay with standart interface themes, you can use any UI Libraries of third party ([for example](https://vuetifyjs.com/)).\n\n## First import or where to start\n\nI don\'t have any specific design for this dapp, but I have [Brandbook](https://static.robonomics.network/assets/Robonomics-Visual-Identity.pdf) and [quit well-established](https://robonomics.network) typography, fonts, button styles etc. So for the start I will import the following css files globally:\n\n```\n...\n├── src/\n│   ├── assets/\n│   │   ├── styles/\n│   │   │   ├── reset.css         # The goal is to reduce browser inconsistencies\n│   │   │   ├── variables.css     # Contains specific values to be reused such as colors, font-names, space values etc.\n│   │   │   ├── typography.css    # Global typography for the whole dapp\n│   │   │   ├── animation.css     # Keyframe animations used throughout the dapp\n...\n\n```\n\nThe content of any of these files you can write in App.vue instead, if it fits your perception better. But I recommend to import some CSS files globally for this example to keep App.vue a little bit more clear.\n\nImport these CSS files into your app by editing **main.js** file:\n\n![Import global CSS in Vue app](../images/build-dapp-interface/import-css-vue-1.png "Import global CSS in Vue app")\n\n```JS\nimport \'./assets/styles/reset.css\'\nimport \'./assets/styles/variables.css\'\nimport \'./assets/styles/typography.css\'\nimport \'./assets/styles/animation.css\'\n```\n\n**Check if fonts have been changed in the dapp:**\n\n![Dapp Interface changing step 1](../images/build-dapp-interface/dapp-1.png "Dapp Interface changing step 1")\n\n\n## Change layout and prettify the title\n\nLet\'s change layout of the application. As I mentioned earlier, you can write your styles directly in App.vue, but for this example I prefer to separate this process.\n\n- Comment or delete styles from tag `<style>` in **App.vue**\n\n- Create css file **app.css** in styles folder for this application and import it into **main.js**\n\n```JS\nimport \'./assets/styles/app.css\'\n```\n\n<details>\n\n<summary>Write in app.css first basic styles for the app:</summary>\n\n```css\n#app {\n  display: grid;\n  grid-template-rows: auto 1fr;\n  align-items: stretch;\n\n  text-align: center;\n}\n\nbody {\n  background-color: var(--color-gray-light);\n}\n```\n\n</details>\n\n\n<details>\n\n<summary>Change the title of the app [App.vue]</summary>\n\n```html\n<div class="top">\n    <h1>dApp Robonomics Demo</h1>\n    <i>Winter School 2021</i>\n    <img class="label" alt="" src="./assets/images/robonomics-winter-school-2021-logo.png"/>\n</div>\n```\n\n</details>\n\n\n\n<details>\n\n<summary>Write styles for the title [app.css]</summary>\n\n```css\n.top {\n  position: relative;\n  padding-top: var(--space);\n  padding-bottom: calc(var(--space)*2);\n\n  border-bottom: 2px solid var(--color-dark);\n  background-color: var(--color-light);\n}\n\n.top h1 {\n  font-size: 1.8rem;\n}\n\n.top i {\n  display: block;\n}\n\n.top .loader-label {\n  display: block;\n  margin: calc(var(--space)/3) auto;\n  max-width: 150px;\n\n  visibility: hidden;\n  opacity: 0;\n  animation: 0.5s FadeIn 0.3s ease forwards, 0.5s ScaleDown 0.1s ease forwards;\n}\n\n.top .label {\n  position: absolute;\n  width: 100px;\n  bottom: -50px;\n  left: calc(50% - 50px);\n  display: block;\n\n  transform: translateY(1rem);\n  visibility: hidden;\n  opacity: 0;\n  animation: 0.7s FadeIn 0.5s ease forwards, 1s ScaleUp 0.5s ease forwards;\n}\n```\n\n</details>\n\n- Place a file with the logo of the Robonomics winter school 2021 in the folder **./src/assets/images**\n\n**You will get the following screen:**\n![Dapp Interface changing step 2](../images/build-dapp-interface/dapp-2.png "Dapp Interface changing step 2")\n\n## Define styles according to the dapp\'s data\n\nNow I will wrap the app\'s content in `<div>` element. Also I will need different styles for different states of the dapp (loaded or not loaded).\n\n- Open the **App.vue** and write a wrapping element:\n```html\n<div class="content">\n  \x3c!--here is everything going after the title--\x3e\n</div>\n```\n- Find the variable `load`, it has already been defined in `<script>`.\n- Pass an object to `v-bind:class` to dynamically toggle classes (I use shortened version `:class`):\n```html\n<div class="content" :class="{ load: load }">\n  \x3c!--here is everything going after the title--\x3e\n</div>\n```\nThat\'s how you can easily toggle styles in your app according to the data you get. You will see the usage of this class below.\n\n## Define views according to the dapp\'s data\n\nLet\'s change the loader for the app.\n- For this purpose I will import my component from another Robonomics project \n\n<details>\n\n<summary>./src/components/AnimatedRobonomicsLogo.vue</summary>\n\n```HTML\n<template>\n  <div class="logo-animated" :style="{transform: \'scale(\'+scale+\')\'}">\n      <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="196.9px" height="170.3px" viewBox="0 0 196.9 170.3" style="enable-background:new 0 0 196.9 170.3;" xml:space="preserve">\n\t\t<g transform="translate(2530 155)">\n            <path class="line" d="M-2523.4,7.9l184.2,0.5l-91.7-158.1L-2523.4,7.9z"/>\n\n            <circle class="dot" cx="-2339.7" cy="8.7" r="6.6"/>\n            <circle class="dot" cx="-2523.4" cy="8.2" r="6.6"/>\n            <circle class="dot" cx="-2430.8" cy="-148.4" r="6.6"/>\n            \n            <path class="triangle-1" d="M-2477.3-18.3l92.1,0.3l-45.8-79L-2477.3-18.3z"/>\n            <path class="triangle-2" d="M-2431.2-18.1l46,0.1l-45.8-79L-2431.2-18.1z"/>\n            <path class="triangle-3" d="M-2477.3-18.3l92.1,0.3l-46-20.3L-2477.3-18.3z"/>\n          </g>\n\t</svg>\n  </div>\n</template>\n\n<script>\n\nexport default {\n\n  props: {\n    scale: {\n      type: String,\n      default: \'1\'\n    },\n  },\n\n};\n<\/script>\n\n<style scoped>\n    /*\n    Global styles required:\n    FadeIn - keyframe animation from animation: .css\n    all --color- variables from variables.css\n    */\n\n    .logo-animated {\n        transform-origin: 0 0;\n    }\n\n    .logo-animated .dot {\n        fill: var(--color-blue);\n        visibility: hidden;\n        opacity: 0;\n        animation: 1s FadeIn 0.3s ease forwards;\n    }\n\n    .logo-animated .line {\n        fill: transparent;\n        stroke: var(--color-blue);\n        stroke-miterlimit:10;\n        stroke-dasharray: 700;\n        stroke-dashoffset: 700;\n        animation: 1s DrawSvgPath 0.5s ease-in-out forwards; \n    }\n\n    .logo-animated .triangle-1 {\n        fill: var(--color-blue);\n        visibility: hidden;\n        opacity: 0;\n        animation: 0.5s FadeIn 0.3s ease forwards, 5s logo-triangle-1 0.1s linear infinite;\n    }\n\n    .triangle-2 {\n        fill: var(--color-violet-light);\n        visibility: hidden;\n        opacity: 0;\n        animation: 0.5s FadeIn 0.3s ease forwards, 5s logo-triangle-2 0.1s linear infinite;\n    }\n\n    .triangle-3 {\n        fill: var(--color-violet-mid);\n        visibility: hidden;\n        opacity: 0;\n        animation: 0.5s FadeIn 0.3s ease forwards, 5s logo-triangle-3 0.1s linear infinite;\n    }\n\n\n    @keyframes DrawSvgPath\n        {\n        to {\n            stroke-dashoffset: 0;\n        }\n        }\n\n    @keyframes logo-triangle-1\n    {\n        0% { fill: var(--color-blue); }\n        25% { fill: var(--color-blue); }\n        50% { fill: var(--color-blue); }\n        75% { fill: var(--color-violet-light); }\n        100% { fill: var(--color-blue); }\n    }\n\n    @keyframes logo-triangle-2\n    {\n        0% { fill: var(--color-violet-light); }\n        25% { fill: #E0BDED; }\n        50% { fill: var(--color-blue); }\n        75% { fill: var(--color-blue); }\n        100% { fill: var(--color-violet-light); }\n    }\n\n    @keyframes logo-triangle-3\n    {\n        0% { fill: var(--color-violet-mid); }\n        25% { fill: var(--color-violet-light); }\n        50% { fill: var(--color-violet-light); }\n        75% { fill: var(--color-violet-dark); }\n        100% { fill: var(--color-violet-mid); }\n    }\n</style>\n```\n\n</details>\n\n- Register this component in **App.vue**\n```JS\nexport default {\n  components: {\n    Loader: () => import("./components/AnimatedRobonomicsLogo")\n  }\n}\n```\n- Insert it with conditional Vue directive `v-if`, using the already known variable `load`:\n```HTML\n<div class="content" :class="{ load: load }">\n  <Loader v-if="load" />\n  <template v-else>\n    \x3c!-- here will be main content of loaded dapp --\x3e\n  </template>\n</div>\n```\n- Watch the result in browser. It has some issues that we will fix now:\n\n1. Loader pops up to the title (it should be in the center). Let\'s insert these lines to **app.css**:\n```css\nbody, html, #app {\n  height: 100%;\n  position: relative;\n}\n```\n2. If your connection goes too fast, you will see just blinking loader for a moment. It may confuse a lot. Let\'s set a timeout for the app\'s responce. To do that open **api.js** and find in the function `initAccount` this code:\n```JS\nconst timeout = new Promise(resolve => {\n  setTimeout(resolve, 300);\n});\n```\nI set `1700` instead of `300` and check the result:\n\n![Dapp Interface changing step 3](../images/build-dapp-interface/dapp-3.gif "Dapp Interface changing step 3")\n\n\n## Using reusable components\n\nYou have already watched how to register and use a component in the previous section about Loader, but now I want to focus on it more carefully.\n\nLet\'s change the Account section. Here I will use self-written components (box, button, icon) and the third party\'s one ([from Vue Polkadot Library](https://vue-polkadot.js.org/vue-ui/vue-identicon/#vue-polkadot-vue-identicon )).\n\n### Adding the box\n\n<details>\n\n<summary>Create Box component in ./src/components/Box.vue file </summary>\n\n```HTML\n<template>\n    <section class="box" :class="classList">\n        <slot />\n    </section>\n</template>\n\n<script>\n\nexport default {\n\n  props: {\n    classList: {\n      type: String\n    },\n  },\n\n};\n<\/script>\n\n<style>\n    /*\n    Global styles required for css variables from variables.css\n    */\n\n    .box {\n        background-color: var(--color-light);\n        border: 1px solid var(--color-dark);\n        padding: calc(var(--space)*0.5) var(--space);\n        box-shadow: 2px 2px 0 var(--color-dark);\n        margin-bottom: calc(var(--space)*1.5);\n    }\n</style>\n```\n</details>\n\nNow we can use it many times throught out the dapp. Let\'s see this on the Account section example:\n\n- Register component (**App.vue**):\n\n```JS\nexport default {\n  components: {\n    Box: () => import("./components/Box")\n  }\n}\n```\n\n- Use it for the Account section with an additional class passed with prop `classList`:\n\n```HTML\n<Box :classList="\'account\'">\n  Account: <b>{{ account }}</b> {{ balance }} |\n  <button @click="faucet">\n    faucet\n  </button>\n</Box>\n```\n\n**Check the result:**\n![Dapp Interface changing step 4](../images/build-dapp-interface/dapp-4.png "Dapp Interface changing step 4")\n\n### Adding the button\n\nYou may even not notice the button in the box that we have added. Let\'s fix it and add a component for buttons as it is not the only button in the app.\n\n<details>\n\n<summary>Create Button component in ./src/components/Button.vue file </summary>\n\n```HTML\n<template>\n  <button type="button" :class="classList" @click="onClick" :disabled="disabled" class="inline-block">\n    {{ label }}\n  </button>\n</template>\n\n<script>\n\nexport default {\n\n  components: {\n    Icon: () => import("./Icon")\n  },\n\n  props: {\n    label: {\n      type: String,\n    },\n    type: {\n      type: String,\n      default: \'primary\',\n      validator: function (value) {\n        return [\'primary\', \'secondary\'].indexOf(value) !== -1;\n      }\n    },\n    disabled: {\n      type: Boolean,\n      default: false,\n    },\n    size: {\n      type: String,\n      default: \'medium\',\n      validator: function (value) {\n        return [\'small\', \'medium\', \'large\'].indexOf(value) !== -1;\n      }\n    }\n  },\n\n  computed: {\n    classList() {\n      return {\n        \'button\': true,\n        [`${this.type}`]: true,\n        [`button__${this.size}`]: true,\n      };\n    },\n  },\n\n  methods: {\n    onClick() {\n      this.$emit(\'onClick\');\n    },\n  },\n\n};\n<\/script>\n\n<style>\n    /*\n    Global styles required for css variables from variables.css\n    */\n\n    .button {\n        appearance: none;\n        -webkit-appearance: none;\n        outline: 0;\n        border: 0;\n\n        transition: 0.1s all linear;\n\n        padding: .15rem 0.6rem;\n        border-width: 1px;\n        border-style: solid;\n        border-radius: .25rem;\n  \n        cursor: pointer;\n\n        font-family: var(--font-family);\n        font-size: calc(var(--font-size)*0.9);\n        line-height: 1;\n        font-weight: 500;\n\n        text-transform: uppercase;\n        letter-spacing: 1px;\n    }   \n\n    .button:not([disabled]):hover {\n    filter: saturate(1.5);\n    }\n\n    .button[disabled] {\n        cursor: default;\n        opacity: 0.6;\n    }\n\n    button.primary {\n        border-color: var(--color-green);\n        background-color: var(--color-green);\n        color: var(--color-light);\n    }\n\n    button.secondary {\n        border-color: var(--color-blue);\n        color: var(--color-blue);\n    }\n\n    button.secondary:not([disabled]):hover {\n        background-color: var(--color-blue);\n        color: var(--color-light);\n    }\n\n    .button__small {\n        font-size: .85rem;\n        padding: .1rem 0.45rem;\n    }\n\n    .button__large {\n        font-size: 1.2rem;\n        padding: .5rem 1.7rem;\n    }\n\n</style>\n```\n</details>\n\n\n- Register the component (**App.vue**):\n\n```JS\nexport default {\n  components: {\n    Button: () => import("./components/Button")\n  }\n}\n```\n\n- Use it for the \'Faucet\' button with props defined in the \'Button\' component\n\n```HTML\n<Box :classList="\'account\'">\n  Account: <b>{{ account }}</b> {{ balance }}\n  <Button label="Faucet" size="large" @onClick="faucet" />\n</Box>\n```\n\n**We get this view:**\n![Dapp Interface changing step 5](../images/build-dapp-interface/dapp-5.png "Dapp Interface changing step 5")\n\nFor the Button component we have emited the click from prop with `@onClick`, so I will pay attention if the faucet function is working correctly now (the balance should change on click):\n\n![Dapp Interface changing step 6](../images/build-dapp-interface/dapp-6.gif "Dapp Interface changing step 6")\n\n### Adding the icon\n\nLet\'s add an icon to this button to attract more attention to this element of the interface, as user can\'t interact with the dapp properly without units and clicking on this button.\n\nFor this purpose you can use any ready Vue library for icons, I will create my own component with the icon.\n\n- I found an appropriate icon on [the big online archive of icons](https://www.flaticon.com).\n- Downloaded .svg file and edited it in the vector graphics editor to make the proper size.\n- Inserted svg as a text in the Icon.vue component.\n\n<details>\n\n<summary>Here is what I got as the Icon.vue component</summary>\n\n```JS\n<template>\n  <div class="icon inline-block" :class="classList">\n    <svg v-if="icon == \'faucet\'" class="icon-fill" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" :width="SvgWidth(20)"  viewBox="0 0 20 24.9" style="enable-background:new 0 0 20 24.9;" xml:space="preserve">\n      <path d="M2.7,24.9c0.2,0,2.4,0,2.4-2.4c0-2-2.2-5.2-2.2-5.2s-2.5,3.3-2.5,5.3C0.4,24.6,2.4,24.9,2.7,24.9z M20,10.8V7.2V3.1h-2.6v2.6h-3.1V1.5h2.6c0.4,0,0.8-0.3,0.8-0.8S17.3,0,16.9,0h-6.7C9.8,0,9.5,0.3,9.5,0.8s0.3,0.8,0.8,0.8h2.6v4.1H7.9c-4.7,0-6.2,3.2-6.3,4.8c0,0,0,0.1,0,0.1v2.8H0v2.1h6.2v-2.1H4.6v-2.7c0-0.3,0.4-1.9,3.3-1.9h9.6v2.1L20,10.8L20,10.8z"/>\n    </svg>\n\n  </div>\n</template>\n\n<script>\n\nexport default {\n  props: {\n    icon: {\n      type: String\n    },\n    classList: {\n      type: String\n    },\n    scale: {\n      type: String,\n      default: \'1\'\n    },\n  },\n\n  methods: {\n    SvgWidth(SvgWidth) {\n      return `${SvgWidth * this.scale}px`;\n    }\n  }\n};\n<\/script>\n\n<style>\n.icon {\n    line-height: 1;\n}\n</style>\n\n```\n\n</details>\n\nTo use it with the button, edit the Button component.\n\nImport the Icon in **Button.vue**:\n\n```JS\ncomponents: {\n    Icon: () => import("./Icon")\n}\n```\n\nRegister prop:\n\n```JS\nprops: {\n  icon: {\n    type: String,\n    default: \'none\'\n  }\n}\n```\n\nAdd the Icon to the button (we can specify different templates with `v-if` condition):\n\n```HTML\n<template v-if="icon != \'none\'">\n  <Icon :icon="icon" />\n  <span v-if="label != \'\'" class="inline-block">{{ label }}</span>\n</template>\n<template v-if="icon == \'none\' & label != \'\'">\n  {{ label }}\n</template>\n```\n\nAdd styles:\n\n```CSS\n.button .icon-fill path {\n  fill: var(--color-light);\n}\n\n.button > *:not(:last-child) {\n  margin-right: calc(var(--space)/2);\n}\n\n```\n\nAdd the icon prop into the button in **App.vue**:\n\n```HTML\n<Button label="Faucet" size="large" icon="faucet" @onClick="faucet" />\n```\n\n**Check:**\n\n![Dapp Interface changing step 7](../images/build-dapp-interface/dapp-7.png "Dapp Interface changing step 7")\n\n### Add the Polkadot avatar\n\n- Install [@vue-polkadot/vue-identicon](https://vue-polkadot.js.org/vue-ui/vue-identicon/#vue-polkadot-vue-identicon)\n\n- Import to App.vue:\n```JS\ncomponents: {\n    Identicon: () => import("@vue-polkadot/vue-identicon")\n}\n```\n\n- Insert the avatar instead of the word \'Account\', pass props according to the documentation, use `account` data as a value prop:\n```HTML\n<Identicon\n  :value="account"\n  :theme="\'polkadot\'"\n  :size="40"\n  :class="\'inline-block\'"\n/>\n```\n\n**Check:**\n\n![Dapp Interface changing step 8](../images/build-dapp-interface/dapp-8.png "Dapp Interface changing step 8")\n\n## Data manipulation for the better view\n\nLet\'s cut the account address:\n\n- Wrap the variable `account` in the computed property:\n\n```JS\ncomputed: {\n  AccountAddress() {\n    return this.account.slice(0, 6) + "..." + this.account.slice(-4);\n  }\n}\n```\n\n- Replace the variable `account` with `AccountAddress` in the template\n\n**Check:**\n\n![Dapp Interface changing step 9](../images/build-dapp-interface/dapp-9.png "Dapp Interface changing step 9")\n\n## CSS magic\n\nLet\'s prettify the account section a little bit more:\n\n<details>\n\n<summary>Template</summary>\n\n```HTML\n<Box :classList="\'account\'">\n              \n  <div class="account__address">\n    <Identicon\n      :value="account"\n      :theme="\'polkadot\'"\n      :size="40"\n      :class="\'inline-block\'"\n    />\n\n    <code class="inline-block">{{ AccountAddress }}</code>\n  </div>\n  \n  <div class="account__balance">{{ balance }}</div>\n\n  <Button label="Faucet" size="large" @onClick="faucet" />\n  \n</Box>\n```\n\n</details>\n\n\n<details>\n\n<summary>Styles (in app.css)</summary>\n\n```CSS\n.account {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  align-items: center;\n  justify-items: stretch;\n  column-gap: var(--space);\n}\n\n.account__balance {\n    font-size: 150%;\n    font-weight: 500;\n    font-family: var(--font-family-code);\n    white-space: nowrap;\n}\n\n.account__address > *:not(:last-child) {\n    margin-right: calc(var(--space)/2);\n}\n```\n\n</details>\n\n![Dapp Interface changing step 10](../images/build-dapp-interface/dapp-10.gif "Dapp Interface changing step 10")\n\nLet\'s edit styles for the tabs:\n\n<details>\n\n<summary>Styles (in app.css)</summary>\n\n```CSS\n.tabs {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  margin-top: calc(var(--space)*2.5);\n}\n\n.tabs button {\n  text-transform: uppercase;\n  letter-spacing: 1px;\n  border-width: 0 0 1px;\n  font-family: var(--font-family);\n  font-size: calc(var(--font-size)*1.5);\n  font-weight: 300;\n  cursor: pointer;\n  transition: 0.2s all linear;\n}\n\n.tabs button:not(.active) {\n  opacity: 0.5;\n  border-color: var(--color-gray)\n}\n\n.tabs-content {\n  padding-top: var(--space);\n}\n```\n\n</details>\n\n<details>\n\n<summary>Minimal template changes:</summary>\n\n```HTML\n<div class="tabs-content">\n  <Demo v-if="tab === \'demo\'" :api="api" :account="account" />\n  <Launch v-if="tab === \'launch\'" :api="api" :account="account" />\n  <Datalog v-if="tab === \'datalog\'" :api="api" :account="account" /> \n</div>\n```\n\n</details>\n\n![Dapp Interface changing step 11](../images/build-dapp-interface/dapp-11.gif "Dapp Interface changing step 11")\n\n> Let me remind you that the finished code for this tutorial is in [this](https://github.com/positivecrash/wscool21-ui-dapp) repository. And let\'s shift to the next steps :)\n\n## Datalog\n\nStart with fixing UI elements that are already known in the dapp: buttons (same as we have done for the \'Faucet\', but with different props).\n\nThen I will wrap these elements in `<fieldset>` to separate them by meaning. And I will write my own styles for the fieldset and input elements.\n\n<details>\n\n<summary>Template in Datalog.vue:</summary>\n\n```HTML\n<div class="tools">\n  <fieldset>\n    <Button label="Read data" size="large" type="secondary" @onClick="read" />\n  </fieldset>\n\n  <fieldset>\n    <input v-model="data" :disabled="isWrite" class="large" />\n    <Button label="Write" :disabled="isWrite" size="large" type="secondary" @onClick="write" />\n  </fieldset>\n</div>\n```\n\n</details>\n\n\n<details>\n\n<summary>Styles for input elements in app.css - it\'s supposed to be global:</summary>\n\n```CSS\ninput, select{\n  padding: .3rem 0.6rem;\n  border: 1px solid var(--color-gray);\n  background-color: var(--color-light);\n  border-radius: var(--radius);\n  font-size: var(--font-size);\n  font-family: var(--font-family-code);\n  border-radius: .25rem;\n  transition: 0.2s ease all;\n}\n\ninput:focus {\n  border-color: var(--color-dark);\n}\n\ninput.large, select.large {\n  font-size: 1.2rem;\n  padding: .35rem 1rem;\n}\n\n\n.tools *, .tools fieldset:not(:last-child):after {\n  display: inline-block;\n  vertical-align: middle;\n  vertical-align: -moz-middle-with-baseline;\n  vertical-align: -webkit-baseline-middle;\n}\n\n.tools fieldset {\n  border: 0;\n}\n\n.tools fieldset:not(:last-child):after {\n  content: "•";\n}\n\n.tools fieldset > *,  .tools > * {\n  margin-right: calc(var(--space)/2)\n}\n```\n\n</details>\n\n**Let\'s check that everything works fine after updates:**\n\n![Dapp Interface changing step 12](../images/build-dapp-interface/dapp-12.gif "Dapp Interface changing step 12")\n\nWe have a datalog section through out the dapp, so I\'ll make a component for it.\n\n<details>\n\n<summary>I have got the following code for a new component DatalogSection.vue</summary>\n\n```HTML\n<template>\n    <div v-if="log" class="log">\n        <h4 class="log-title">Datalog</h4>\n\n        <div class="log-content">\n\n          <p v-if="log.length === 0" class="error">Not found</p>\n\n          <details v-for="(item, k) in log" :key="k" class="box" :open="k === 0">\n              <summary>{{ item[0] }}</summary>\n              <pre>{{ item[1] }}</pre>\n          </details>\n        </div>\n    </div>\n</template>\n\n<script>\n\nexport default {\n\n  props: {\n    log: {\n      type: Array\n    }\n  },\n\n}\n\n<\/script>\n\n<style>\n\n.log {\n  text-align: left;\n  margin: var(--space) auto;\n  width: 100%;\n}\n\n.log-content {\n  border: 1px solid var(--color-gray);\n  max-height: 500px;\n  overflow-y: auto;\n  padding: var(--space);\n  background-color: var(--color-gray-middark);\n  outline: 1px solid #fff;\n  box-shadow: 0 0 60px 20px #fff inset;\n}\n\n.log-title {\n  color: var(--color-gray-dark);\n  font-weight: 300;\n  font-family: var(--font-family-code);\n\n  border-bottom: 1px solid var(--color-gray);\n}\n\n.log .box {\n  margin-bottom: var(--space);\n}\n\ndetails {\n  transition: 0.2s all ease;\n}\n\ndetails summary {\n  cursor: pointer;\n}\n\ndetails.box {\n  padding-top: 0;\n  padding-bottom: 0;\n}\n\ndetails.box[open] {\n  padding-bottom: calc(var(--space)*0.5);\n}\n\ndetails.box:focus {\n  box-shadow: 0 0 5px var(--color-gray)\n}\n\ndetails.box summary {\n  padding-top: calc(var(--space)*0.5);\n  padding-bottom: calc(var(--space)*0.5);\n}\n\ndetails.box[open] summary {\n  border-bottom: 1px solid var(--color-dark);\n  margin-bottom: calc(var(--space)*0.5);\n  font-weight: 500;\n}\n\n.log details.box summary {\n  font-family: var(--font-family-code);\n}\n\n</style>\n```\n\n</details>\n\nWhat you should pay attention to here: we pass prop `log` as an array. I assume that this multidimensional array will contain log of entries and every entry has a title (I wrote there date for all logs in the dapp) and content. We need to reformat arrays in components **Datalog.vue** and **Launch.vue**.\n\nNow edit **Datalog.vue**. Find method, where we get the log:\n```JS\nasync read() {\n  this.log = (await this.api.query.datalog.datalog(this.account)).toArray();\n}\n```\n\nNow we have to format data in **Datalog.vue**, and pass ready log array for **DatalogSection.vue**. So let\'s map the log array:\n```JS\nasync read() {\n  this.log = (await this.api.query.datalog.datalog(this.account)).toArray().map((item) => {\n    return [new Date(Number(item[0])).toLocaleString(), u8aToString(item[1])]\n  });\n}\n```\n\nWe don\'t need this code anymore:\n```JS\nfilters: {\n  dateFormat: function(v) {\n    return new Date(Number(v)).toLocaleString();\n  },\n  dataFormat: function(v) {\n    return u8aToString(v);\n  }\n}\n```\n\n**Let\'s check the datalog section in Datalog tab:**\n\n![Dapp Interface changing step 13](../images/build-dapp-interface/dapp-13.gif "Dapp Interface changing step 13")\n\n## Launch\n\nFor this step, most of improvements have already been done, we just need to apply them to the template: import Button and Datalog components, remove the excessive title:\n\n![Dapp Interface changing step 14](../images/build-dapp-interface/dapp-14.gif "Dapp Interface changing step 14")\n\nLet\'s replace `select` control element with `checkbox`.\n\nInstead of this:\n```HTML\n<select v-model="parameter" :disabled="isWrite">\n  <option value="ON">ON</option>\n  <option value="OFF">OFF</option>\n</select>\n```\n\nWrite this:\n```HTML\n<div class="toggler inline-block">\n  <input v-model="parameter" :disabled="isWrite" type="checkbox" id="robot-switch" />\n  <label for="robot-switch"><span></span></label>\n</div>\n```\n\n<details>\n\n<summary>Styles in app.css:</summary>\n\n```CSS\n.toggler input { display: none; }\n.toggler label {\n  position: relative;\n  display: block;\n  width: 60px;\n  height: 40px;\n  border-radius: 4px;\n  font-weight: 500;\n  text-transform: uppercase;\n  letter-spacing: 1px;\n  cursor: pointer;\n  background-color: var(--color-gray);\n  color: var(--color-light);\n  text-align: center;\n}\n\n.toggler label:before {\n  content: \'Off\';\n  width: 100%;\n  text-align: center;\n  line-height: 40px;\n}\n\n.toggler label:after {\n  content: \'\';\n  display: block;\n  width: 6px;\n  height: 100%;\n  border-radius: 10px;\n  background-color: var(--color-gray-dark);\n\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: 10;\n\n  transition: 0.3s ease-out all;\n}\n\n.toggler input:checked + label {\n  background-color: var(--color-green);\n}\n\n.toggler input:checked + label:before {\n  content: \'On\';\n}\n\n.toggler input:checked + label:after {\n  transform: translateX(54px);\n  background-color: #007038;\n}\n```\n\n</details>\n\n![Dapp Interface changing step 15](../images/build-dapp-interface/dapp-15.gif "Dapp Interface changing step 15")\n\nI want to clarify something with the interface: with these elements we start some device. Let\'s visualize it. I\'ve chosen a drone, so I will toggle classes according to `item.parameter`.\n\nCreate a new property in `data`:\n```JS\ndata() {\n  status: false\n}\n```\n\nAssign value of `parameter` to `status` after button is clicked and tx is sent to the block:\n```JS\nmethods: {\n    async launch() {\n      try {\n        this.error = "";\n        this.isWrite = true;\n\n        const tx = await this.api.tx.launch\n          .launch(this.robot, this.parameter === "ON")\n          .signAsync(this.account);\n\n        await tx.send(result => {\n          if (result.status.isInBlock) {\n            this.isWrite = false;\n            this.status = this.parameter; // new line here\n          }\n        });\n      } catch (error) {\n        this.error = error.message;\n        this.isWrite = false;\n      }\n    }\n  }\n```\n\nWrite styles for the drone in **Launch.vue**. Don\'t forget `scoped` for `<style>` tag, to apply styles only for this component.\n\n<details>\n\n<summary>CSS for drone:</summary>\n\n```CSS\n<style scoped>\n.tools {\n  position: relative;\n  padding-left: 120px;\n  text-align: left;\n  display: inline-block;\n}\n\n.launch-drone {\n  position: absolute;\n  width: 100px;\n  left: 0;\n  filter: grayscale(1);\n  transition: 1s all ease-in;\n}\n\n.launch-drone.on {\n  filter: grayscale(0);\n  animation: DroneLaunch 10s linear infinite;\n}\n\n@keyframes DroneLaunch {\n  0%, 20%, 40%, 60%, 80%, 100% {\n    transform: translateY(0);\n  }\n  10%, 30%, 50%, 70%, 90% {\n    transform: translateY(-20%);\n  }\n}\n</style>\n```\n\n</details>\n\n![Dapp Interface changing step 16](../images/build-dapp-interface/dapp-16.gif "Dapp Interface changing step 16")\n\nNow let\'s add the **DatalogSection.vue** component.\n\n```JS\ncomponents: {\n  DatalogSection: () => import("./DatalogSection")\n}\n```\n\nReformat the log array from:\n\n```JS\nthis.log.push({\n  sender,\n  robot,\n  parameter\n});\n```\n\nto (for structure like `[["entry 1 date", "entry 1 content"], ["entry 2 date", "entry 2 content"]]`):\n\n```JS\nthis.log.push([new Date().toLocaleString(), {\n  sender,\n  robot,\n  parameter\n}]);\n```\n\nReplace the code from the template:\n\n```HTML\n<div v-if="log.length > 0" class="log">\n  <div v-for="(item, k) in log" :key="k" class="row">\n    sender: <b>{{ item.sender }}</b>\n    <br />\n    robot: <b>{{ item.robot }}</b>\n    <br />\n    parameter: <b>{{ item.parameter ? "ON" : "OFF" }}</b>\n  </div>\n</div>\n```\n\nwith this:\n\n```HTML\n<DatalogSection :log="log"/>\n```\n\n**Check:**\n![Dapp Interface changing step 17](../images/build-dapp-interface/dapp-17.gif "Dapp Interface changing step 17")\n\nSometimes you get some errors, it\'s almost inevitable. Something can go wrong with the connection or anything else can happen. So we have fallbacks with error messages through out the dapp, I haven\'t changed them from the start, in the code they look like:\n\n```HTML\n<div v-if="error" class="error">{{ error }}</div>\n```\n\nOn the interface errors look this way now:\n\n![Dapp Interface changing step 18](../images/build-dapp-interface/dapp-18.png "Dapp Interface changing step 18")\n\nAdd styles for the `.error` in **app.css**:\n\n```CSS\n.error {\n  font-weight: 400;\n  text-transform: uppercase;\n  letter-spacing: 1px;\n  color: var(--color-red);\n}\n```\n\nAnd I will fix a space between the `.tools` section and other content from the bottom as well in **app.css**:\n\n```CSS\n.tools {\n  margin-bottom: var(--space);\n}\n```\n\nWe get:\n\n![Dapp Interface changing step 19](../images/build-dapp-interface/dapp-19.png "Dapp Interface changing step 19")\n\nNow on this page we have to "primary" buttons. Technically it is okay, but this is not okay from the above user experience. It\'s better not to use more than one prevailing button on the screen. So let\'s fix it and add for the `Button` in **Launch.vue** with property `type="secondary"`:\n\n![Dapp Interface changing step 20](../images/build-dapp-interface/dapp-20.png "Dapp Interface changing step 20")\n\nGreat, now I\'ll fix some issues with my node and go to the Demo step.\n\n## Demo\n\nFor the start, I\'d like to swap tabs, to pay more attention to the most relevant one, but this is not the first step that we do to practice. Reverse tabs in **App.vue**.\n\nDon\'t forget to replace the default data:\n\n```JS\ndata() {\n    return {\n      ...\n      tab: "demo"\n    };\n},\n```\n\n![Dapp Interface changing step 21](../images/build-dapp-interface/dapp-21.png "Dapp Interface changing step 21")\n\nAs usual let\'s start with changing what we have already got.\n\n- Remove the title `<h2>Demo</h2>` as in the previous steps\n- Find UI elements that we have already learn – datalog, buttons, account address. But not so fast. Now we\'ll change the datalog only.\n\nAdd the component to **Demo.vue**:\n\n```JS\ncomponents: {\n  DatalogSection: () => import("./DatalogSection")\n}\n```\n\n```HTML\n<DatalogSection :log="log"/>\n```\n\nWe\'ve got raw data in the log, so we need to reformat the array with the log to pass in the component ready-view data as in the previous steps. Find the line `return [item[0], item[1]];` in `async created()` and replace it with:\n\n```JS\nreturn [new Date(Number(item[0])).toLocaleString(), JSON.parse(u8aToString(item[1]))];\n```\n\nRemove the unused code from the log:\n\n```HTML\n<div v-if="log" class="log">\n  <p v-if="log.length === 0" class="error">Not found</p>\n  <div v-for="(item, k) in log" :key="k" class="row">\n    <b>{{ item[0] | dateFormat }}</b>\n    <pre>{{ item[1] | dataFormat }}</pre>\n  </div>\n</div>\n```\n\nand:\n\n```JS\nfilters: {\n  dateFormat: function(v) {\n    return new Date(Number(v)).toLocaleString();\n  },\n  dataFormat: function(v) {\n    return JSON.parse(u8aToString(v));\n  }\n},\n```\n\n**Check:**\n![Dapp Interface changing step 22](../images/build-dapp-interface/dapp-22.png "Dapp Interface changing step 22")\n\nFor customization of this demo example with launching a robot, you are free to come up with any idea. Personally, I started with this town:\n\n![Dapp Interface changing step 23](../images/build-dapp-interface/dapp-23.gif "Dapp Interface changing step 23")\n\nI won\'t show the whole code for this not to confuse you at all, but schematically there will be something like this:\n\n```HTML\n<div class="demo" :class="[robot.state ? \'play\' : \'stop\']">\n  <div class="demo-back"></div>\n  <div class="demo-city"></div>\n  <div class="demo-car"></div>\n</div>\n```\n\nThan within the element `.demo.play` write styles for moving the city backward, and the car forward.\n\nWhile working on this, I came up with the idea of realization the CyberPunk city. As I have no any particullar task, so the car became a taxi, driver became a passenger, and now on the interface we have an AI robot hologram welcoming the passenger (these all are just CSS and graphics tweaks&&tricks).\n\n**The code for the Cyberpunk city demo:**\n\n<details>\n\n<summary>Template</summary>\n\n```HTML\n<div class="demo" :class="[robot.state ? \'play\' : \'stop\']">\n  <div class="demo-back-1"></div>\n  <div class="demo-back-2"></div>\n  <div class="demo-city-1"></div>\n  <div class="demo-car"></div>\n\n  <div class="demo-data">\n    <div class="demo-data-driver inline-block">\n      <img alt="Driver\'s avatar" src="../assets/images/cabman.png" v-if="robot.state"/>\n    </div>\n    <div class="demo-data-lines inline-block">\n      <div class="demo-data-line">\n          <div>Robot</div>\n          <div>[ {{ addressShort(robot.address) }} ]</div>\n      </div>\n\n      <div class="demo-data-line" v-if="robot.state">\n          <div>Passenger</div>\n          <div>[ {{ addressShort(robot.driver) }} ]</div>\n      </div>\n\n      <div class="demo-data-welcome" v-if="robot.state">\n          <span>Hello, passenger. </span>\n          <span>I\'ve linked to the vehicle. </span>\n          <span>Your ride begins, congrats! </span>\n      </div>\n    </div>\n\n  </div>\n\n  <Button :label="robot.state ? \'stop\' : \'run\'" :disabled="isWrite" size="large" @onClick="run" />\n</div>\n```\n\n</details>\n\nThere are more than one hash address that should be shortenned, so I added the method:\n\n```JS\nmethods: {\n  addressShort(address) {\n    return address.slice(0, 6) + "..." + address.slice(-4);\n  }\n}\n```\n\nDon\'t forget to register the Button component\n\n```JS\ncomponents: {\n  Button: () => import("./Button")\n}\n```\n\n<details>\n\n<summary>Styles</summary>\n\n```CSS\n<style scoped>\n.demo {\n    --h: 120px;\n    --color-yellow: #F2F209;\n\n    background-color: #AFCCD3;\n\n    background: linear-gradient(#010123, #4baac7);\n\n    position: relative;\n    height: 500px;\n    overflow: hidden;\n\n    border-width: 2px 2px 2px 15px;\n    border-style: solid;\n    border-color: var(--color-yellow);\n    \n}\n\n.demo:before {\n    content: \'[ Delamain cabs rental DEMO ]\';\n    background-color: var(--color-yellow);\n    color: #000;\n\n    position: absolute;\n    top: 0;\n    left: 0;\n    padding: .5rem 1rem;\n\n    text-transform: uppercase;\n    letter-spacing: 1px;\n    font-weight: 300;\n\n    border-width: 0 6px 2px 0;\n    border-style: solid;\n    border-color: #7B186E;\n}\n\ndiv[class^=demo-back-], div[class^=demo-city-] {\n    position: absolute;\n    left: 0;\n    width: 100%;\n    z-index: 2;\n}\n\ndiv[class^=demo-back-]{\n    border-top: 1px solid #364444;\n}\n\ndiv[class^=demo-city-] {\n    background-repeat: repeat-x;\n    background-size: cover;\n    background-position: 100% 0;\n\n    height: 300px;\n    bottom: var(--h);\n\n    animation: 50s MoveCity infinite linear 1.5s;\n}\n\ndiv.demo-back-1 {\n    background-color: #060236;\n    background: linear-gradient(#7B186E, #060236);\n    height: var(--h);\n    bottom: 0;\n}\n\ndiv.demo-back-2 {\n    background-color: #c515ae;\n    border-width: 2px 0;\n    border-style: solid;\n    border-color: #69045c;\n\n    height: 20px;\n    bottom: var(--h);\n    z-index: 10;\n}\n\ndiv.demo-city-1 {\n    background-image: url(../assets/images/city-1.png);\n}\n\n.demo-car {\n    background-image: url(../assets/images/car.png);\n    background-size: contain;\n    background-repeat: no-repeat;\n    background-position: 100% 0;\n\n    width: calc(508px * 0.5);\n    height: calc(257px * 0.5);\n    position: absolute;\n    bottom: calc(var(--h) + 4px);\n    z-index: 10;\n\n    transform: translateX(-100px);\n    animation: MoveCar 50s infinite 1.5s linear;\n}\n\n.demo.play div[class^=demo-city-], .demo.play .demo-car { animation-play-state: running; }\n.demo.stop div[class^=demo-city-], .demo.stop .demo-car { animation-play-state: paused; }\n\n.demo.play .demo-car {\n    background-image: url(../assets/images/car-ride.png);\n}\n\n\n.demo button {\n    background-color: var(--color-yellow);\n    border-color: var(--color-yellow);\n    color: #000;\n\n    position: absolute;\n    bottom: 30px;\n    right: 30px;\n    z-index: 1000;\n}\n\n.demo-data {\n    position: absolute;\n    bottom: 30px;\n    left: 30px;\n    z-index: 1000;\n\n    background-color: rgba(0, 0, 0, .5);\n    color: #fff;\n    padding: .5rem;\n    font-family: var(--font-family-code);\n\n    transition: 0.2s all ease;\n}\n\n.demo-data-lines {\n    max-width: 400px;\n}\n\n.demo-data-line {\n    display: grid;\n    grid-template-columns: 100px auto;\n    gap: .5rem;\n    text-align: left;\n}\n\n.demo-data-line div:first-child {\n    text-transform: uppercase;\n    letter-spacing: 1px;\n    font-weight: 700;\n}\n\n.demo-data-driver {\n    margin-right: 1rem;\n}\n\n.demo-data-driver img {\n    display: block;\n    max-width: 100px;\n\n    visibility: hidden;\n    opacity: 0;\n    animation: FadeInBlink .3s cubic-bezier(0.075, 0.82, 0.165, 1) 0.6s forwards;\n}\n\n.demo-data-welcome {\n    text-align: left;\n    padding-top: .5rem;\n}\n\n.demo-data-welcome span {\n    visibility: hidden;\n    opacity: 0;\n\n    animation-name: FadeIn;\n    animation-timing-function: cubic-bezier(0.075, 0.82, 0.165, 1);\n    animation-duration: 0.6s;\n    animation-fill-mode: forwards;\n}\n\n.demo-data-welcome span:nth-child(1) { animation-delay: 1.5s; }\n.demo-data-welcome span:nth-child(2) { animation-delay: 2.5s; }\n.demo-data-welcome span:nth-child(3) { animation-delay: 3.2s; }\n\n\n@keyframes MoveCity\n{\n  100% {\n    background-position: -1000px 0;\n  }\n}\n\n@keyframes MoveCar\n{\n    0% {\n        transform: translateX(-100px);\n    }\n    100% {\n        transform: translateX(960px);\n    }\n}\n</style>\n\n```\n\n</details>\n\n**Result:**\n\n![Dapp Interface changing step 25](../images/build-dapp-interface/dapp-25.gif "Dapp Interface changing step 25")\n\n## Conclusion\n\nCongratulations! Now you have redesigned the dapp and clues how to start building your application\'s interface.\n\n### Checkout links\n\n- [Full code of this tutorial](https://github.com/positivecrash/wscool21-ui-dapp)\n- [Discuss in Discord](https://discord.gg/5UWNGNaAUf)\n- [View the Robonomics Winter School 2021 schedule and summary](https://robonomics.network/blog/winter-robonomics-school/)\n- [Github of contributor](https://github.com/positivecrash)\n\n### Practice\n\nIf you have some extra time or want to practice your skills, there are some ideas for improvements that you could make to this demo:\n\n- Adapt UI for narrow screens, make the dapp mobile-friendly\n- Add the \'day/night\' mode, by editing the **_variables.scss** file and the template file of the dapp\n- Add \'Copy to clipboard\' buttons for addresses\n- Make delicate popus to inform users about changes (e.g. you can popup a message that units are received after clicking the \'Faucet\' button, or you can move in the popup an error that we had in the \'Launch\' section).\n\nPlease, fill free to ask questions and share your results in [Discord](https://discord.gg/5UWNGNaAUf), mark me in your message `@positivecrash`\n\n\n\n\n\n\n'}},{node:{id:"ecd3bb67f6bd0a89db828bb9c97e87be",title:"Lesson 6.1, Build IoT Dapps For End Users",path:"/docs/ru/wschool2021-build-dapp-for-end-users/",content:'\n## Getting ready\n\n### Robonomics node launch\n\nFor dApp development and testing, we will use a local Robonomics node. To do this, you need to download the compiled binary file https://github.com/airalab/robonomics/releases. I will be using Ubuntu, so I download the appropriate version.\n\nUnpack the archive\n```sh\nwget https://github.com/airalab/robonomics/releases/download/v0.24.0/robonomics-ubuntu-0.24.0-x86_64.zip\nunzip robonomics-ubuntu-0.24.0-x86_64.zip\ncd robonomics-ubuntu-0.24.0-x86_64\nchmod +x robonomics\n```\n\nNow we can start the node in development mode. To do this, use the --dev flag\n```sh\n./robonomics --dev\n```\n\n> Troubleshooting\n```sh\n./robonomics purge-chain --dev\n```\n\n### Browser extension\n\nTo store keys in a browser, there is a `polkadot{.js} extension`. In dApp we will use it to sign transactions.\n\nThe extension is currently available for `Google chrome` and `Firefox` https://polkadot.js.org/extension/\n\nAfter installing the extension, create a new account.\n![screen1](../images/build-iot-dapps/screen1.png)\n\n> The first step is completed.\n\n## DApp development\n\n### Step 1\n\n> We will write the dApp using the vue.js framework, although you can use whatever you like/can.\n\nLet\'s start developing the dApp by creating a startup application with vue.js And here you can do it in two ways.\n\nWay 1:\n\nUsing the `Vue cli` console utility.\nTo do this, you need to install it https://cli.vuejs.org/guide/installation.html\n\nAfter installation, you can run the command in the terminal\n\n```sh\nvue create mydapp\n```\n\nAnswer a few questions of the setup wizard. We will be using version Vue 2, so we keep the default version `Default ([Vue 2] babel, eslint)`.\n\nWay 2:\n\nClone the prepared git repository with the example and switch to step 1\n\n```sh\ngit clone https://github.com/airalab/example-robonomics-dapp.git mydapp\ncd mydapp\ngit checkout step-1\n```\n\nAs a result, we will get a directory with the installed startup application, which can already be launched and opened in the browser.\n\n```sh\nyarn\nyarn serve\n```\n\n### Step 2. Getting started with polkadot.js\n\n#### Installing dependencies\n\nTo connect the dApp to the Robonomics chain, there is the `@polkadot/api` library. And for interaction of dApp with an extension with keys, we have the `@polkadot/extension-dapp` library. We need to install them into our application.\nMore details on using this library can be found in the documentation https://polkadot.js.org/docs/.\n\nWay 1:\n\n```sh\nyarn add @polkadot/api @polkadot/extension-dapp\n```\n\nYou also need to add the `vue.config.js` file to support `mjs` extension.\n\n`vue.config.js`\n```js\nmodule.exports = {\n  publicPath: "",\n  configureWebpack: {\n    resolve: {\n      extensions: ["*", ".mjs", ".js", ".vue", ".json", ".gql", ".graphql"]\n    },\n    module: {\n      rules: [\n        {\n          test: /\\.mjs$/,\n          include: /node_modules/,\n          type: "javascript/auto"\n        }\n      ]\n    }\n  }\n};\n```\n\n#### Connecting to Robonomics\n\nFirst, let\'s create a configuration file with the parameters for connecting to the Robonomics node. In the demo repository, there is an example of this file `config.template.json`.\n\n`src/config.json`\n```json\n{\n  "endpoint": "ws://localhost:9944",\n  "types": {\n    "Record": "Vec<u8>",\n    "Parameter": "Bool",\n    "Address": "AccountId",\n    "LookupSource": "AccountId"\n  }\n}\n```\n\nIn this file, we indicate the node, which we are going to connect to, and custom types. The types for Robonomics can be taken from github https://github.com/airalab/robonomics/blob/master/bin/node/cli/res/custom_types.json\n\nNow we need to write a script to connect to our running node.\n\n`src/utils/api.js`\n```js\nimport { ApiPromise, WsProvider } from "@polkadot/api";\nimport config from "../config.json";\n\nlet api;\nexport async function initApi() {\n  const provider = new WsProvider(config.endpoint);\n  api = await ApiPromise.create({\n    provider,\n    types: config.types\n  });\n  return api;\n}\n\nexport function getApi() {\n  return api;\n}\n```\n\nSo that we can sign transactions with the key from the extension, let’s add two functions for connecting to the extension and the function for initializing the account.\n\n`src/utils/api.js`\n```js\n...OTHER_CODE...\n\nimport {\n  web3Accounts,\n  web3Enable,\n  web3FromAddress\n} from "@polkadot/extension-dapp";\n\nasync function getExtension() {\n  const extensions = await web3Enable("demo");\n  if (extensions.length === 0) throw new Error("no extension");\n  return extensions[0];\n}\n\nexport async function initAccount(index = 0) {\n  const timeout = new Promise(resolve => {\n    setTimeout(resolve, 300);\n  });\n  await timeout;\n  await getExtension();\n  const accounts = await web3Accounts();\n  if (accounts.length > 0) {\n    const injector = await web3FromAddress(accounts[index].address);\n    api.setSigner(injector.signer);\n    return accounts[index].address;\n  }\n  throw new Error("no accounts");\n}\n\n...OTHER_CODE...\n```\n\nOur account will have a zero balance, while we need a little funds. So we need to create another faucet function. As we launched Robonomics with the `--dev` flag, we have `Alice` account with a large balance, so we will request funds from there.\n\n`src/utils/api.js`\n```js\n...OTHER_CODE...\n\nimport { Keyring } from "@polkadot/keyring";\n\nexport function getBalance(account, cb) {\n  api.query.system.account(account, ({ data: { free: currentFree } }) => {\n    cb(currentFree);\n  });\n}\n\nexport const keyring = new Keyring({ type: "sr25519" });\n\nexport async function faucet(address) {\n  keyring.setSS58Format(api.registry.chainSS58);\n  const account = keyring.addFromUri("//Alice");\n  const tx = api.tx.balances.transfer(address, 1000000000000000);\n  await tx.signAndSend(account);\n}\n\n...OTHER_CODE...\n```\n\nThe full version of script https://github.com/airalab/example-robonomics-dapp/blob/master/src/utils/api.js\n\nRun app\n\n```sh\nyarn serve\n```\n\nWay 2:\n\nIf you start the application with cloning the repository, then in order to complete these steps, it will be enough to switch to step 2 and install the rest of the dependencies.\n\n```sh\ngit checkout step-2\ncp src/config.template.json src/config.json\nyarn\nyarn serve\n```\n\n### Step 3. Vue connecting component\n\n#### Connecting\n\nWe have already written a script for connecting. Now we can use it on our interface. It is enough to call the written `initApi` function in  the root component `App.vue`. And while the user is waiting for a connection, we will show him a small loader, for now in the form of an ellipsis.\n\nWay 1:\n\nComponent template and base styles.\n\n`src/App.vue`\n```js\n<template>\n  <div id="app">\n    <h1>Robonomics dApp</h1>\n    <div v-if="load">...</div>\n    <template v-else>\n      <div v-if="error" class="error">{{ error }}</div>\n      <template v-else-if="api">\n        connected\n      </template>\n    </template>\n  </div>\n</template>\n\n...OTHER_CODE...\n\n<style>\n#app {\n  font-family: Avenir, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n  margin-top: 60px;\n}\nbutton {\n  font-size: 14px;\n  padding: 5px 12px;\n}\nbutton:hover {\n  cursor: pointer;\n}\ninput {\n  font-size: 14px;\n  padding: 5px;\n}\nselect {\n  font-size: 14px;\n  padding: 5px;\n}\nbutton:focus,\ninput:focus {\n  outline: none;\n}\n.error {\n  color: rgb(151, 31, 31);\n  font-weight: bold;\n  text-align: center;\n  margin: 10px 0;\n}\n</style>\n```\n\nThere is the component code where the  `initApi` function will be called\n\n`src/App.vue`\n```js\n<script>\nimport { initApi } from "./utils/api";\n\nexport default {\n  name: "App",\n  data() {\n    return {\n      load: false,\n      api: null,\n      error: null\n    };\n  },\n  created() {\n    this.init();\n  },\n  methods: {\n    async init() {\n      try {\n        this.load = true;\n        this.api = await initApi();\n        this.load = false;\n      } catch (error) {\n        this.error = error.message;\n        this.load = false;\n      }\n    }\n  }\n};\n<\/script>\n```\n\n#### Account with balance\n\nNow we can use our account, top up its balance and show it on the interface.\n\nLet’s add the appropriate markup to the template\n\n`src/App.vue`\n```js\n<template>\n\n  ...OTHER_CODE...\n\n    <template v-else>\n      <div v-if="error" class="error">{{ error }}</div>\n      <template v-else-if="api && account">\n        <p>\n          Account: <b>{{ account }}</b> {{ balance }} |\n          <button @click="faucet">\n            faucet\n          </button>\n        </p>\n      </template>\n    </template>\n\n  ...OTHER_CODE...\n\n</template>\n```\n\nLet’s add new fields for account address and balance\n\n`src/App.vue`\n```js\n\n...OTHER_CODE...\n\ndata() {\n  return {\n\n    ...OTHER_CODE...\n\n    account: null,\n    balance: 0,\n\n    ...OTHER_CODE...\n\n  };\n}\n\n...OTHER_CODE...\n```\n\nWe need to add the account initialization to the `init` function and get its balance\n\n`src/App.vue`\n```js\n<script>\nimport { initApi, initAccount, getBalance, faucet } from "./utils/api";\nimport { formatBalance } from "@polkadot/util";\n\n...OTHER_CODE...\n\nasync init() {\n\n  ...OTHER_CODE...\n\n  this.api = await initApi();\n  this.account = await initAccount();\n  getBalance(this.account, balance => {\n    this.balance = formatBalance(balance);\n  });\n\n  ...OTHER_CODE...\n\n}\n\n...OTHER_CODE...\n<\/script>\n```\n\nIt remains to add the function of replenishing the balance, when clicking on the button\n\n`src/App.vue`\n```js\n\n...OTHER_CODE...\n\n  methods: {\n    faucet() {\n      faucet(this.account);\n    },\n\n...OTHER_CODE...\n```\n\nhttps://github.com/airalab/example-robonomics-dapp/blob/step-3/src/App.vue\n\nRun app\n\n```sh\nyarn serve\n```\n\nWay 2:\n\nIf you start the application with cloning the repository, then to complete these steps, you will just need to switch to step 3.\n\n```sh\ngit checkout step-3\nyarn serve\n```\n\nAs a result we will get this picture in the browser\n\n![screen2](../images/build-iot-dapps/screen2.png)\n\n### Step 4. Datalog\n\nTo save and read any data in the chain, we use the `datalog` module.\n\nFor an example of how to use this module, let\'s make a `Datalog.vue` component.\n\nWay 1:\n\nIn the markup, we will have a button for reading data `read` with a block, where we will display a list in the form of a date and the data itself. And there will be a form with a text input, into which you can enter any data in the form of a string, and a `write` button.\n\n`src/components/Datalog.vue`\n```js\n<template>\n  <div>\n    <h2>Datalog</h2>\n    <button @click="read">read</button> |\n    <input v-model="data" :disabled="isWrite" />\n    <button @click="write" :disabled="isWrite">write</button>\n    <div v-if="error" class="error">{{ error }}</div>\n    <div v-if="log" class="log">\n      <p v-if="log.length === 0" class="error">Not found</p>\n      <div v-for="(item, k) in log" :key="k" class="row">\n        date: <b>{{ item[0] | dateFormat }}</b>\n        <br />\n        data: <b>{{ item[1] | dataFormat }}</b>\n      </div>\n    </div>\n  </div>\n</template>\n\n...OTHER_CODE...\n\n<style scoped>\n.log {\n  border: 1px solid #eee;\n  text-align: left;\n  width: 800px;\n  margin: 20px auto;\n}\n.log .row {\n  margin: 10px;\n}\n</style>\n```\n\nComponent code. Here the main point in sending a transaction is to call the function, into which we transfer data and which we sign with our account, via api `this.api.tx.datalog.record(stringToHex(this.data)).signAsync(this.account);`\n\n`src/components/Datalog.vue`\n```js\n<script>\nimport { stringToHex, u8aToString } from "@polkadot/util";\n\nexport default {\n  props: ["api", "account"],\n  data() {\n    return {\n      data: "data string",\n      log: null,\n      isWrite: false,\n      error: ""\n    };\n  },\n  filters: {\n    dateFormat: function(v) {\n      return new Date(Number(v)).toLocaleString();\n    },\n    dataFormat: function(v) {\n      return u8aToString(v);\n    }\n  },\n  methods: {\n    async read() {\n      this.log = (await this.api.query.datalog.datalog(this.account)).toArray();\n    },\n    async write() {\n      try {\n        this.error = "";\n        this.isWrite = true;\n        const tx = await this.api.tx.datalog\n          .record(stringToHex(this.data))\n          .signAsync(this.account);\n        await tx.send(result => {\n          if (result.status.isInBlock) {\n            this.read();\n            this.isWrite = false;\n          }\n        });\n      } catch (error) {\n        this.error = error.message;\n        this.isWrite = false;\n      }\n    }\n  }\n};\n<\/script>\n```\n\nhttps://github.com/airalab/example-robonomics-dapp/blob/master/src/components/Datalog.vue\n\nTo switch between components, added to `App.vue` the output of our component\n\n`src/App.vue`\n```js\n...OTHER_CODE...\n\n<template v-else-if="api && account">\n  <p>\n    Account: <b>{{ account }}</b> {{ balance }} |\n    <button @click="faucet">faucet</button>\n  </p>\n\n  <div>\n    <div class="tabs">\n      <button\n        @click="tab = \'datalog\'"\n        :class="{ active: tab === \'datalog\' }"\n      >\n        datalog\n      </button>\n    </div>\n    <Datalog v-if="tab === \'datalog\'" :api="api" :account="account" />\n  </div>\n</template>\n\n...OTHER_CODE...\n\n<script>\nimport Datalog from "./components/Datalog";\n\n...OTHER_CODE...\n\nexport default {\n  name: "App",\n  components: {\n    Datalog\n  },\n  data() {\n    return {\n      tab: "datalog"\n\n...OTHER_CODE...\n<\/script>\n\n<style>\n...OTHER_CODE...\n\n.tabs button {\n  font-size: 14px;\n  padding: 10px 20px;\n  font-weight: bold;\n  background: #ececec;\n  border: 1px solid #aaa;\n}\n.tabs button:hover {\n  background: #bfbfbf;\n}\n.tabs button:last-child {\n  border-left: none;\n}\n.tabs button.active {\n  background: #ced5e2;\n}\n</style>\n```\n\nRun app\n\n```sh\nyarn serve\n```\n\nWay 2:\n\nIf you start the application with cloning the repository, then to complete these steps, you will just need to switch to step 4.\n\n```sh\ngit checkout step-4\nyarn serve\n```\n\nAs a result we will get this picture in the browser\n\n![screen3](../images/build-iot-dapps/screen3.png)\n\n### Step 5. Launch\n\nThis function is used to start and stop the robot. To demonstrate how to use this module, let\'s write the `Launch.vue` component.\n\nWay 1:\n\nIn the component template, we will have a form where you can specify the address of the robot, the ON/OFF clicker and the button for sending.\n\n`src/components/Launch.vue`\n```js\n<template>\n  <div>\n    <h2>Launch</h2>\n    <input v-model="robot" :disabled="isWrite" placeholder="Robot address" />\n    <select v-model="parameter" :disabled="isWrite">\n      <option value="ON">ON</option>\n      <option value="OFF">OFF</option>\n    </select>\n    <button @click="launch" :disabled="isWrite">launch</button>\n    <div v-if="error" class="error">{{ error }}</div>\n    <div v-if="log.length > 0" class="log">\n      <div v-for="(item, k) in log" :key="k" class="row">\n        sender: <b>{{ item.sender }}</b>\n        <br />\n        robot: <b>{{ item.robot }}</b>\n        <br />\n        parameter: <b>{{ item.parameter ? "ON" : "OFF" }}</b>\n      </div>\n    </div>\n  </div>\n</template>\n\n...OTHER_CODE...\n\n<style scoped>\n.log {\n  border: 1px solid #eee;\n  text-align: left;\n  width: 800px;\n  margin: 20px auto;\n}\n.log .row {\n  margin: 10px;\n}\n</style>\n```\n\nThe code looks like the `Datalog.vue` component. The difference is just in reading. The robot will receive the command through events.\n\n`src/components/Launch.vue`\n```js\n<script>\nexport default {\n  props: ["api", "account"],\n  data() {\n    return {\n      robot: this.account,\n      parameter: "ON",\n      log: [],\n      isWrite: false,\n      error: "",\n      unsubscribe: null\n    };\n  },\n  async created() {\n    this.unsubscribe = await this.api.query.system.events(events => {\n      events.forEach(record => {\n        const { event } = record;\n        if (event.section === "launch" && event.method === "NewLaunch") {\n          const sender = event.data[0].toString();\n          const robot = event.data[1].toString();\n          const parameter = event.data[2].toHuman();\n          this.log.push({\n            sender,\n            robot,\n            parameter\n          });\n        }\n      });\n    });\n  },\n  destroyed() {\n    if (this.unsubscribe) {\n      this.unsubscribe();\n    }\n  },\n  methods: {\n    async launch() {\n      try {\n        this.error = "";\n        this.isWrite = true;\n        const tx = await this.api.tx.launch\n          .launch(this.robot, this.parameter === "ON")\n          .signAsync(this.account);\n        await tx.send(result => {\n          if (result.status.isInBlock) {\n            this.isWrite = false;\n          }\n        });\n      } catch (error) {\n        this.error = error.message;\n        this.isWrite = false;\n      }\n    }\n  }\n};\n<\/script>\n```\n\nhttps://github.com/airalab/example-robonomics-dapp/blob/master/src/components/Launch.vue\n\nFor display, add a new component to `App.vue`\n\n`src/App.vue`\n```js\n<template>\n...OTHER_CODE...\n\n  <div>\n    <div class="tabs">\n      <button\n        @click="tab = \'datalog\'"\n        :class="{ active: tab === \'datalog\' }"\n      >\n        datalog\n      </button>\n      <button\n        @click="tab = \'launch\'"\n        :class="{ active: tab === \'launch\' }"\n      >\n        launch\n      </button>\n    </div>\n    <Datalog v-if="tab === \'datalog\'" :api="api" :account="account" />\n    <Launch v-if="tab === \'launch\'" :api="api" :account="account" />\n  </div>\n\n...OTHER_CODE...\n</template>\n\n...OTHER_CODE...\n\n<script>\nimport Datalog from "./components/Datalog";\nimport Launch from "./components/Launch";\n\n...OTHER_CODE...\n\ncomponents: {\n  Datalog,\n  Launch\n},\n\n...OTHER_CODE...\n```\n\nRun app\n\n```sh\nyarn serve\n```\n\nWay 2:\n\nIf you start the application with cloning the repository, then to complete these steps, you will just need to switch to step 5.\n\n```sh\ngit checkout step-5\nyarn serve\n```\n\nAs a result we will get this picture in the browser\n\n![screen4](../images/build-iot-dapps/screen4.png)\n\n### Step 6. Demo\n\nIn this demo, we will have a car that can be started and stopped through the dApp. The car collects a log during the trip, and after stopping, saves it to the chain. Here we will use both modules, which we tried separately, in conjunction.\n\nTo emulate the behavior of a robot (car), we will write a Robot class. We will use the `Alice` key as an account for this robot. The `Robot` class will watch for `NewLaunch` events to turn itself on and off. After turning on, it starts collecting data into the log, in terms of data it will be just a timestamp. And after shutdown, it saves this log to the `datalog` module.\n\nWay 1:\n\nCreate file `src/utils/robot.js`. The full code of the file https://github.com/airalab/example-robonomics-dapp/blob/master/src/utils/robot.js\n\nFor visualization, we will create a `Demo.vue` component, where we will have a start button, car animation and log output.\n\n`src/components/Demo.vue`\n```js\n<template>\n  <div>\n    <h2>Demo</h2>\n    <template v-if="robot">\n      <h3>Robot: {{ robot.address }}</h3>\n      <p v-if="robot.state">Driver: {{ robot.driver }}</p>\n      <button @click="run" :disabled="isWrite">\n        <template v-if="!robot.state">run</template>\n        <template v-else>stop</template>\n      </button>\n      <div class="road">\n        <div\n          class="robot"\n          :class="[robot.state ? \'robot-play\' : \'robot-stop\']"\n        ></div>\n      </div>\n      <div v-if="error" class="error">{{ error }}</div>\n      <div v-if="log" class="log">\n        <p v-if="log.length === 0" class="error">Not found</p>\n        <div v-for="(item, k) in log" :key="k" class="row">\n          <b>{{ item[0] | dateFormat }}</b>\n          <pre>{{ item[1] | dataFormat }}</pre>\n        </div>\n      </div>\n    </template>\n  </div>\n</template>\n\n...OTHER_CODE...\n\n<style scoped>\n.log {\n  border: 1px solid #eee;\n  text-align: left;\n  width: 800px;\n  margin: 20px auto;\n  height: 500px;\n  overflow-y: auto;\n}\n.log .row {\n  margin: 10px;\n  border-bottom: 1px solid #eee;\n}\n.road {\n  width: 1000px;\n  margin: 20px auto;\n  background-color: #eee;\n  padding: 20px 0;\n  border: 5px solid #a5a5a5;\n  border-left: 0;\n  border-right: 0;\n  position: relative;\n}\n.road::before {\n  content: " ";\n  width: 1000px;\n  border-top: 5px dashed #a5a5a5;\n  position: absolute;\n  top: 50%;\n  left: 0;\n}\n@keyframes move {\n  from {\n    transform: translateX(0);\n  }\n  to {\n    transform: translateX(100%);\n  }\n}\n.robot {\n  height: 100px;\n  width: 100px;\n  color: #fff;\n  font-weight: bold;\n  font-style: 14px;\n  animation: move 30s linear infinite;\n  border-radius: 0 10px 10px 0;\n  background: url("../images/build-iot-dapps/car.png") no-repeat 0 0;\n  background-size: cover;\n}\n.robot-play {\n  animation-play-state: running;\n}\n.robot-stop {\n  animation-play-state: paused;\n}\n</style>\n```\n\nComponent code. Here we need to create an instance of the `Robot` class and a launch/stop function.\n\n`src/components/Demo.vue`\n```js\n...OTHER_CODE...\n\n<script>\nimport { u8aToString } from "@polkadot/util";\nimport Robot from "../utils/robot";\n\nexport default {\n  props: ["api", "account"],\n  data() {\n    return {\n      isWrite: false,\n      error: "",\n      robot: null,\n      log: []\n    };\n  },\n  filters: {\n    dateFormat: function(v) {\n      return new Date(Number(v)).toLocaleString();\n    },\n    dataFormat: function(v) {\n      return JSON.parse(u8aToString(v));\n    }\n  },\n  async created() {\n    this.robot = new Robot("//Alice", this.api);\n    await this.robot.subscribeLog(r => {\n      this.log = r.reverse().map(item => {\n        return [item[0], item[1]];\n      });\n    });\n  },\n  destroyed() {\n    this.robot.destroy();\n  },\n  methods: {\n    async run() {\n      try {\n        this.error = "";\n        this.isWrite = true;\n        const tx = await this.api.tx.launch\n          .launch(this.robot.account.address, !this.robot.state)\n          .signAsync(this.account);\n        await tx.send(result => {\n          if (result.status.isInBlock) {\n            this.isWrite = false;\n          }\n        });\n      } catch (error) {\n        this.error = error.message;\n        this.isWrite = false;\n      }\n    }\n  }\n};\n<\/script>\n\n...OTHER_CODE...\n```\n\nhttps://github.com/airalab/example-robonomics-dapp/blob/master/src/components/Demo.vue\n\nLet\'s add another picture of our car to `src/images/build-iot-dapps/car.png`. Example https://github.com/airalab/example-robonomics-dapp/blob/master/src/images/build-iot-dapps/car.png.\n\nFor display, add a new component to `App.vue`\n\n`src/App.vue`\n```js\n<template>\n\n...OTHER_CODE...\n\n  <div>\n    <div class="tabs">\n      <button\n        @click="tab = \'datalog\'"\n        :class="{ active: tab === \'datalog\' }"\n      >\n        datalog\n      </button>\n      <button\n        @click="tab = \'launch\'"\n        :class="{ active: tab === \'launch\' }"\n      >\n        launch\n      </button>\n      <button @click="tab = \'demo\'" :class="{ active: tab === \'demo\' }">\n        demo\n      </button>\n    </div>\n    <Datalog v-if="tab === \'datalog\'" :api="api" :account="account" />\n    <Launch v-if="tab === \'launch\'" :api="api" :account="account" />\n    <Demo v-if="tab === \'demo\'" :api="api" :account="account" />\n  </div>\n\n...OTHER_CODE...\n\n</template>\n\n...OTHER_CODE...\n\n<script>\nimport Datalog from "./components/Datalog";\nimport Launch from "./components/Launch";\nimport Demo from "./components/Demo";\n\n...OTHER_CODE...\n\ncomponents: {\n  Datalog,\n  Launch,\n  Demo\n},\n\n...OTHER_CODE...\n```\n\nRun app\n\n```sh\nyarn serve\n```\n\nWay 2:\n\nIf you start the application with cloning the repository, then to complete these steps, you will just need to switch to step 6.\n\n```sh\ngit checkout step-6\nyarn serve\n```\n\nAs a result we will get this picture in the browser\n\n![screen5](../images/build-iot-dapps/screen5.png)\n\nThis concludes our lesson.\n\nThanks!\n'}},{node:{id:"ae94b68823336db895e807644b4436b2",title:"Как участвовать в переводе Вики",path:"/docs/ru/translate-wiki/",content:'\nКаждый может внести свой вклад в Робономику. Если вы хотите принять участие в переводе документации, вы на правильном пути: эта статья расскажет вам как это можно сделать.\n\n## Редактирование статьи\n\nЕсли поддержка вашего языка уже добавлена на сайт, то следуйте следующим шагам:\n\n1. Кликните кнопку "Редактировать эту страницу" в статье, которую хотели бы перевести. Каждая статья продублирована в поддерживаемом языке, даже если она ещё не переведена с английского.\n2. Редактируйте, придерживаясь существующей разметки. Можете прочитать статью [Как редактировать в ВИКИ](/docs/edit-wiki)\n3. Сделайте [RP](https://docs.github.com/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request) с внесенными вами изменениями.\n\n## Добавление нового языка\n\nЕсли язык, на который вы бы хотели перевести статью, ещё не добавлен, запросите его добавление у корневой команды разработчиков Робономики, [создав Issue](https://docs.github.com/desktop/contributing-and-collaborating-using-github-desktop/creating-an-issue-or-pull-request) на GitHub.\n\nКогда мы добавим поддержку запрашиваемого языка на сайт, то закроем Issue, прокомментировав его при необходимости. Вам придет соответствующее уведомление. Это значит, что можно переводить страницы (они уже будут сдублировны на английском в папке вида `/docs/локаль-вашего-языка`)\n\n## Примечания\n* Если вы заметили, как можно улучшить существующий перевод той или иной статьи, можете так же воспользовать функицоналом PR или Issue на GitHub\n* При значительном вкладе в перевод вы можете поучаствовать в программе вознаграждений. '}},{node:{id:"05caf33c7bdc97784bc84e90d6ee6378",title:"Sensors Connectivity",path:"/docs/ru/sensors-connectivity/",content:'\nThis Aira package allows you to read data from a SDS011 sensor and publish to different output channels. That said Aira is able to form a json formatted message with measurements and publish to a few channels. Also it includes Datalog feature which is still experimental. It could be used to publish data to Substrate based blockchain by Robonomics.\n\nThe last release is [Sensors Connectivity v0.2](https://github.com/airalab/sensors-connectivity/releases/tag/v0.2)\n\n## Sensor Connectivity Protocol :: v1\n\n### Sensor to Station\n\n**TCP Session diagram**\n\n| HEADER | DATA1 | DATA2 | DATA3 | ... | DATAN |\n|--------|-------|-------|-------|-----|-------|\n\nwhere `HEADER` is 34 bytes\n\n|      | Name      |\n|------|-----------|\n| 0x00 | public_id |\n| 0x20 | codec_id  |\n\n* `public_id` - Public identifier, generated on sensor setup.\n* `codec_id` - Type of used data codec.\n\n**Data frame**\n\n|      | Name      |\n|------|-----------|\n| 0x22 | payload   |\n| 0xNN | signature |\n\n\n* `payload` - Sensor measurements.\n* `signature` - Measurement Ed25519 signature, 64 bytes long. ([pynacl](https://github.com/pyca/pynacl))\n\nFor SDS011 sensor `payload` consists of 4 float numbers: PM2.5, PM10, GEO_LAT, GEO_LON\n\n### Station to Robonomics\n\nThe default output channel is Robonomics protocol over IPFS pubsub. For every measurement connectivity produces the following json formatted string:\n\n```\n{public_id: {"model": codec_id,"timestamp": unix_timestamp, "measurement": {"pm25": PM2.5, "pm10": PM10, "geo": "GEO_LAT,GEO_LON"}}}\n```\n\n## Stations and Feeders\n\nIn Sensors Connectivity there are two entities: station and feeder.\n\n### Station\n\nStation represents a source of data. The package can handle many inputs simultaneously:\n\n```\nstation1 \\                        / output1\nstation2 -  sensors-connectivity  - output2\nstation3 /                        \\ output3\n```\n\nThere are COM Station and TCP Station implemented. The first one reads data from a sensor that is connected to a serial port. TCP Station starts a tcp server and listens to incoming connections. \n\nTCP Station can accept data from every sensor or you can specify an access control list (ACL) for known sensors only.\n\n### Feeder\n\nFeeder is an output in terms of sensors connectivity:\n\n```\ninput1 \\                        / feeder1\ninput2 -  sensors-connectivity  - feeder2\ninput3 /                        \\ feeder3\n```\n\nAt current implementation the package can publish data to [Luftdaten](https://meine.luftdaten.info/), Robonomics or Robonomics on Substrate (using Datalog feature).\n\n## Connectivity Configuration\n\nThe package is highly configurable. The default configuration file looks like:\n\n```yaml\n# Please DO NOT edit this file\n# Make a copy instead, make changes and pass the absolute path to the copy in arguments\ngeneral:\n  publish_interval: 300 # time between two published messages\ncomstation:\n  port: "/dev/ttyUSB0"  # COM port of the device\n  work_period: 300      # time between two measurements in seconds\n  geo: ""               # Geo coordinates as latitude,longitude\n  public_key: ""        # If not provided, COMStation creates itself\ntcpstation:\n  address: ""           # IP and PORT to listen to, for example 0.0.0.0:31313\n  acl:                  # list of known addresses. If not specified accepts from everyone\n  # -\n  # -\nluftdaten:\n  enable: true          # whether or not publish to https://luftdaten.info/\nrobonomics:\n  enable: true          # enable use of Robonomics Network\n  ipfs_provider: ""     # ipfs endpoint\n  ipfs_topic: "airalab.lighthouse.5.robonomics.eth"\ndatalog:\n  enable: false         # enable use of Datalog Robonomics subcommand\n  path: ""              # path to Robonomics execution file\n  suri: ""              # private key of publisher account\n  remote: "wss://substrate.ipci.io"\n  dump_interval: 3600   # time between two transactions in seconds\n  temporal_username:    # set to pin files in Temporal.Cloud\n  temporal_password:\ndev:\n  sentry: ""\n```\n\nTo get familiar with all the options and launch scenarios check the [README.md](https://github.com/airalab/sensors-connectivity/tree/v0.2) out.\n\n'}},{node:{id:"887cbfea9b63e2ae6011d24fb54e7238",title:"Install Sensors Connectivity on Your Own Aira",path:"/docs/ru/sensors-connectivity-on-aira/",content:'\n## Prerequirements\n\nYou must have an AIRA instance somewhere\n\n## Install the Package\n\n```\ngit clone https://github.com/airalab/sensors-connectivity\ncd sensors-connectivity\nnix build -f release.nix\n```\n\nFrom this point you can run the package with the default configuration file or create a systemd service to launch it automatically\n\n### Edit Configuration File\n\nAssuming you are in the package root directory edit the file:\n```\ncp config/default.json config/my.json\nvim config/my.json\n```\n\nExtended description of options is located [here](/docs/configuration-options-description)\n\n### Run Manually\n\nFrom the package directory:\n\n```\nsource result/setup.zsh\nroslaunch sensors_connectivity agent.launch config:=/root/sensors-connectivity/config/my.json\n```\n\n### Run via systemd\n\nAdd the following to `/etc/nixos/configuration.nix`:\n\n```\nsystemd.services.connectivity = {\n  requires = [ "roscore.service" ];\n  after = ["roscore.service" ];\n  wantedBy = [ "multi-user.target" ];\n  environment.ROS_MASTER_URI =  "http://localhost:11311";\n  script = \'\'\n    source /root/sensors-connectivity/result/setup.bash && roslaunch sensors_connectivity agent.launch config:=/root/sensors-connectivity/config/my.json\n  \'\';\n  serviceConfig = {\n    Restart = "on-failure";\n    StartLimitInterval = 0;\n    RestartSec = 60;\n    User = "root";\n  };\n};\n```\n\nThen\n\n```\nnixos-rebuild switch\n```\n\nRunning\n\n```\nsystemctl start connectivity.service\n```\n\n'}},{node:{id:"cd202774c4f705bee7e9cda2fca0cec0",title:"Securely connect cloud AI to the factory floor",path:"/docs/ru/securely-connect-cloud-ai-to-the-factory-floor/",content:"\nRobonomics technologies can already solve the challenges that Industry 4.0 faces and they are already applied to real-world scenarios in the industrial environment.\n\nA large number of AI companies are building solutions to optimize the processes on the factory floor, allowing plants to produce more with less cost. However, most plants are hesitant to connect their infrastructure to the cloud directly since this results in potential cybersecurity risks, which could lead to million-dollar losses and even the loss of human life.\n\n[MerkleBot](https://merklebot.com) has used [Robonomics Network](https://robonomics.network) to build a solution for industrial clients to connect their factory to the cloud-based AI in a secure way.\n\nThis article is written in the wake of an experiment we conducted with [Veracity Protocol](https://www.veracityprotocol.org/) that uses algorithms to create non-invasive protection of any physical item based on the photographs from a mobile device.\n\nThis use case shows the process of scanning the industrial parts using a robotic arm.\n\n[Demo video](https://youtu.be/8AL70LFVX5w)\n\n## Step-by-step process\n\n### DApp as user interface\n\n![](../images/google-play-store.gif)\n\nDApp acts as a user interface for the operator. It is used to request the launch of the robot to collect the photographs and its purpose is to allow secure communication between the factory environment and cloud-based AI.\n\n### Launching the robot\n\n![](../images/Veracity_Protocol_Transaction.gif)\n\nThe operator launches the robotic scan by signing the transaction in the DApp. This step guarantees that the process on the factory floor can only start based on the transaction in the public blockchain.\n\nThe robot receives a command from the blockchain through the Robonomics Network and begins the scan. Robonomics Network technologies allow us to close the gap between the business objective and robotics operation.\n\n### Data collection and sending to cloud-based AI\n\nIn the DApp the operator sees the confirmation and the robot begins to scan the items placed on the table, such as in this use case, or on the factory line directly if the need arises.\n\n![](../images/Veracity_Protocol_Launch.gif)\n\nWhen the robot collects the data, it stores it locally and makes it available to cloud-based AI through IPFS protocol. By encrypting the data and organizing the data exchange through a blockchain transaction as well, we can authorize access to cloud-based AI while making sure that the data remains secure and in place.\n\nThe security mechanism built into Robonomics based on the shared security of public blockchains allows gaining the level of security that is prohibitively expensive for most factories to organize on their own.\n\n### Digital passport creation\n\nWhen the cloud-based AI analyses the data, the log file and recommendations are recorded as a [Digital Passport](https://wiki.robonomics.network/docs/create-digital-identity-run-by-ethereum/) automatically. Every operation and scan can be traced back since the blockchain record has the hash to all these files through IPFS protocol.\n\n## Comments about the use case\n\nIn this use case, Universal Robot UR3 industrial arm was used. But thanks to Robonomics support for ROS, most major industrial manipulators can be used and connected to cloud-based AI securely, including KUKA, Fanuc, and Yaskawa.\n\nIf you are interested to learn more about the deployment and integration of cloud-based AI instruments securely please [reach out](mailto:v@merklebot.com)\n"}},{node:{id:"376e29b62ac7a29031f1e491d44b777f",title:"Manual start of the Robonomics network, consisting of 3 nodes",path:"/docs/ru/robonomics-test-network-manual/",content:'\n**Need to start Robonomics network of N (N> = 2) nodes**\n\n## Requirements\n- Robonomics binary, download latest here: https://github.com/airalab/robonomics/releases/\n- Subkey tool, download latest here: https://github.com/airalab/robonomics/releases/\n- 3 servers with root shell. Their ip-addresses in the current instruction will be `165.227.171.127`, `159.89.25.75` and `159.89.30.50`\n\n## Introduction\nIn this tutorial, we will first create all key files locally, and then upload them to their corresponding nodes. \n\n## Prepare directories\nDownload 2 archives from the links above and open the folder with them in the terminal.\nThen create a directory for the project, unpack the archives into it and go to the created folder:\n```\n$ mkdir robonomics_test_network\n$ tar -xf ./robonomics-ubuntu-0.21.0-x86_64.tar.xz -C ./robonomics_test_network/\n$ tar -xf ./subkey-ubuntu-0.21.0-x86_64.tar.xz -C ./robonomics_test_network/\n$ cd ./robonomics_test_network/\n```\n\nNext, create a separate **uploads** directory and the necessary subdirectories for each server. All files intended for uploading to a specific server will be stored in these subdirectories:\n```\n$ mkdir -p uploads/165.227.171.127/keystore && mkdir -p uploads/165.227.171.127/network\n$ mkdir -p uploads/159.89.25.75/keystore && mkdir -p uploads/159.89.25.75/network\n$ mkdir -p uploads/159.89.30.50/keystore && mkdir -p uploads/159.89.30.50/network\n```\n\nAlso, create a **local** folder with **validators** and **sudo** folders, which will store the validators and sudo keys locally.\n```\n$ mkdir -p local/validators && mkdir -p local/sudo\n```\n\n## Prepare spec.json\nUsing the robonomics binary, generate a **spec.json** file, which will use as the basis:\n```\n$ ./robonomics build-spec --chain dev > uploads/spec.json\n```\n\nNext, edit this file. At first correct the first three fields, make them look like this:\n```\n"name": "Test Robonomics Network",\n"id": "dev",\n"chainType": "Live",\n```\n\n### bootNodes\nThe **bootNodes** field is a list of strings of special format. For each of the bootnodes must write the corresponding string here.\nTo do this, first create a key file for each bootnode using **subkey**:\n```\n$ ./subkey generate-node-key uploads/165.227.171.127/network/secret_ed25519  \n12D3KooWBPq1fDLQC2iqQ4FpM2mUpiXjBRcb8ptk7tbaqr2B6HZN\n$ ./subkey generate-node-key uploads/159.89.25.75/network/secret_ed25519\n12D3KooWRbGmdpbz6o1fe66wFs7nJsUYfBp2f3W7J1uDXj3gt4Bh\n$ ./subkey generate-node-key uploads/159.89.30.50/network/secret_ed25519\n12D3KooWMuTrL9CmJxj8LjH43s4hsJMsyuMdbuB86zCaAf9VCwFf\n```\n\nEach command creates a key file in the specified directory and outputs to stdout the string that will be needed to fill in the **bootNodes** field in the **spec.json** file. As a result, the **bootNodes** section should look like following example:\n```\n"bootNodes": [\n"/ip4/165.227.171.127/tcp/30333/p2p/12D3KooWBPq1fDLQC2iqQ4FpM2mUpiXjBRcb8ptk7tbaqr2B6HZN",\n"/ip4/159.89.25.75/tcp/30333/p2p/12D3KooWRbGmdpbz6o1fe66wFs7nJsUYfBp2f3W7J1uDXj3gt4Bh",\n"/ip4/159.89.30.50/tcp/30333/p2p/12D3KooWMuTrL9CmJxj8LjH43s4hsJMsyuMdbuB86zCaAf9VCwFf"\n],\n```\nThe next 3 fields (telemetryEndpoints, protocolId, properties) can be filled like this:\n```\n "telemetryEndpoints": [\n     [\n       "/dns4/telemetry.polkadot.io/tcp/443/x-parity-wss/%2Fsubmit%2F",\n       0\n     ]\n ],\n"protocolId": "txrt",\n"properties": {\n    "ss58Format": 32,\n    "tokenDecimals": 9,\n    "tokenSymbol": "TXRT"\n},\n```\nFurther up to the **palletBalances** field leave unchanged.\n\n\n### palletBalances\nTo fill the palletBalances field create **the number of nodes + 1** (the last key is for **sudo**) keys. This can be done using **subkey**, in the file name must specify **SS58 Address** from the generated key, in the file content must specify **seed** phrase in quotes. \n\nExample creating one key.\n - Generate key:\n    ```\n    $ ./subkey -n robonomics generate\n    Secret phrase `display cargo domain april joy still bundle notice bridge pencil fat approve` is account:\n      Network ID/version: substrate\n      Secret seed:        0x0275ab9bce53e4359184f02112943162c708f483009e0b7b3ba63549c5c2e514\n      Public key (hex):   0xd0996b85dd1b2876080b26123f9c27097d698f871c5978c3cb9c299253e7a530\n      Account ID:         0xd0996b85dd1b2876080b26123f9c27097d698f871c5978c3cb9c299253e7a530\n      SS58 Address:       4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx\n    ```\n - Create key file:\n    ```\n    $ touch ./local/validators/4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx && echo \'"display cargo domain april joy still bundle notice bridge pencil fat approve"\' | tee ./local/validators/4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx\n    ```\n  \nCommand template for creating a validator key file:  \n`touch ./local/validators/**SS58_Address** && echo \'"**seed**"\' | tee ./local/validators/**SS58_Address**`\n\nCommand template for creating a sudo key file:   \n`touch ./local/sudo/**SS58_Address** && echo \'"**seed**"\' | tee ./local/sudo/**SS58_Address**`\n\nThree keys are stored in the **local/validators** folder and one in the **local/sudo** folder. As a result, the following content should appear in the **local** directory:\n```\n./local/\n├── sudo\n│   └── 4Dy6bzrvoApwjLaAjfrtvtX3tthCw6fnCU1Ym5KNyRGt3kKb\n└── validators\n    ├── 4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx\n    ├── 4EeMi84pk5P5nQpyupQeCZ1C4NhUFtMF7Xh1MXJLANkZ3BTd\n    └── 4FPRYfSVqwaX39vXZ78tT3DPBT9FmFXvdQDD7y5UQKncJGu1\n```\n\nNow fill the palletBalances section in the spec.json file with these keys.\nAs a result, it should look like this:\n```\n"palletBalances": {\n  "balances": [\n    [\n      "4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx",    <-- Generated validator 1 key\n      1000000000000000000\n    ],\n    [\n      "4EeMi84pk5P5nQpyupQeCZ1C4NhUFtMF7Xh1MXJLANkZ3BTd",    <-- Generated validator 2 key\n      1000000000000000000\n    ],\n    [\n      "4FPRYfSVqwaX39vXZ78tT3DPBT9FmFXvdQDD7y5UQKncJGu1",    <-- Generated validator 3 key\n      1000000000000000000\n    ],\n    [\n      "4Dy6bzrvoApwjLaAjfrtvtX3tthCw6fnCU1Ym5KNyRGt3kKb",    <-- Generated sudo key\n      1000000000000000000\n    ],\n  ]\n},\n```\nThe values that were previously presented in the palletBalances section must be deleted.\n\n### palletSession\nNext step is the **palletSession** section in file **spec.json**. First let\'s describe its format. \nThis section contains the "keys" field, that contains a list of three lists (equals of nodes count). Each of these lists looks like follows:\n```\n[\n    "%validator_SS58_address%",\n    "%validator_SS58_address%",\n    {\n        "babe": "%sr25519_babe_SS58_address%",\n        "im_online": "%sr25519_im_online_SS58_address%"\n        "authority_discovery": "%sr25519_authority_discovery_SS58_address%",\n        "grandpa": "%ed25519_grandpa_SS58_address%",\n    }\n]\n```\n**%validator_SS58_address%** is the validator key that was generated for each node in the **palletBalances** section of this manual. Just copy it twice for each node.\n\nTo fill in the remaining 4 lines for each node, you need to create 4 key files for each node and store them in the **keystore** folders.\nAs key files are generated, you can fill **palletSession**.\n\nEach key file must contain a **seed** phrase in quotes.\nMaking of the name of each key file require separate consideration.\nThe name of each key file is formed as **prefix** + **account_id without leading hexadecimal zero**.\n\nPrefixes matching:  \n>      grandpa: \'6772616e\'  \n>      babe: \'62616265\'\n>      im_online: \'696d6f6e\'  \n>      authority_discovery: \'61756469\'  \n\nAn example of creating keys for one node:\n- Creating a **babe** (prefix *62616265*) key file.   \n  ```\n  $ ./subkey --sr25519 -n robonomics generate\n  ```\n  >  Secret phrase **cover once garment syrup income chair elder business diary frozen rack damage** is account:  \n  >\n  >  Network ID/version: `substrate`\n  >\n  >  Secret seed:        `0x90ddeee3a9a0c464572021d311c245eefc41f9a59c739faefda47efcf4755677`\n  >\n  >  Public key (hex):   `0xfa44d96e310cf68350dd855c745794f7c1afa63089ebdb2c96bff3797972bb43`\n  >\n  >  Account ID:         `0xfa44d96e310cf68350dd855c745794f7c1afa63089ebdb2c96bff3797972bb43`\n  > \n  >  SS58 Address:       `4HirHF5BVHxkRBtqptFxBSmnAiZir1qQLs6pL9Utmm4eF77C`\n  \n ```\n $ touch uploads/165.227.171.127/keystore/62616265fa44d96e310cf68350dd855c745794f7c1afa63089ebdb2c96bff3797972bb43 && echo \'"cover once garment syrup income chair elder business diary frozen rack damage"\' | tee ./uploads/165.227.171.127/keystore/62616265fa44d96e310cf68350dd855c745794f7c1afa63089ebdb2c96bff3797972bb43 \n ```\n This command creates a **babe** key file for the `165.227.171.127` node. To fill in **spec.json**, need to take from this output the value **SS58 Address**: `4HirHF5BVHxkRBtqptFxBSmnAiZir1qQLs6pL9Utmm4eF77C`. This address need to insert instead of `%sr25519_babe_SS58_address%` in the above **palletSession** template.\n   \n **babe** key file creation command template:  \n`touch ./uploads/[node_ip]/keystore/62616265+[Account_ID] && echo \'"[seed]"\' | tee ./uploads/[node_ip]/keystore/62616265+[Account_ID]`  \n\nAs you can see, the name of the babe key file is the sum of two substrings: `babe prefix (\'62616265\')`, and the `account_id` of the generated key, without the leading zero (`fa44d96e310cf68350dd855c745794f7c1afa63089ebdb2c96bff3797972bb43`). \n  Note that the keys `babe, im_online, authority_discovery` are generated with the indication `--sr25519`.  \n  **grandpa** key have to generate with the indication `--ed25519`.\n \n\n- Creating an **im_online** (prefix *696d6f6e*) key file.  \n  ```\n  $ ./subkey --sr25519 -n robonomics generate\n  ```\n  > Secret phrase **envelope truly balance turkey undo casual waste skill average ordinary gun split** is account:\n  >\n  >   Network ID/version: `substrate`\n  > \n  >   Secret seed:        `0x8a19df08feeff9f1fa3581902ca22a305252aea32e284d32f10e990d00bb8926`\n  > \n  >   Public key (hex):   `0x6c13ff8e37d91b80fe3b03f9b92a91a1ef7db741434cf12cc44d5ed29257ab09`\n  >  \n  >   Account ID:         `0x6c13ff8e37d91b80fe3b03f9b92a91a1ef7db741434cf12cc44d5ed29257ab09`\n  >  \n  >   SS58 Address:       `4EWQyBRoucH4Wjd4JtGoSEYYCw4bbkonjoFy9hNUX5fbmMEt`\n   \n  ```\n  $ touch uploads/165.227.171.127/keystore/696d6f6e6c13ff8e37d91b80fe3b03f9b92a91a1ef7db741434cf12cc44d5ed29257ab09 && echo \'"envelope truly balance turkey undo casual waste skill average ordinary gun split"\' | tee uploads/165.227.171.127/keystore/696d6f6e6c13ff8e37d91b80fe3b03f9b92a91a1ef7db741434cf12cc44d5ed29257ab09\n  ```\n  **im_online** key file creation command template:  \n  `touch ./uploads/[node_ip]/keystore/696d6f6e+[Account_ID] && echo \'"[seed]"\' | tee ./uploads/[node_ip]/keystore/696d6f6e+[Account_ID]`\n  \n  **spec.json**: `4EWQyBRoucH4Wjd4JtGoSEYYCw4bbkonjoFy9hNUX5fbmMEt` need to insert instead of `%sr25519_im_online_SS58_address%` in the above **palletSession** template.\n\n\n- Creating an **authority_discovery** (prefix *61756469*) key file.\n   ```\n   $ ./subkey --sr25519 -n robonomics generate\n   ```\n   > Secret phrase **boy harsh because omit equip atom apart spring undo explain walnut crystal** is account:\n   >\n   > Network ID/version: `substrate`\n   >\n   >   Secret seed:        `0x27838c9ea0524353da3717862ef0ecef123f40e81b73bb5ef377d12b47d1c543`\n   > \n   >   Public key (hex):   `0x4e33ccfd4105d30dfd93c5ef4658e2585a749508ea7c7abe754efc36dd634c07`\n   > \n   >   Account ID:         `0x4e33ccfd4105d30dfd93c5ef4658e2585a749508ea7c7abe754efc36dd634c07`\n   >  \n   >   SS58 Address:       `4DqEyoefRSz746sjaonxJ7KZQz8MUq4cKFA87DfoLzQgWk8t`\n   \n   ```\n   $ touch uploads/165.227.171.127/keystore/617564694e33ccfd4105d30dfd93c5ef4658e2585a749508ea7c7abe754efc36dd634c07 && echo \'"boy harsh because omit equip atom apart spring undo explain walnut crystal"\' | tee uploads/165.227.171.127/keystore/617564694e33ccfd4105d30dfd93c5ef4658e2585a749508ea7c7abe754efc36dd634c07\n   ```\n  **authority_discovery** key file creation command template:  \n  `touch ./uploads/[node_ip]/keystore/61756469+[Account_ID] && echo \'"[seed]"\' | tee ./uploads/[node_ip]/keystore/61756469+[Account_ID]` \n  \n   **spec.json**: `4DqEyoefRSz746sjaonxJ7KZQz8MUq4cKFA87DfoLzQgWk8t` need to insert instead of `%sr25519_authority_discovery_SS58_address%` in the above **palletSession** template.\n\n\n- Creating a **grandpa** (prefix *6772616e*) key file.\n   ```\n   $ ./subkey --ed25519 -n robonomics generate\n   ```\n   > Secret phrase **squeeze nature off vendor comic pause tattoo seek omit spatial regular cattle** is account:\n   > \n   >   Network ID/version: `substrate`\n   >\n   >   Secret seed:        `0xef0a9f51a4da7b789c0a25d39b44428d4da7262cc3fe013d4383b45216e8b83e`\n   >  \n   >   Public key (hex):   `0x7ea1beed13fb66a333b50b1ae417ebfd152bab99b223be2d4d886adb5fa7f009`\n   >  \n   >   Account ID:         `0x7ea1beed13fb66a333b50b1ae417ebfd152bab99b223be2d4d886adb5fa7f009`\n   > \n   >   SS58 Address:       `4EvjwRdgUg6YtdUDjq6Z3PoTKtzH5cgFgwnzArMSbw3RzYTa`\n    \n   ```\n   $ touch uploads/165.227.171.127/keystore/6772616e7ea1beed13fb66a333b50b1ae417ebfd152bab99b223be2d4d886adb5fa7f009 && echo \'"squeeze nature off vendor comic pause tattoo seek omit spatial regular cattle"\' | tee uploads/165.227.171.127/keystore/6772616e7ea1beed13fb66a333b50b1ae417ebfd152bab99b223be2d4d886adb5fa7f009\n   ```\n   **grandpa** key file creation command template:  \n  `touch ./uploads/[node_ip]/keystore/6772616e+[Account_ID] && echo \'"[seed]"\' | tee ./uploads/[node_ip]/keystore/6772616e+[Account_ID]`\n   \n   **spec.json**: `4EvjwRdgUg6YtdUDjq6Z3PoTKtzH5cgFgwnzArMSbw3RzYTa` need to insert instead of `%sr25519_grandpa_SS58_address%` in the above **palletSession** template.\n   \n   \n**Now 4 key files have been created for one node. Need to repeat this actions for the remaining two nodes.**\n\nYou should get the following **uploads** directory structure after creating all the keys:\n```\n./uploads/\n├── 165.227.171.127\n│   ├── keystore\n│   │   ├── 617564694e33ccfd4105d30dfd93c5ef4658e2585a749508ea7c7abe754efc36dd634c07\n│   │   ├── 62616265fa44d96e310cf68350dd855c745794f7c1afa63089ebdb2c96bff3797972bb43\n│   │   ├── 6772616e7ea1beed13fb66a333b50b1ae417ebfd152bab99b223be2d4d886adb5fa7f009\n│   │   └── 696d6f6e6c13ff8e37d91b80fe3b03f9b92a91a1ef7db741434cf12cc44d5ed29257ab09\n│   └── network\n│       └── secret_ed25519\n├── 159.89.25.75\n│   ├── keystore\n│   │   ├── 617564692ac9bd30c0168fa623cfd66abb4327992d900a652bcbb238b740bdde497a565f\n│   │   ├── 626162657cd666bb540c41cb33896a34d7413ffb86fcef1eddddfcd4edb325166df6335d\n│   │   ├── 6772616e084402349bc08ef90c2837e8e3f12ebe8bd4ab86809e9ee5f4f8ca26e73a0518\n│   │   └── 696d6f6e6ed2d507c0283ae869ba6514975bd8765eb8e06abd22afc09e8f36ef3950a116\n│   └── network\n│       └── secret_ed25519\n└── 159.89.30.50\n|   ├── keystore\n|   │   ├── 61756469f20a4e16a0ee79431d6f9a70c38892c7532ad1347c2226d43ef6ffe8966e9b30\n|   │   ├── 62616265e695aa459dbfd42bea7ed3b87970f164f34b6fee4d5a831ffbecd89eb9769b26\n|   │   ├── 6772616eadef59f896ea6b94bcd4519be8cc4b70263fc318cec1a3be14850bbc22117c34\n|   │   └── 696d6f6e2cb4dc8f8a67f477da15045ca40ef3861a2a6b2034ae0c64a179b4431341ea2c\n|   └── network\n|       └── secret_ed25519\n└── spec.json\n```\n\nThe palletSession section should look like this:\n```\n"palletSession": {\n    "keys": [\n        [\n            "4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx",    <-- Validator 1 SS58 Address\n            "4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx",    <-- Validator 1 SS58 Address\n            {\n                "authority_discovery": "4DqEyoefRSz746sjaonxJ7KZQz8MUq4cKFA87DfoLzQgWk8t",\n                "babe": "4HirHF5BVHxkRBtqptFxBSmnAiZir1qQLs6pL9Utmm4eF77C",\n                "grandpa": "4EvjwRdgUg6YtdUDjq6Z3PoTKtzH5cgFgwnzArMSbw3RzYTa",\n                "im_online": "4EWQyBRoucH4Wjd4JtGoSEYYCw4bbkonjoFy9hNUX5fbmMEt"\n            }\n        ],\n        [\n            "4EeMi84pk5P5nQpyupQeCZ1C4NhUFtMF7Xh1MXJLANkZ3BTd",    <-- Validator 2 SS58 Address\n            "4EeMi84pk5P5nQpyupQeCZ1C4NhUFtMF7Xh1MXJLANkZ3BTd",    <-- Validator 2 SS58 Address\n            {\n                "authority_discovery": "4F6daoG2gBXRLvbT4mVRajExZdZBHH7APmX3wDuLYJyzxHSS",\n                "babe": "4C7vBVHUYKqApCywqGsuap6XhjZ3gdYnW4YYP2mMyvYctLqT",\n                "grandpa": "4G3Ai6BGUjqtCoM2aTvWyR19gQ8WZiNnh1KFM47RyiYTwkE6",\n                "im_online": "4FHA7gzKfSLvd8jP85JUCWV6RyeRLm331KHcjnynGx7TWm7D"\n            }\n        ],\n        [\n            "4FPRYfSVqwaX39vXZ78tT3DPBT9FmFXvdQDD7y5UQKncJGu1",    <-- Validator 3 SS58 Address                        \n            "4FPRYfSVqwaX39vXZ78tT3DPBT9FmFXvdQDD7y5UQKncJGu1",    <-- Validator 3 SS58 Address\n            {\n                "authority_discovery": "4CqzJFkdSZg52PfV6Fd4gJ3vPLmRu1HGuPvNivjJ8dDWaz1a",\n                "babe": "4EComk8TsrT399xT6MPhGnhbZEif6U6cny8DiyZ3zezo9b5f",\n                "grandpa": "4Cqi4rG3CzWRZairhZX4isT8qG2jyz9fGDXJMrP6uBYkrft5",\n                "im_online": "4C7V6R59cZVbabExqgWvHVE1vj1E1cV42SZr8d8zZD3gmsqk"\n            }\n        ]\n    ]\n},\n```\n\n### palletStaking\n**palletStaking** must be filled in as follows:\n```\n"palletStaking": {\n    "historyDepth": 84,\n    "validatorCount": 10,\n    "minimumValidatorCount": 2,\n    "invulnerables": [\n        "4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx",     <-- Validator 1 SS58 Address\n        "4EeMi84pk5P5nQpyupQeCZ1C4NhUFtMF7Xh1MXJLANkZ3BTd",     <-- Validator 2 SS58 Address\n        "4FPRYfSVqwaX39vXZ78tT3DPBT9FmFXvdQDD7y5UQKncJGu1"      <-- Validator 3 SS58 Address\n    ],\n    "forceEra": "NotForcing",\n    "slashRewardFraction": 100000000,\n    "canceledPayout": 0,\n    "stakers": [\n        [\n            "4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx",  <-- Validator 1 SS58 Address\n            "4HirHF5BVHxkRBtqptFxBSmnAiZir1qQLs6pL9Utmm4eF77C",  <-- Validator 1 babe address\n            1000000,\n            "Validator"\n        ],\n        [\n            "4EeMi84pk5P5nQpyupQeCZ1C4NhUFtMF7Xh1MXJLANkZ3BTd",  <-- Validator 2 SS58 Address\n            "4C7vBVHUYKqApCywqGsuap6XhjZ3gdYnW4YYP2mMyvYctLqT",  <-- Validator 2 babe address\n            1000000,\n            "Validator"\n        ],\n        [\n            "4FPRYfSVqwaX39vXZ78tT3DPBT9FmFXvdQDD7y5UQKncJGu1",   <-- Validator 3 SS58 Address\n            "4EComk8TsrT399xT6MPhGnhbZEif6U6cny8DiyZ3zezo9b5f",   <-- Validator 3 babe address\n            1000000,\n            "Validator"\n        ]\n    ]\n},\n```\nThe example specified in which fields what values should be substituted.\n\n### palletSudo\nIn the rest of the **spec.json** file, you need to change only the contents of **palletSudo**, substituting the previously generated **sudo** address there:\n```\n            "palletBabe": {\n                "authorities": []\n            },\n            "palletGrandpa": {\n                "authorities": []  \n            },\n            "palletImOnline": {\n                "keys": []\n            },\n            "palletAuthorityDiscovery": {\n                "keys": []\n            },\n            "palletTreasury": {},\n            "palletElectionsPhragmen": {\n                "members": []\n            },\n            "palletCollectiveInstance1": {\n                "phantom": null,\n                "members": []\n            },\n            "palletSudo": {\n                "key": "4Dy6bzrvoApwjLaAjfrtvtX3tthCw6fnCU1Ym5KNyRGt3kKb"   <-- sudo address\n            }\n        }\n    }\n}\n```\n\n## systemd unit file\nNow create systemd unit file:\n```\n$ touch ./uploads/robonomics.service\n```\n\nAnd fill it like this:\n```\n[Unit]\nDescription=robonomics\nAfter=network.target\n\n[Service]\nUser=root\nGroup=root\nType=users\nWorkingDirectory=/root\nRestart=on-failure\nExecStart=/usr/bin/robonomics  --chain /etc/substrate/spec.json --name ${HOSTNAME} --validator\n\n[Install]\nWantedBy=multi-user.target\n```\nAs you can see from the "ExecStart" line, the **robonomics** binary is stored in the **/usr/bin/** directory, and the **spec.json** file is stored in the **/etc/substrate/** directory.\n\n## Uploading files\nThe following one-line command uploads all files to the required directories on the servers. It is important that there are no other folders in the **uploads** directory, except for the folders with the ip-addresses of the nodes:\n```\n$ \\\nfor IP in `ls -l ./uploads/ | grep \'^d\' | awk \'{print $9}\'`; do \\\n    ssh root@"$IP" "mkdir -p /root/.local/share/robonomics/chains/dev" && \\\n    scp -r ./uploads/$IP/* root@$IP:/root/.local/share/robonomics/chains/dev/ && \\\n    scp ./uploads/robonomics.service root@$IP:/etc/systemd/system/ && \\\n    scp ./robonomics root@$IP:/usr/bin/ && \\\n    ssh root@$IP "mkdir -p /etc/substrate" && \\\n    scp ./uploads/spec.json root@$IP:/etc/substrate/ \\\n; done\n```\n\n## Network launch\nNow connect to all nodes, enable and start the **robonomics.service** unit:\n```\n$  \\\nfor IP in `ls -l ./uploads/ | grep \'^d\' | awk \'{print $9}\'`; do \\\n   ssh root@$IP "systemctl enable robonomics.service && systemctl start robonomics.service" \\\n; done\n```\nAfter starting the service on all three nodes, you can view the node logs using **journalctl**. \nTo do this, you can connect to any existing server via ssh and run the following command:\n```\n$ journalctl -u robonomics.service -f\n```\n![Robonomics Chart](../images/robonomics-test-network-manual/result-journalctl.jpg "Robonomics Network journalctl stdout")\n'}},{node:{id:"7e865494bb6a151103643b9968791e02",title:"Robonomics + Prometheus + Grafana",path:"/docs/ru/robonomics-prometheus-grafana/",content:"\n**The following instruction is provided by [Hubo Bubo](https://github.com/hubobubo)**\n\n**The original article is located [here](https://github.com/hubobubo/robonomics/wiki/Robonomics-(XRT)-metrics-using-Prometheus-and-Grafana)**\n\n## Introduction\nTo better monitor and maintain Robonomics node(s) it's good to setup a monitoring based on Prometheus Server and Grafana. This doc will show how to configure each one of it to fully monitor your node.\n\n##  Prerequisites\n* [Server Setup with Ubuntu 18.04](https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-18-04) \n* [Robonomics parachain collator installed](https://blog.aira.life/installing-and-running-the-robonomics-validator-in-the-polkadot-network-487ad4c1a567)\n* Make sure you have robonomics.service working on your machine and port 9615 is reachable \n\n## Step 1 — Creating Service Users\n\nFor security purposes, we’ll begin by creating two new user accounts, prometheus and node_exporter. Create these two users, and use the _--no-create-home_ and _--shell /bin/false_ options so that these users can’t log into the server.\n```\nsudo useradd --no-create-home --shell /bin/false prometheus\nsudo useradd --no-create-home --shell /bin/false node_exporter\n```\n\nBefore we download the Prometheus binaries, create the necessary directories for storing Prometheus’ files and data. Following standard Linux conventions, we’ll create a directory in _/etc_ for Prometheus’ configuration files and a directory in _/var/lib_ for its data.\n```\nsudo mkdir /etc/prometheus\nsudo mkdir /var/lib/prometheus\n```\nNow, set the user and group ownership on the new directories to the prometheus user.\n```\nsudo chown prometheus:prometheus /etc/prometheus\nsudo chown prometheus:prometheus /var/lib/prometheus\n```\n## Step 2 — Downloading Prometheus\n\nFirst, download and unpack the current stable version of Prometheus into your home directory. You can find the latest binaries on the [Prometheus download page.](https://prometheus.io/download/)\n\n```\nwget https://github.com/prometheus/prometheus/releases/download/v2.21.0/prometheus-2.21.0.linux-amd64.tar.gz\n\n```\nNow, unpack the downloaded archive.\n\n```\ntar xvf prometheus-2.21.0.linux-amd64.tar.gz\n\n```\nThis will create a directory called prometheus-2.21.0.linux-amd64 containing two binary files (prometheus and promtool), _consoles_ and _console_libraries_ directories containing the web interface files, a license, a notice, and several example files.\n\nCopy the two binaries to the _/usr/local/bin_ directory.\n\n```\nsudo cp prometheus-2.21.0.linux-amd64/prometheus /usr/local/bin/\nsudo cp prometheus-2.21.0.linux-amd64/promtool /usr/local/bin/\n\n```\nSet the user and group ownership on the binaries to the prometheus user created in Step 1.\n\n```\nsudo chown prometheus:prometheus /usr/local/bin/prometheus\nsudo chown prometheus:prometheus /usr/local/bin/promtool\n\n```\nCopy the consoles and _console_libraries_ directories to _/etc/prometheus_.\n\n```\nsudo cp -r prometheus-2.21.0.linux-amd64/consoles /etc/prometheus\nsudo cp -r prometheus-2.21.0.linux-amd64/console_libraries /etc/prometheus\n\n```\nSet the user and group ownership on the directories to the prometheus user. Using the -R flag will ensure that ownership is set on the files inside the directory as well.\n\n```\nsudo chown -R prometheus:prometheus /etc/prometheus/consoles\nsudo chown -R prometheus:prometheus /etc/prometheus/console_libraries\n\n```\nNow that Prometheus is installed, we’ll create its configuration and service files in preparation of its first run.\n\n## Step 3 — Configuring Prometheus\n\nIn the _/etc/prometheus_ directory, use nano or your favorite text editor to create a configuration file named _prometheus.yml_.\n\n```\nsudo nano /etc/prometheus/prometheus.yml\n\n```\nIn the global settings, define the default interval for scraping metrics. Note that Prometheus will apply these settings to every exporter unless an individual exporter’s own settings override the globals.\n\n```\nglobal:\n  scrape_interval: 15s\n\n```\nThis scrape_interval value tells Prometheus to collect metrics from its exporters every 15 seconds, which is long enough for most exporters.\nNow, add Prometheus itself to the list of exporters to scrape from with the following scrape_configs directive:\n\n```\n...\nscrape_configs:\n  - job_name: 'prometheus'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9090']\n```\nPrometheus uses the _job_name_ to label exporters in queries and on graphs, so be sure to pick something descriptive here.\n\nAnd, as Prometheus exports important data about itself that you can use for monitoring performance and debugging, we’ve overridden the global scrape_interval directive from 15 seconds to 5 seconds for more frequent updates.\n\nLastly, Prometheus uses the _static_configs_ and _targets_ directives to determine where exporters are running. Since this particular exporter is running on the same server as Prometheus itself, we can use localhost instead of an IP address along with the default port, 9090.\n\nYour configuration file should now look like this:\n\n```\nglobal:\n  scrape_interval: 15s\n\nscrape_configs:\n  - job_name: 'prometheus'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9090']\n```\nSave the file and exit your text editor.\n\nNow, set the user and group ownership on the configuration file to the prometheus user created in Step 1.\n\n```\nsudo chown prometheus:prometheus /etc/prometheus/prometheus.yml\n\n```\nWith the configuration complete, we’re ready to test Prometheus by running it for the first time.\n\n## Step 4 — Running Prometheus\n\nStart up Prometheus as the _prometheus_ user, providing the path to both the configuration file and the data directory.\n\n```\nsudo -u prometheus /usr/local/bin/prometheus \\\n    --config.file /etc/prometheus/prometheus.yml \\\n    --storage.tsdb.path /var/lib/prometheus/ \\\n    --web.console.templates=/etc/prometheus/consoles \\\n    --web.console.libraries=/etc/prometheus/console_libraries\n```\n\nThe output contains information about Prometheus’ loading progress, configuration file, and related services. It also confirms that Prometheus is listening on port _9090_.\n\n```\n_log output_\nSep 14 17:55:53 robonomics systemd[1]: Started Prometheus.\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.347Z caller=main.go:310 msg=\"No time or size retention was set so using the default time retention\" duration=15d\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.350Z caller=main.go:346 msg=\"Starting Prometheus\" version=\"(version=2.21.0, branch=HEAD, revision=e83ef207b6c2398919b69cd87d2693cfc2fb4127)\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:347 build_context=\"(go=go1.15.2, user=root@a4d9bea8479e, date=20200911-11:35:02)\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:348 host_details=\"(Linux 4.15.0-112-generic #113-Ubuntu SMP Thu Jul 9 23:41:39 UTC 2020 x86_64 robonomics (none))\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:349 fd_limits=\"(soft=1024, hard=4096)\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:350 vm_limits=\"(soft=unlimited, hard=unlimited)\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.357Z caller=main.go:701 msg=\"Starting TSDB ...\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.368Z caller=web.go:523 component=web msg=\"Start listening for connections\" address=0.0.0.0:9090\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.372Z caller=head.go:644 component=tsdb msg=\"Replaying on-disk memory mappable chunks if any\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:658 component=tsdb msg=\"On-disk memory mappable chunks replay completed\" duration=12.659µs\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:664 component=tsdb msg=\"Replaying WAL, this may take a while\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.380Z caller=head.go:716 component=tsdb msg=\"WAL segment loaded\" segment=0 maxSegment=1\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:716 component=tsdb msg=\"WAL segment loaded\" segment=1 maxSegment=1\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:719 component=tsdb msg=\"WAL replay completed\" checkpoint_replay_duration=48.125µs wal_replay_duration=8.253748ms total_replay_duration=8.343335ms\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.383Z caller=main.go:721 fs_type=EXT4_SUPER_MAGIC\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:724 msg=\"TSDB started\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:850 msg=\"Loading configuration file\" filename=/etc/prometheus/prometheus.yml\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:881 msg=\"Completed loading of configuration file\" filename=/etc/prometheus/prometheus.yml totalDuration=908.135µs remote_storage=6.693µs web_handler=819ns query_engine=1.383µs scrape=400.232µs scrape_sd=41.679µs notify=1.1µs notify_sd=1.847µs rules=1.522µs\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:673 msg=\"Server is ready to receive web requests.\"\n```\nIf you get an error message, double-check that you’ve used YAML syntax in your configuration file and then follow the on-screen instructions to resolve the problem.\n\nNow, halt Prometheus by pressing _CTRL+C_, and then open a new _systemd_ service file.\n\n```\nsudo nano /etc/systemd/system/prometheus.service\n\n```\nThe service file tells _systemd_ to run Prometheus as the prometheus user, with the configuration file located in the _/etc/prometheus/prometheus.yml_ directory and to store its data in the _/var/lib/prometheus_ directory.Copy the following content into the file:\n\n```\n[Unit]\nDescription=Prometheus\nWants=network-online.target\nAfter=network-online.target\n\n[Service]\nUser=prometheus\nGroup=prometheus\nType=simple\nExecStart=/usr/local/bin/prometheus \\\n    --config.file /etc/prometheus/prometheus.yml \\\n    --storage.tsdb.path /var/lib/prometheus/ \\\n    --web.console.templates=/etc/prometheus/consoles \\\n    --web.console.libraries=/etc/prometheus/console_libraries\n\n[Install]\nWantedBy=multi-user.target\n```\n\nFinally, save the file and close your text editor. To use the newly created service, reload systemd.\n\n```\nsudo systemctl daemon-reload\n\n```\nYou can now start Prometheus using the following command:\n\n```\nsudo systemctl start prometheus\n\n```\nTo make sure Prometheus is running, check the service’s status.\n\n```\nsudo systemctl status prometheus\n\n```\nThe output tells you Prometheus’ status, main process identifier (PID), memory use, and more.\n\nIf the service’s status isn’t active, follow the on-screen instructions and re-trace the preceding steps to resolve the problem before continuing the tutorial.\n\n```\n* prometheus.service - Prometheus\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\n   Active: active (running) since Mon 2020-09-14 17:59:48 CEST; 24h ago\n Main PID: 29650 (prometheus)\n    Tasks: 9 (limit: 4915)\n   CGroup: /system.slice/prometheus.service\n           `-29650 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\n```\n\nWhen you’re ready to move on, press _Q_ to quit the status command. Lastly, enable the service to start on boot.\n\n```\nsudo systemctl enable prometheus\n\n```\n\nNow that Prometheus is up and running, we can install an additional exporter to generate metrics about our server’s resources.\n\n## Step 5 — Downloading Node Exporter\n\nTo expand Prometheus beyond metrics about itself only, we’ll install an additional exporter called Node Exporter. Node Exporter provides detailed information about the system, including CPU, disk, and memory usage. Download the current stable version of Node Exporter into your home directory. You can find the latest binaries on [Prometheus download page.](https://prometheus.io/download/)\n\n```\nwget https://github.com/prometheus/node_exporter/releases/download/v1.0.1/node_exporter-1.0.1.linux-amd64.tar.gz\n\n```\nNow, unpack the downloaded archive.\n\n```\ntar xvf node_exporter-1.0.1.linux-amd64.tar.gz\n\n```\nThis will create a directory called _node_exporter-1.0.1.linux-amd64_ containing a binary file named _node_exporter_, a license, and a notice.\n\nCopy the binary to the _/usr/local/bin_ directory and set the user and group ownership to the node_exporter user that you created in Step 1.\n\n```\nsudo cp node_exporter-1.0.1.linux-amd64/node_exporter /usr/local/bin\nsudo chown node_exporter:node_exporter /usr/local/bin/node_exporter\n\n```\nNow that you’ve installed Node Exporter, let’s test it out by running it before creating a service file for it so that it starts on boot.\n\n## Step 6 — Running Node Exporter\n\nThe steps for running Node Exporter are similar to those for running Prometheus itself. Start by creating the Systemd service file for Node Exporter.\n\n```\nsudo nano /etc/systemd/system/node_exporter.service\n\n```\nCopy the following content into the service file:\n\n```\n[Unit]\nDescription=Node Exporter\nWants=network-online.target\nAfter=network-online.target\n\n[Service]\nUser=node_exporter\nGroup=node_exporter\nType=simple\nExecStart=/usr/local/bin/node_exporter --collector.systemd\n\n[Install]\nWantedBy=multi-user.target\n```\n\nSave the file and close your text editor. Finally, reload systemd to use the newly created service.\n\n```\nsudo systemctl daemon-reload\n\n```\nYou can now run Node Exporter using the following command:\n\n```\nsudo systemctl start node_exporter\n\n```\nVerify that Node Exporter’s running correctly with the status command.\n\n```\nsudo systemctl status node_exporter\n\n```\nLike before, this output tells you Node Exporter’s status, main process identifier (PID), memory usage, and more. If the service’s status isn’t active, follow the on-screen messages and re-trace the preceding steps to resolve the problem before continuing.\n\n```\n_Output_\n* node_exporter.service - Node Exporter\n   Loaded: loaded (/etc/systemd/system/node_exporter.service; enabled; vendor preset: enabled)\n   Active: active (running) since Mon 2020-09-14 17:58:25 CEST; 1 day 1h ago\n Main PID: 29612 (node_exporter)\n    Tasks: 7 (limit: 4915)\n   CGroup: /system.slice/node_exporter.service\n           `-29612 /usr/local/bin/node_exporter --collector.systemd\n```\nLastly, enable Node Exporter to start on boot.\n\n```\nsudo systemctl enable node_exporter\n\n```\nWith Node Exporter fully configured and running as expected, we’ll tell Prometheus to start scraping the new metrics.\n\n## Step 7 — Configuring Prometheus to Scrape Node Exporter\n\nBecause Prometheus only scrapes exporters which are defined in the scrape_configs portion of its configuration file, we’ll need to add an entry for Node Exporter, just like we did for Prometheus itself. Open the configuration file.\n\n```\nsudo nano /etc/prometheus/prometheus.yml\n\n```\nAt the end of the scrape_configs block, add a new entry called node_exporter.\n\n```\n...\n  - job_name: 'node_exporter'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9100']\n```\nBecause this exporter is also running on the same server as Prometheus itself, we can use localhost instead of an IP address again along with Node Exporter’s default port, 9100. Your whole configuration file should look like this:\n\n```\nglobal:\n  scrape_interval: 15s\n\nscrape_configs:\n  - job_name: 'prometheus'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9090']\n  - job_name: 'node_exporter'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9100']\n```\nSave the file and exit your text editor when you’re ready to continue. Finally, restart Prometheus to put the changes into effect.\n\n```\nsudo systemctl restart prometheus\n\n```\nOnce again, verify that everything is running correctly with the status command.\n\n```\nsudo systemctl status prometheus\n\n```\nIf the service’s status isn’t set to active, follow the on screen instructions and re-trace your previous steps before moving on.\n\n```\nOutput\n* prometheus.service - Prometheus\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\n   Active: active (running) since Tue 2020-09-15 19:06:56 CEST; 2s ago\n Main PID: 19725 (prometheus)\n    Tasks: 8 (limit: 4915)\n   CGroup: /system.slice/prometheus.service\n           `-19725 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\n```\n\nWe now have Prometheus and Node Exporter installed, configured, and running.\n\n## Step 8 - Adding Robonomic build in node_exporter\n\nAfter successfully installed Prometheus and node_exporter we will have to use build in prometheus exporter in every substrate project. To make this happen we have to add additional entry to _/etc/prometheus/prometheus.yml_. \nOpen the configuration file.\n\n```\nsudo nano /etc/prometheus/prometheus.yml\n\n```\nAt the end of the scrape_configs block, add a new entry called robonomic_exporter.\n\n``` \n  - job_name: 'robonomics_exporter'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9615']\n```\nSave the file and exit your text editor. Your whole configuration file should look like this:\n\n```\nglobal:\n  scrape_interval: 15s\n\nscrape_configs:\n  - job_name: 'prometheus'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9090']\n  - job_name: 'node_exporter'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9100']\n  - job_name: 'robonomics_exporter'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9615']\n```\n\nFinally, restart Prometheus to put the changes into effect.\n\n```\nsudo systemctl restart prometheus\n\n```\nOnce again, verify that everything is running correctly with the status command.\n\n```\nsudo systemctl status prometheus\n\n```\nWe now have _Prometheus_ and _Node Exporter_ as well as _Robonomic Exporter_ installed, configured, and running. Now move on to Grafana\n\n## Step 9 - Setting up Grafana\n\nThe last step is to connect Prometheus as a Data Source in Grafana. For purpose of this tutorial we will use free cloud-based grafana which allow to have up to 5 dashboards as well as dedicated [Robonomics dashboard](https://grafana.com/grafana/dashboards/13015). Simply go to [grafana.com](https://grafana.com/) create new account and login to your newly created grafana instance.\n\nAt the beginning we must add to Grafana new _**Data Source**_ which in our case will be Prometheus server.\nGo to Data Source:\n\n>![DataSource](../images/prometheus-grafana/grafana-6-2020-09-15-19-18-50-Window.png)\n\nThen click **_Add data source_**\n\n>![DataSource](../images/prometheus-grafana/grafana-7-2020-09-15-19-18-50-Window.png)\n\nNext select _**Prometheus**_\n\n>![DataSource](../images/prometheus-grafana/grafana-8-2020-09-15-19-18-50-Window.png)\n\nIn new screen put your **_Prometheus server IP adress with 9090 port_**\n\n> ![DataSource](../images/prometheus-grafana/grafana-9-2020-09-15-19-18-50-Window.png)\n\nAfter that _**Save & Test**_ if you did all steps you should be green and ready to go for importing dashboard. On the main site click to **+** and then **Import** as shown on the pic below:\n\n> ![Import dashboard](../images/prometheus-grafana/grafana-1-2020-09-15-19-18-50-Window.png)\n\nThen you should see Import page:\n\n> ![Import page](../images/prometheus-grafana/grafana-2-2020-09-15-19-18-50-Window.png)\n\nIn the _Grafana.com dashboard url or id_ write _**13015**_ (as this is ID of the Robonomic dashboard)\n\n> ![Import Robonomic dashboard](../images/prometheus-grafana/grafana-3-2020-09-15-19-18-50-Window.png)\n\nAfter loading external dashboard you will get this screen:\n\n> ![XRT 13015 dashboard import](../images/prometheus-grafana/grafana-4-2020-09-15-19-18-50-Window.png)\n\nThe last step is to choose previously created **_Data Source_** and click _**Import**_\n\n> ![Prometheus as a DataSource](../images/prometheus-grafana/grafana-5-2020-09-15-19-18-50-Window.png)\n\nTHAT'S IT ! At this point you should see imported dashboard. \n\n\n## References\n\n* [How To Install Prometheus on Ubuntu 16.04](https://www.digitalocean.com/community/tutorials/how-to-install-prometheus-on-ubuntu-16-04)\n* [Build A Monitoring Dashboard by Prometheus + Grafana](https://medium.com/htc-research-engineering-blog/build-a-monitoring-dashboard-by-prometheus-grafana-741a7d949ec2)\n* [Grafana support for Prometheus](https://prometheus.io/docs/visualization/grafana/)\n* [Monitoring Linux host metrics with the node exporter](https://prometheus.io/docs/guides/node-exporter/)\n* [Querying Prometheus](https://prometheus.io/docs/prometheus/latest/querying/basics/)\n* [Visualizing Node Metrics](https://substrate.dev/docs/en/tutorials/visualize-node-metrics/)\n* [Substrate Prometheus Exporter](https://github.com/paritytech/substrate/tree/master/utils/prometheus)\n* [polkadot-dashboard](https://github.com/w3f/polkadot-dashboard)\n* [Polkadot node metric](https://grafana.com/grafana/dashboards/12425)\n* [Node Exporter for Prometheus Dashboard](https://grafana.com/grafana/dashboards/11074)\n* [Grafana ROBONOMICS (XRT) Metrics](https://grafana.com/grafana/dashboards/13015)\n\n"}},{node:{id:"d387a8898ca613aebd4a505af12d2eaa",title:"Robonomics Liability",path:"/docs/ru/robonomics-liability/",content:'\nThe package is responsible for receiving `New Liability` events (`listener` node) and playing topics from `objective` field (`executor` node).\nThe launch file also include `ipfs_channel` node and `signer` node.\n\n## ROS Parameters\n\n### ~web3_http_provider\n\nWeb3 HTTP provider address. The type is `string`, defaults to `http://127.0.0.1:8545`\n\n### ~web3_ws_provider\n\nWeb3 WebSocket provider address. The type is `string`, defaults to `ws://127.0.0.1:8546`\n\n### ~ipfs_http_provider\n\nIPFS HTTP provider address. The type is `string`, defaults to `http://127.0.0.1:5001`\n\n### ~ipfs_swarm_connect_addresses\n\nIPFS nodes to connect to. The type is `string`, defaults to `""`\n\n### ~ipfs_public_providers\n\nA public IPFS node to pin result files. The type is `string`, defaults to `""`\n\n### ~factory_contract\n\nThe name of the liability factory. The type is `string`, defaults to `factory.5.robonomics.eth`\n\n### ~lighthouse_contract\n\nThe name of a lighthouse you are working on. The type is `string`, defaults to `airalab.lighthouse.5.robonomics.eth`\n\n### ~enable_executor\n\nEnable or disable executor node. If it\'s `false`, no topics from objective would be published. The type is `boolean`, defaults to `true`\n\n### ~master_check_interval\n\nPeriod (in seconds) to check master for new topic publications. It\'s necessary for the Recorder, which records all the topics a CPS publishes. The type is `double`, defaults to `0.1`\n\n### ~recording_topics\n\nList of topics name separated by comma. It allows you to specify which topics would be recorded. The type is `string`, defaults to `""`\n\n### ~ens_contract\n\nThe checksumed address of ENS registry. The type is `string`, defaults to `""`\n\n### ~keyfile\n\nPath to keyfile. The type is `string`, defaults to `""`. **Required parameter**\n\n### ~keyfile_password_file\n\nPath to a file with password for the keyfile. The type is `string`, defaults to `""`. **Required parameter**\n\n## Subscribed topics\n\n### /liability/infochan/eth/signing/demand (robonomics_msgs/Demand)\n\n[robonomics_msgs/Demand](/docs/market-messages#demand) message to sign and send further to IPFS channel\n\n### /liability/infochan/eth/signing/offer (robonomics_msgs/Offer)\n\n[robonomics_msgs/Offer](/docs/market-messages#offer) message to sign and send further to IPFS channel\n\n### /liability/infochan/eth/signing/result (robonomics_msgs/Result)\n\n[robonomics_msgs/Result](/docs/market-messages#result) message to sign and send further to IPFS channel\n\n\n## Published topics\n\n### /liability/infochan/incoming/demand (robonomics_msgs/Demand)\n\nContains a [robonomics_msgs/Demand](/docs/market-messages#demand) message which was read from IPFS channel\n\n### /liability/infochan/incoming/offer (robonomics_msgs/Offer)\n\nContains a [robonomics_msgs/Offer](/docs/market-messages#offer) message which was read from IPFS channel\n\n### /liability/infochan/incoming/result (robonomics_msgs/Result)\n\nContains a [robonomics_msgs/Result](/docs/market-messages#result) message which was read from IPFS channel\n\n### /liability/incoming (robonomics_liability/Liability)\n\nContains all the information about the last created [robonomics_liability/Liability](/docs/robonomics-liability-messages#robonomics_liabilityliabilitymsg)\n\n### /liability/ready (robonomics_liability/Liability)\n\nSignals when a [robonomics_liability/Liability](/docs/robonomics-liability-messages#robonomics_liabilityliabilitymsg)is ready for execution\n\n### /liability/complete (robonomics_liability/Liability)\n\nSignals when a [robonomics_liability/Liability](/docs/robonomics-liability-messages#robonomics_liabilityliabilitymsg) has done its job\n\n### /liability/finalized (std_msgs/String)\n\nSignals when a liability has been finalized\n\n## Services\n\n### /liability/start (robonomics_liability/StartLiability)\n\nThe service tells executor to play topics from the objective. It\'s required to pass a liability address ([robonomics_liability/StartLiability](/docs/robonomics-liability-messages#robonomics_liabilitystartliabilitysrv)), which you can get from `/liability/ready` topic\n\n### /liability/finish (robonomics_liability/FinishLiability)\n\nCPS should call the service after performing the task. The input is [robonomics_liability/FinishLiability](/docs/robonomics-liability-messages#robonomics_liabilityfinishiabilitysrv)\n\n### /liability/restart (robonomics_liability/StartLiability)\n\nThe service allows to restart a liability after the system shutdown. The input is [robonomics_liability/StartLiability](/docs/robonomics-liability-messages#robonomics_liabilitystartliabilitysrv)\n\n### /liability/resume (robonomics_liability/StartLiability)\n\nThe service allows to resume a liability from the last timestamp available in the persistence store. The input is [robonomics_liability/StartLiability](/docs/robonomics-liability-messages#robonomics_liabilitystartliabilitysrv)\n\n### /liability/read (robonomics_liability/ReadLiability)\n\nThe service returns all the data about a liability by its address. The input is [robonomics_liability/ReadLiability](/docs/robonomics-liability-messages#robonomics_liabilityreadliabilitysrv)\n'}},{node:{id:"6672b366b26214aab25ab0f021ed72da",title:"Robonomics Liability Messages",path:"/docs/ru/robonomics-liability-messages/",content:"\n## robonomics_liability/Liability.msg\n\n| Field        \t| Type                                                                         \t| Description                                    \t|\n|--------------\t|------------------------------------------------------------------------------\t|------------------------------------------------\t|\n| address      \t| [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) \t| The Liability’s address                        \t|\n| model        \t| [ipfs_commom/Multihash](/docs/ipfs-common-messages#ipfs_commonmultihashmsg)         \t| CPS behavioral model Identifier                \t|\n| objective    \t| [ipfs_commom/Multihash](/docs/ipfs-common-messages#ipfs_commonmultihashmsg)         \t| CPS behavioral model parameters in rosbag file \t|\n| result       \t| [ipfs_commom/Multihash](/docs/ipfs-common-messages#ipfs_commonmultihashmsg)         \t| Liability result hash                          \t|\n| promisee     \t| [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) \t| The promisee address                           \t|\n| promisor     \t| [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) \t| The promisor address (usually CPS)             \t|\n| lighthouse   \t| [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) \t| The address of lighthouse your CPS works on    \t|\n| token        \t| [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) \t| Operational token address                      \t|\n| cost         \t| [ethereum_commom/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg) \t| CPS behavioral model implementation cost       \t|\n| validator    \t| [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) \t| Observing network address                      \t|\n| validatorFee \t| [ethereum_commom/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg) \t| Observing network commission                   \t|\n\n## robonomics_liability/StartLiability.srv\n\n**Request**\n\n| Field     | Type              | Description                                           |\n|---------  |-----------------  |-----------------------------------------------------  |\n| address   | std_msgs/String   | The address of Liability you are willing to execute   |\n\n**Response**\n\n| Field     | Type              | Description                               |\n|---------  |-----------------  |------------------------------------------ |\n| success   | std_msgs/Bool     | Weather or not the Liability was started  |\n| msg       | std_msgs/String   | Status of launch                          |\n\n## robonomics_liability/FinishLiability.srv\n\n**Request**\n\n| Field     | Type              | Description                           |\n|---------  |-----------------  |------------------------------------   |\n| address   | std_msgs/String   | The address of Liability to finish    |\n| success   | std_msgs/Bool     | The status of execution               |\n\n**Response**\n\nThe response is empty\n\n## robonomics_liability/ReadLiability.srv\n\n**Request**\n\n| Field     | Type                                                                          | Description                   |\n|---------  |------------------------------------------------------------------------------ |----------------------------   |\n| address   | [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg)  | The address of a liability    |\n\n**Response**\n\n| Field         | Type                                                                  | Description           |\n|-----------    |---------------------------------------------------------------------  |---------------------  |\n| read          | std_msgs/Bool                                                         | Status of execution   |\n| liability     | [robonomics_liability/Liability](#robonomics_liabilityliabilitymsg)   | Liability             |\n"}},{node:{id:"565fea83eab6b4ceb2728e5152d37406",title:"Robonomics-js",path:"/docs/ru/robonomics-js/",content:"\n[Robonomics-js](https://github.com/airalab/robonomics-js) is a simple Javascript library for working with Robonomics Network.\n\n## Installation\n\n```\nnpm install robonomics-js --save\n```\n\nor\n\n```\nyarn add robonomics-js\n```\n\n### Dependencies \n\n* [Web3](https://github.com/ethereum/web3.js/) version 1.2.4\n* [Ipfs](https://github.com/ipfs/js-ipfs) version 0.34.0\n\n\n## Usage \n\nCreates a Robonomics instance\n\n```JavaScript\nconst options = {...};\nconst robonomics = new Robonomics(options);\n```\n\n### options\n\nThe object of properties:\n\n```\noptions.web3\n```\n\nAn instance of [web3.js](https://github.com/ethereum/web3.js/):\n\n```JavaScript\n// metamask\nconst options = {\n  web3: new Web3(window.ethereum),\n  ...\n};\n\n// infura\nconst options = {\n  web3: new Web3(\n    new Web3.providers.WebsocketProvider(\n      \"wss://mainnet.infura.io/ws/v3/0b2f2a5026264b57b6d698b480332e89\"\n    )\n  ),\n  ...\n};\n```\n\n```\noptions.messageProvider\n```\n\nThis is an instance of MessageProviderIpfs which uses a [js-ipfs](https://github.com/ipfs/js-ipfs) node with pubsub support\n\n```JavaScript\nconst ipfs = new Ipfs({\n  repo: 'robonomics-example',\n  relay: {\n    enabled: true,\n    hop: {\n      enabled: true\n    }\n  },\n  EXPERIMENTAL: {\n    pubsub: true\n  },\n  config: {\n    Addresses: {\n      Swarm: [\n        '/dns4/ws-star.discovery.libp2p.io/tcp/443/wss/p2p-websocket-star',\n        '/dns4/1.wsstar.aira.life/tcp/443/wss/p2p-websocket-star/',\n        '/dns4/2.wsstar.aira.life/tcp/443/wss/p2p-websocket-star/',\n        '/dns4/3.wsstar.aira.life/tcp/443/wss/p2p-websocket-star/'\n      ]\n    },\n    Bootstrap: [\n      '/dns4/ams-1.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLer265NRgSp2LA3dPaeykiS1J6DifTC88f5uVQKNAd',\n      '/dns4/lon-1.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLMeWqB7YGVLJN3pNLQpmmEk35v6wYtsMGLzSr5QBU3',\n      '/dns4/nyc-1.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLueR4xBeUbY9WZ9xGUUxunbKWcrNFTDAadQJmocnWm',\n      '/dns4/nyc-2.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLV4Bbm51jM9C4gDYZQ9Cy3U6aXMJDAbzgu2fzaDs64',\n      '/dns4/node0.preload.ipfs.io/tcp/443/wss/ipfs/QmZMxNdpMkewiVZLMRxaNxUeZpDUb34pWjZ1kZvsd16Zic',\n      '/dns4/node1.preload.ipfs.io/tcp/443/wss/ipfs/Qmbut9Ywz9YEDrz8ySBSgWyJk41Uvm2QJPhwDJzJyGFsD6',\n      '/dns4/1.pubsub.aira.life/tcp/443/wss/ipfs/QmdfQmbmXt6sqjZyowxPUsmvBsgSGQjm4VXrV7WGy62dv8',\n      '/dns4/2.pubsub.aira.life/tcp/443/wss/ipfs/QmPTFt7GJ2MfDuVYwJJTULr6EnsQtGVp8ahYn9NSyoxmd9',\n      '/dns4/3.pubsub.aira.life/tcp/443/wss/ipfs/QmWZSKTEQQ985mnNzMqhGCrwQ1aTA6sxVsorsycQz9cQrw'\n    ]\n  }\n})\n\nconst options = {\n  messageProvider: new MessageProviderIpfs(ipfs),\n  ...\n};\n```\n\n```\noptions.account\n```\n\nThis is an account object which will be used to sign messages. It's necessary to specify either account address (that one must be unlocked) or a private key (the address will be recovered from the given private key).\n\nOption `isSignPrefix` tells whether or not a prefix must be appended. Default is `true`.\n\n```JavaScript\nconst options = {\n  account: {\n    address: '0x0000000000000000000000000000000000000000',\n    privateKey: '0x0000000000000000000000000000000000000000000000000000',\n    isSignPrefix: true\n  },\n  ...\n};\n```\n\n```\noptions.ens\n```\n\nThis is a `ens` contract object. This one is not required. If it's necessary you may specify `address` of the contract if the network is not set to mainnet. `suffix` may be `sid` for sidechain or `eth` for mainnet. `eth` is default. `version` is the version of Robonomics Network. Default is the latest deployed version.\n\n```JavaScript\nconst options = {\n  ens: {\n    address: '0x314159265dD8dbb310642f98f50C066173C1259b',\n    suffix: 'eth',\n    version: 5\n  },\n  ...\n};\n```\n\n```\noptions.lighthouse\n```\n\nENS name of a lighthouse, not required. Default is `airalab.lighthouse.5.robonomics.eth`. It's possible to specify only the first part of the name, like `airalab`.\n\n```JavaScript\nconst options = {\n  lighthouse: 'airalab.lighthouse.5.robonomics.eth',\n  ...\n};\n```\n\nIt's necessary to wait until full initialization\n\n```JavaScript\nconst options = {...};\nconst robonomics = new Robonomics(options);\nrobonomics.ready().then(() => {\n  console.log('Robonomics instance ready')\n})\n```\n\n## API\n\n### Messages\n\n#### Demand \n\nThe message specification\n\n```JavaScript\nconst demand = {\n  // REQUIRED\n  model: \"QmSt69qQqGka1qwRRHbdmAWk4nCbsV1mqJwd8cWbEyhf1M\",      // ipfs hash of the model \n  objective: \"QmSt69qQqGka1qwRRHbdmAWk4nCbsV1mqJwd8cWbEyhf2M\",  // ipfs hash of the objective\n  token: robonomics.xrt.address,                                // payment token address\n  cost: 1,                                                      // cost\n  deadline: 9999999,                                            // until which block demand is valid\n\n  // NOT REQUIRED \n  lighthouse: \"0x0000000000000000000000000000000000000000\",     // lighthouse address, by default the initialization address\n  validator: \"0x0000000000000000000000000000000000000000\",      // validator address if necessary\n  validatorFee: 0,                                              // validator fee \n  nonce: 1                                                      // index number \n};\n```\n\n`robonomics.sendDemand`\n\nSigning and broadcasting the demand message. A liability is returned as promise\n\n```JavaScript\nrobonomics.sendDemand(demand).then(liability => {\n  console.log(liability.address);\n});\n```\n\n`robonomics.onDemand`\n\nListens to demand messages with a defined model. If model is `null` returns any demand message.\n\n```JavaScript\nrobonomics.onDemand(model, message => {\n  console.log(message);\n});\n```\n\n#### Offer \n\nThe message specification\n\n```JavaScript\nconst offer = {\n  // REQUIRED \n  model: \"QmSt69qQqGka1qwRRHbdmAWk4nCbsV1mqJwd8cWbEyhf1M\",      // ipfs hash of the model \n  objective: \"QmSt69qQqGka1qwRRHbdmAWk4nCbsV1mqJwd8cWbEyhf2M\",  // ipfs hash of the objective\n  token: robonomics.xrt.address,                                // payment token address\n  cost: 1,                                                      // cost \n  deadline: 9999999,                                            // until which block demand is valid\n\n  // NOT REQUIRED\n  lighthouse: \"0x0000000000000000000000000000000000000000\",     // lighthouse address, by default the initialization address\n  lighthouseFee: 0,                                             // lighthouse fee\n  validator: \"0x0000000000000000000000000000000000000000\",      // validator address if necessary\n  nonce: 1                                                      // index number \n};\n```\n\n`robonomics.sendOffer`\n\nSigns and broadcasts an offer message. A liability is returned as promise\n\n```JavaScript\nrobonomics.sendOffer(offer).then(liability => {\n  console.log(liability.address);\n});\n```\n\n`robonomics.onOffer`\n\nListens to offer messages with a defined model. If model is `null` returns any offer message\n\n```JavaScript\nrobonomics.onOffer(model, message => {\n  console.log(message);\n});\n```\n\n#### Result \n\nThe message specification\n\n```JavaScript\nconst result = {\n  // REQUIRED \n  liability: \"0x0000000000000000000000000000000000000000\",  // liability contract address\n  success: true,                                            // status of the task\n  result: \"QmWXk8D1Fh5XFJvBodcWbwgyw9htjc6FJg8qi1YYEoPnrg\"  // ipfs hash of the rosbag log file\n};\n```\n\n`robonomics.sendResult`\n\nSigns and broadcasts a result message\n\n```JavaScript\nrobonomics.sendResult(result).then(() => {\n  console.log(\"ok\");\n});\n```\n\n`robonomics.onResult`\n\nListens to result messages. These results may be not valid. Valid results are stored in a liability contract\n\n```JavaScript\nrobonomics.onResult(result => {\n  console.log(result);\n});\n```\n\n### Smart Contracts \n\n#### Liability \n\n`liability.getInfo`\n\nReturn a property object of the contract\n\n```JavaScript\nliability.getInfo().then(data => {\n  console.log(data);\n  /*\n  {\n    model,\n    objective,\n    result,\n    token,\n    cost,\n    lighthouseFee,\n    validatorFee,\n    demandHash,\n    offerHash,\n    promisor,\n    promisee,\n    lighthouse,\n    validator,\n    isSuccess,\n    isFinalized\n  }\n  */\n});\n```\n\n`liability.onResult`\n\nWaits until a liability is finished. Returns a result\n\n```JavaScript\nliability.onResult().then(result => {\n  console.log(result);\n});\n```\n\n#### Lighthouse \n\n`robonomics.lighthouse.getInfo`\n\nReturns a property object of the contract\n\n```JavaScript\nrobonomics.lighthouse.getInfo().then(data => {\n  console.log(data);\n  /*\n  {\n    minimalStake,\n    timeoutInBlocks,\n    keepAliveBlock,\n    marker,\n    quota\n  }\n  */\n});\n```\n\n`robonomics.lighthouse.getProviders`\n\nReturns a list of providers on the lighthouse\n\n```JavaScript\nrobonomics.lighthouse.getProviders().then(list => {\n  console.log(list);\n});\n```\n\n##### Creation of a new lighthouse\n\n```JavaScript\nconst minimalFreeze = 1000      // Wn\nconst timeout = 25              // blocks\nconst name = 'mylighthouse'     // lighthouse name\nrobonomics.factory.methods.createLighthouse(minimalFreeze, timeout, name).send({ from: robonomics.account.address })\n    .then((tx) => console.log(tx))\n\nrobonomics.factory.onLighthouse((lighthouse) => {\n    console.log(lighthouse.name)\n})\n```\n\n##### Become a provider \n\nPreliminarily you must call `approve` for the tokens `XRT`\n\n```JavaScript\nconst name = \"mylighthouse\";    // lighthouse name\nconst stake = 1000;             // Wn\nrobonomics.lighthouse.methods\n  .refill(stake)\n  .send({ from: robonomics.account.address })\n  .then(tx => console.log(tx));\n```\n\n#### Token \n\n`robonomics.xrt.getInfo`\n\nReturns property object of the token\n\n```JavaScript\nrobonomics.xrt.getInfo().then(data => {\n  console.log(data);\n  /*\n  {\n    name,\n    totalSupply,\n    decimals,\n    symbol\n  }\n  */\n});\n```\n\n##### Check balance \n\n```JavaScript\nrobonomics.xrt.methods\n  .balanceOf(robonomics.account.address)\n  .call()\n  .then(balance => console.log(balance));\n```\n\n##### Check allowance \n\n```JavaScript\nrobonomics.xrt.methods\n  .allowance(robonomics.account.address, robonomics.factory.address)\n  .call()\n  .then(allowance => console.log(allowance));\n```\n\n##### Approve \n\n```JavaScript\nrobonomics.xrt.methods\n  .approve(robonomics.lighthouse.address, 100)\n  .send({\n    from: robonomics.account.address\n  })\n  .then(tx => console.log(tx));\n```\n\n## Links \n\n- [Website](https://robonomics.network/)\n- [Minimal template of dApp](https://github.com/airalab/vue-dapp-robonomics-template)\n- [dApp example](https://codesandbox.io/s/robonomics-vue-template-ewuiw)\n"}},{node:{id:"99ab44fc12312cb6e32aa1fa1a255b5a",title:"How Robonomics Network Works",path:"/docs/ru/robonomics-how-it-works/",content:'\nIn this section we will discuss the Robonomics Network scenario.\n\nThere are few main parts in the Robonomics network:\n\n- IPFS for the messages exchanging\n- the Ethereum blockchain for storing new liability contracts\n- a provider that is responsible for matching messages\n- an agent\n\nLet\'s have a look at the following diagram that describes the scenario without any additional details:\n\n![The main scenario of Robonomics Network](../images/robonomics_network_scenario.jpg "The main scenario of Robonomics Network")\n\nThere are three types of [messages](/docs/market-messages) in IPFS: Demand, Offer, Result.\n\n**Below there is the specification for a Demand message:**\n\n| Field         | Type                      | Description                                       | Example                                           |\n|-------------- |-------------------------  |------------------------------------------------   |------------------------------------------------   |\n| model         | [ipfs_common/Multihash](/docs/robonomics-liability-messages#ipfs_commonmultihashmsg)     | CPS behavioral model Identifier                   | QmfXHZ2YkNC5vRjp1oAaRoDHD8H3zZznfhBPasTu348eWC    |\n| objective     | [ipfs_common/Multihash](/docs/robonomics-liability-messages#ipfs_commonmultihashmsg)     | CPS behavioral model parameters in rosbag file    | QmUo3vvSXZPQaQWjb3cH3qQo1hc8vAUqNnqbdVABbSLb6r    |\n| token         | ethereum_common/Address   | Operational token address                         | 0xbD949595eE52346c225a19724084cE517B2cB735        |\n| cost          | ethereum_common/UInt256   | CPS behavioral model implementation cost          | 1                                                 |\n| lighthouse    | ethereum_common/Address   | Lighthouse address                                | 0xa1b60ED40E5A68184b3ce4f7bEf31521A57eD2dB1       |\n| validator     | ethereum_common/Address   | Observing network address                         | 0x0000000000000000000000000000000000000000        |\n| validatorFee  | ethereum_common/UInt256   | Observing network commission                      | 0                                                 |\n| deadline      | ethereum_common/UInt256   | Deadline block number                             | 6393332                                           |\n| sender        | ethereum_common/Address   | Message sender address                            | 0x0000000000000000000000000000000000000000        |\n| signature     | std_msgs/UInt8[]          | Sender’s digital signature                        | 0x23bc…c617                                       |\n\n\x3c!--\n=============== ============================================================== ================================================ ================================================\n     Field                                   Type                                                Description                                        Example\n=============== ============================================================== ================================================ ================================================\n  model          :ref:`ipfs_common/Multihash <IPFS-Common-Multihash.msg>`       CPS behavioral model Identifier                  QmfXHZ2YkNC5vRjp1oAaRoDHD8H3zZznfhBPasTu348eWC\n  objective      :ref:`ipfs_common/Multihash <IPFS-Common-Multihash.msg>`       CPS behavioral model parameters in rosbag file   QmUo3vvSXZPQaQWjb3cH3qQo1hc8vAUqNnqbdVABbSLb6r\n  token          :ref:`ethereum_common/Address <Ethereum-common-Address.msg>`   Operational token address                        0xbD949595eE52346c225a19724084cE517B2cB735\n  cost           :ref:`ethereum_common/UInt256 <Ethereum-common-UInt256.msg>`   CPS behavioral model implementation cost         1\n  lighthouse     :ref:`ethereum_common/Address <Ethereum-common-Address.msg>`   Lighthouse address                               0xa1b60ED40E5A68184b3ce4f7bEf31521A57eD2dB1\n  validator      :ref:`ethereum_common/Address <Ethereum-common-Address.msg>`   Observing network address                        0x0000000000000000000000000000000000000000\n  validatorFee   :ref:`ethereum_common/UInt256 <Ethereum-common-UInt256.msg>`   Observing network commission                     0\n  deadline       :ref:`ethereum_common/UInt256 <Ethereum-common-UInt256.msg>`   Deadline block number                            6393332\n  sender         :ref:`ethereum_common/Address <Ethereum-common-Address.msg>`   Message sender address                           0x0000000000000000000000000000000000000000\n  signature      std_msgs/UInt8[]                                               Sender\'s digital signature                       0x23bc...c617\n=============== ============================================================== ================================================ ================================================\n--\x3e\n\nAn Offer message has the same fields but instead of `validatorFee` there is a `lighthouseFee` field. This field determines the amount of fee for a lighthouse.\n\nNow let\'s have a look at the following diagram and walk step by step from the moment of publishing messages to a liability finalization.\n\n![Robonomics Network detailed scenario](../images/robonomics_network_detailed_scenario.jpg "Robonomics Network detailed scenario")\n\nA liability contract is created only if the following fields match: `model`, `objective`, `token`, `cost`. A provider of Robonomics Network watches every message and finds those ones that have a match.\nAfter the match is found the provider calls `createLiability(demand, offer)` method from the contract factory where `demand` and `offer` are serialized.\n\nBelow is the package diagram for the Robonomics communication stack:\n\n![Robonomics communication stack](../images/robonomics_network_communication_stack.jpg "Robonomics communication stack")\n\nThe factory deserializes arguments and recovers *promisee* and *promisor* addresses from signatures.\n\nNext step is token transfer. The factory transfers **cost** tokens from the *promisee* address and **validatorFee** and **lighthouseFee** from the *promisor* address to the new liability address.\n\n> - **You should approve sufficient amount of tokens for the factory.**\n> - **It\'s not required to approve tokens from the *promisor* address if fees are null.**\n\nNow the factory emits a NewLiability event with the liability address. An agent gets the address, reads fields, perform a task and at the same time writes a log file in rosbag format.\n\nWhen the work is done the agent sends a Result message with the following fields: hash of the rosbag file, a success flag, a signature. If the **validator** field is not null it means that only validator is able to finalize the liability.\n\nAfter the successful liability finalization the agent gets **cost** tokens. Otherwise, the *promisee* gets tokens back.'}},{node:{id:"4a105098aac2c860e939c4947da9cb10",title:"Robonomics DApp Overview",path:"/docs/ru/robonomics-dapp-overview/",content:"\nYou can operate with Robonomics Network using the interface of [Robonomics Network Dapp (decentralized application)](https://dapp.robonomics.network/#/). It is available in browsers with [Metamask extension](https://metamask.io). On the first page you will see the statistics of the network:\n\n![Robonomics DApp's first page](../images/robonomics_dapp_first_page.jpg \"Robonomics DApp's first page\")\n\nLet's have a look at the bottom table \"Robonomics Telemetry\".\n\nEvery time an instance of AIRA is launched it broadcasts a piece of information about itself. Usually it takes some time for the Dapp to receive data from an instance of AIRA.\n\nHave a brief look at the page [\"AIRA installation\"](/docs/aira-installation) to understand where `IPNS` and `Address Eth` came from.\n\n## IPNS\n\nYou can treat it as a unique identifier of your instance in IPFS network. Under that name AIRA publishes metadata about itself.\n\n## Address Eth\n\nBy default AIRA generates new Ethereum address for you (it's [possible](/docs/aira-faq#how-to-change-ethereum-address-of-aira) to generate new one).\n\nIt's mainly used to sign all the outcoming messages.\n\n## Lighthouse\n\nIn Robonomics Network an agent must choose a lighthouse to work on. By default it's `airalab.lighthouse.5.robonomics.eth`.\n\nYou can choose existing one or create your own on [Lighthouses](https://dapp.robonomics.network/#/lighthouse) page.\n\n## Peers\n\nThe amount of IPFS pubsub [peers](/docs/aira-faq#how-to-check-the-quantity-of-ipfs-peers).\n\n## Date\n\nThe date and time of last update\n\n## Network\n\nRobonomics Network officially works in Ethereum Mainnet.\nThere is also [Sidechain](https://github.com/airalab/airalab-sidechain) which is mostly for testing purpose.\n\n\n"}},{node:{id:"017e7ff4697e29e302b39ccb172f7a00",title:"Contracts deployment",path:"/docs/ru/robonomics-contracts-deployment/",content:"\nRobonomics network works on top of the existing Ethereum network. The protocol is implemented by smart contracts. A source code is on [Github](https://github.com/airalab/robonomics_contracts). Airalab team deploys new version of contracts and supports a current one. \n\nIn this lesson we are going to learn more about these contracts. To do this we will deploy our test copy. Also we are going to use these contracts in the future lessons. \n\nYou need a client running Ethereum node. You can use either one of existing network (e.g. Mainnet, Ropsten, Kovan) or your local one. For testing purpose we suggest to use this [docker container](https://github.com/f-o-a-m/cliquebait) \n\n    $ docker run --rm -d -p 9545:8545 -p 9546:8546 foamspace/cliquebait:latest\n\nNext step is obtain a copy of robonomics contracts source code:\n\n    $ git clone --recursive https://github.com/airalab/robonomics_contracts\n\nA file truffle.js contains available networks for migration. We will work with development network. When you are in `robonomics_contracts` directory install dependencies and run a migration:\n\n    npm install // to install dependencies\n    truffle migrate --network development\n\nIt's time to learn how to create a new lighthouse. For more information about Robonomics network and Lighthouse in particular read [white paper](http://static.robonomics.network/docs/book-the-economy-of-robots-1-2017/robonomics.network-book-the-economy-of-robots-1-2017-en.pdf). Briefly lighthouse o distributes the running time of providers. Every lighthouse serves its own broadcast channel. Ask and Bid messages come into this channel. XRT tokens are used as a payment. \n\nWhen XRT contracts was deployed some tokens were issued on our account. Let's check the balance:\n\n    $ truffle --network development console\n    > xrt = XRT.at(XRT.address)\n    > xrt.balanceOf(web3.eth.accounts[0])\n\nAnd that's how we create a lighthouse:\n\n    > factory = LiabilityFactory.at(LiabilityFactory.address)\n    > tx = factory.createLighthouse(1000, 10, \"test\")\n    > tx.then(x => {laddress = x.logs[0].args.lighthouse})\n    > l = LighthouseLib.at(laddress)\n\nInstead of deploying a lighthouse contract every time we need a new one, we ask a factory to do this job. A `l` variable contains lighthouse instance. The lighthouse should be able to spend our tokens. Let's make an approve and check everything went well:\n\n    > xrt.approve(l.address,1000)\n    > xrt.allowance(web3.eth.accounts[0],l.address)\n\nAnd a very important step is become a worker:\n\n    > l.refill(1000)\n\nEach worker has to put a stake. In this case it's 1000 Wn.\n\nBelow is a table of our addresses:\n\n| Contract          | Address                                       | ENS name                          |\n|------------------ |--------------------------------------------   |---------------------------------- |\n| ENSRegistry       | 0x80c77a7de64a15450bb8cf45ece4fbb7bae6fb49    |                                   |\n| XRT               | 0x673583a369eb3a830a5571208cf6eb7ce83987f8    | xrt.3.robonomics.eth              |\n| LiabilityFactory  | 0x1b3190e00c1903266862af1f31714d4b81ef59b2    | factory.3.robonomics.eth          |\n| Lighthouse        | 0xd2b78c032b6c8851a8b6cbf950caa02a77618d8e    | test.lighthouse.3.robonomics.eth  |\n"}},{node:{id:"519ea3a4dd6a86e66a7a68ca437d81a6",title:"Become a Provider",path:"/docs/ru/robonomics-become-a-provider/",content:'\nThis page describes how to create a lighthouse and become a provider in the Robonomics network.\n\n## Prepare an address\n\nFirst of all, an Ethereum address is required. You must have access to a private key of the address. In case you don\'t have one, below are steps to create an address via [Parity](https://www.parity.io/ethereum/).\n\n```\n$ sudo snap install parity\n$ parity.ethkey generate random\nsecret:  15abe71557c07b69537bbe4352ed10a057be89037c69d4b35556112519911539\npublic: 38b800bfd90d486c78c646da79bb94b9d038aca8aad221062ce1b148df7764bfef02f6b3cf931786b6997540b798ea226ae60bd201c222d8f702e408a1a5cbff\naddress: c531fa8f141493df3da264a864bdcbec19695b4c\n```\n\nThe `secret` field is a private key, you\'ll need it to run the provider client. Save it to a file:\n\n```\n$ echo \'0x15abe71557c07b69537bbe4352ed10a057be89037c69d4b35556112519911539\' > private.key\n```\n\nThe next step is to deposit some ethers and XRT tokens to the address which is held in the `address` field.\n\n## Create a lighthouse\n\nGo to the lighthouse [dapp](https://dapp.robonomics.network/#/lighthouse) and fill in a name in the right side:\n\n![The Right Side](../images/become_a_provider_1.jpg "The Right Side")\n\nClick on the `Create lighthouse and connect to the network` button and sign a transaction. After a while you should see:\n\n![Success of Creating a Lighthouse](../images/become_a_provider_2.jpg "Success of Creating a Lighthouse")\n\nNow it\'s time to put a stake. Select the new lighthouse and click `Connect to the network`:\n\n![Selecting the Lighthouse](../images/become_a_provider_3.jpg "Selecting the Lighthouse")\n\nOn this page in the `Provider` section click the `Approve` button, sign a transaction. When it\'s mined click the `Refill` button and do the same.\n\n## Install the client\n\nNow you need to install [robonomics-tools](https://github.com/airalab/robonomics-tools) at least 0.4.2 version. You can build from the source or do the following steps:\n\n**Make sure you have Nix and Stack installed:**\n    \n```\n$ curl -sSL https://get.haskellstack.org/ | sh\n$ curl https://nixos.org/nix/install | sh\n```\n\n* Setup Airalab binary cache at [https://aira.cachix.org](https://aira.cachix.org/)\n* Import Airalab channel:\n\n```\n$ nix-channel --add http://aira.life/channels/aira-unstable/ aira\n$ nix-channel --update\n```\n* Install from the binary cache:\n\n```\n$ nix-env -iA aira.robonomics-tools\n```\n* Run the client:\n\n```\n$ xrtd --lighthouse mobilerobotics.lighthouse.5.robonomics.eth --private $(cat private.key)\n```\n\n**Get familiar with the `xrtd` options via `xrtd --help`.**\n\n## Test the provider\n\nTo test your provider go again to the lighthouse [dapp](https://dapp.robonomics.network/#/lighthouse/) and connect to the just created lighthouse.\n\nAt the bottom you should see the `TEST LIGHTHOUSE` section.\n\nClick on the `Demand` button and then on the `Offer` one. You should see something similar to:\n\n![Demand and Offer messages](../images/provider_mobilerobotics_demand_offer.jpg "Demand and Offer messages")\n\nDon\'t forget to sign every message with the MetaMask extension.\n\nFinally you should see a new liability contract created:\n\n![Liability is created](../images/provider_mobilerobotics_liability.jpg "Liability is created")\n'}},{node:{id:"cff67e4359f9ff0d91a389f630be5e11",title:"Robonomics IO Overview",path:"/docs/ru/rio-overview/",content:"\nThe [crate](https://crates.robonomics.network/robonomics_io/index.html) provides a convenient way to interact with blockchain and includes a set of tools. The latest release can be found [here](https://github.com/airalab/robonomics/releases)\n\n```\n% ./robonomics io\nrobonomics-io 0.21.0\nRobonomics Framework I/O operations\n\nUSAGE:\n    robonomics io [FLAGS] [OPTIONS] <SUBCOMMAND>\n\nFLAGS:\n        --dev        Specify the development chain\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nOPTIONS:\n    -d, --base-path <PATH>        Specify custom base path\n        --chain <CHAIN_SPEC>      Specify the chain specification (one of dev, local, or staging)\n    -l, --log <LOG_PATTERN>...    Sets a custom logging filter. Syntax is <target>=<level>, e.g. -lsync=debug\n\nSUBCOMMANDS:\n    help     Prints this message or the help of the given subcommand(s)\n    read     Read information from device\n    write    Write information into device\n```\n\n## The Pipeline Philosophy \n\nThe tool is designed in order to be included in a pipeline chain of processes. From Unix user experience everyone is familiar with commands like:\n\n```\nps aux | grep robonomics\n```\n\nIt means standard output produced by the `ps` program becomes standard input for the `grep` program. \n\nThe `robonomics io` consists of several subcommands with reading, writing abilities or both. It treats everything as a virtual or physical device ([everything is a file](https://en.wikipedia.org/wiki/Everything_is_a_file))\n\n## Read Overview\n\nIn general `read` means it reads data from a device or a network and prints it in `stdout`.\n\nHow to use it for:\n\n* [ipfs](/docs/rio-ipfs)\n* [launch](/docs/rio-launch)\n\n```\n% ./robonomics io read\nrobonomics-io-read 0.4.0\nRead information from device\n\nUSAGE:\n    robonomics io read <SUBCOMMAND>\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nSUBCOMMANDS:\n    help      Prints this message or the help of the given subcommand(s)\n    ipfs      Download data from IPFS storage\n    launch    Robot launch request events\n    pubsub    Subscribe for broadcasing data\n    sds011    Nova SDS011 particle sensor\n```\n\n## Write Overview\n\nUsually it writes data to blockchain or publishes to pubsub channel. \n\nHow to use it for:\n\n* [datalog](/docs/rio-datalog)\n* [ipfs](/docs/rio-ipfs)\n* [launch](/docs/rio-launch)\n\n```\n% ./robonomics io write\nrobonomics-io-write 0.4.0\nWrite information into device\n\nUSAGE:\n    robonomics io write <SUBCOMMAND>\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nSUBCOMMANDS:\n    datalog    Data blockchainization subsystem command\n    help       Prints this message or the help of the given subcommand(s)\n    ipfs       Upload data into IPFS storage\n    launch     CPS launch subsystem command\n    pubsub     Broadcast data into PubSub topic\n```\n\n## Local Testnet\n\nFor testing purpose it's possible to run the development environment:\n\n```\n% ./robonomics --dev --rpc-cors all\n```\n\n`--rpc-cors all` allows the [Dapp](https://parachain.robonomics.network/) to be connected to local node. After launching the node, go to the dapp, click on Robonomics icon in the upper left corner, choose Development and put node's local address\n\n![Robonomics Dapp Connect to Local Node](../images/robonomics-dapp-connect-local.jpg \"Robonomics Dapp Connect to Local Node\")\n\nFinally click Switch and you should be connected to the local node. Check out Accounts tab. There you can create new accounts and transfer tokens.\n\n"}},{node:{id:"8383d42e69455b21c62fdd04606fe1f7",title:"Robonomics IO Launch",path:"/docs/ru/rio-launch/",content:'\nA simple way to turn on and off an IoT device or a robot. Basically sending "ON" will result in `true` state for a device, anything else will result in `false`.\n\nFor the examples the development network is used. Check [this](/docs/robonomics-test-network-manual/) out to set it up for yourself.\n\n## Requirements\n\n* `robonomics` [executable](https://github.com/airalab/robonomics/releases)\n* Accounts on parachain\n\nYou can find instructions on how to create an account [here](/docs/create-account-in-dapp)\n\n## Usage\n\nTo see the result of transaction first of all run `read` part:\n\n```\n% ./robonomics io read launch\n```\n\nNow let\'s turn a robot on:\n\n```\n% echo "ON" | ./robonomics io write launch -r 5CiPPseXPECbkjWCa6MnjNokrgYjMqmKndv2rSnekmSK2DjL -s 0xb046fc3c322e91e14a61ad4f08a3809ee0de7092e73aa9b3c2b642a0f476d4d6\n```\n\nThen you should see in the first terminal window:\n\n```\n% ./robonomics io read launch\n5H3iRnX16DH2sb2RLxMM8UhDZTvJjP84EhhKXv3sCiEDq6bH >> 5CiPPseXPECbkjWCa6MnjNokrgYjMqmKndv2rSnekmSK2DjL : true\n```\n\nLet\'s describe all the accounts and options above.\n\n* `-r 5CiPPseXPECbkjWCa6MnjNokrgYjMqmKndv2rSnekmSK2DjL` means robot\'s address\n* `-s 0xb046fc3c322e91e14a61ad4f08a3809ee0de7092e73aa9b3c2b642a0f476d4d6` private key of the account to launch from (must have tokens for a transaction)\n* `5H3iRnX16DH2sb2RLxMM8UhDZTvJjP84EhhKXv3sCiEDq6bH` address that launches a robot\n* `true` turn it on\n\nIf we pass anything else but "ON" the state becomes `false`\n\n## Remote\nIf your local node is configured differently from defaults or you have a remote node, it\'s possible to specify it with `--remote` option\n\n```\n% echo "ON" | ./robonomics io write launch -r 5CiPPseXPECbkjWCa6MnjNokrgYjMqmKndv2rSnekmSK2DjL -s 0xb046fc3c322e91e14a61ad4f08a3809ee0de7092e73aa9b3c2b642a0f476d4d6 --remote https://ipfs.infura.io:5001/\n```\n\nand\n\n```\n% ./robonomics io read launch --remote https://ipfs.infura.io:5001/\n```\n'}},{node:{id:"47cc6cb919e92e8b98adcae0154d972e",title:"Robonomics IO IPFS",path:"/docs/ru/rio-ipfs/",content:'\nIt serves downloading and uploading files from/to IPFS network\n\n## Requirements\n\n* `robonomics` [executable](https://github.com/airalab/robonomics/releases)\n* Running [IPFS](https://ipfs.io/#install) daemon \n\n## Write\n\n```\n% echo "Hello Robonomics" | ./robonomics io write ipfs\nQmQAcvgXmcZEjXGibXGFcqdsvvrnWp3BguuubWhzSBZMXy\n```\n\n## Read\n\n```\n% echo QmQAcvgXmcZEjXGibXGFcqdsvvrnWp3BguuubWhzSBZMXy | ./robonomics io read ipfs\nHello Robonomics\n```\n\n## Remote IPFS node\n\nIf your local node is configured differently from defaults or you have a remote node, it\'s possible to specify it with `--remote` option\n\n```\n% echo "Hello Robonomics" | ./robonomics io write ipfs --remote https://ipfs.infura.io:5001/\nQmQAcvgXmcZEjXGibXGFcqdsvvrnWp3BguuubWhzSBZMXy\n```\n\nThe same applies for `read`\n\n'}},{node:{id:"af48592a7bd5bce8445c0dfa6fc8e51a",title:"Robonomics IO Datalog",path:"/docs/ru/rio-datalog/",content:'\nDatalog module allows you to store any string on blockchain\n\nhttps://www.youtube.com/watch?v=rs67AMyd-gE\n\nFor the examples the development network is used. Check [this](/docs/robonomics-test-network-manual/) out to set it up for yourself.\n\n## Requirements\n\n* `robonomics` [executable](https://github.com/airalab/robonomics/releases)\n* Account on parachain\n\nYou can find instructions on how to create an account [here](/docs/create-account-in-dapp)\n\n## Write\n\nAssuming local node is running:\n\n```\n% echo "Hello Robonomics" | ./robonomics io write datalog -s 0xb046fc3c322e91e14a61ad4f08a3809ee0de7092e73aa9b3c2b642a0f476d4d6\n```\n\nwhere `0xb046fc3c322e91e14a61ad4f08a3809ee0de7092e73aa9b3c2b642a0f476d4d6` is a private key for the account with tokens.\nIn this example the public key is 5H3iRnX16DH2sb2RLxMM8UhDZTvJjP84EhhKXv3sCiEDq6bH. Let\'s go to the [Dapp](https://parachain.robonomics.network/)\nand see what happened.\n\nIn the Dapp go to Developer -> Chain state. In the "selected state query" list choose datalog and below choose your account. Click plus button on the right and you should see the following:\n\n![Robonomics Chain State Datalog](../images/robonomics-dapp-chain-state-datalog.jpg "Robonomics Chain State Datalog")\n\n## Remote\nIf your local node is configured differently from defaults or you have a remote node, it\'s possible to specify it with `--remote` option\n\n```\n% echo "Hello Robonomics" | ./robonomics io write datalog -s 0xb046fc3c322e91e14a61ad4f08a3809ee0de7092e73aa9b3c2b642a0f476d4d6 --remote https://ipfs.infura.io:5001/\n```\n'}},{node:{id:"1159cec7738e6369271d84e6df6cbc65",title:"Control Kuka manipulator with robonomics",path:"/docs/ru/kuka/",content:"\nVideo with an example of work can be found here:\n\n[https://youtu.be/Fhf9LIt6zXQ](https://youtu.be/Fhf9LIt6zXQ)\n***\n## Requirements\n* ROS melodic, Gazebo (installation instraction [here](http://wiki.ros.org/melodic/Installation/Ubuntu))\n* Some extra packages\n```bash\nsudo apt-get install ros-melodic-gazebo-ros-control ros-melodic-effort-controllers ros-melodic-joint-state-controller\n```\n* IPFS 0.4.22 (download from [here](https://www.npackd.org/p/ipfs/0.4.22) and install)\n```bash\ntar -xvzf go-ipfs_v0.4.22_linux-386.tar.gz\ncd go-ipfs/\nsudo bash install.sh\nipfs init\n```\n* pip\n```bash\nsudo apt install python-pip\n```\n* ipfshttpclient\n```bash\npip install ipfshttpclient\n```\n* Robonomics node (binary file) (download latest release [here](https://github.com/airalab/robonomics/releases))\n* IPFS browser extension (not necessary)\n***\n## Installation\nInstall Kuka manipulator and control packages\n```bash\ncd catkin_ws/src/\ngit clone https://github.com/orsalmon/kuka_manipulator_gazebo\ngit clone https://github.com/LoSk-p/kuka_controller\ncd ..\ncatkin_make\necho \"source /home/$USER/catkin_ws/devel/setup.bash\" >> ~/.bashrc\n```\n***\n## Running gazebo model\n```bash\nroslaunch manipulator_gazebo manipulator_empty_world.launch\n```\nIn a new window\n```bash\nrosrun manipulator_gazebo move_arm_server\n```\n![model](../images/kuka-demo/gazebo.jpg)\n***\n## Running robonomics\nGo to the folder with robonomics file ad create a local robonomics network:\n```bash\n./robonomics --dev --rpc-cors all\n```\n\n![robonomics](../images/kuka-demo/robonomics.jpg)\n\n**Important!** Before next launches it is necessary to remove a directory `db` with\n\n```\nrm -rf /home/$USER/.local/share/robonomics/chains/dev/db\n```\n\nGo to https://parachain.robonomics.network and switch to local node\n\n![local](../images/kuka-demo/local.jpg)\n\nThen go to Accounts and create KUKA and WORK accounts. Save account's addresses and keys, you will need them later\n\n![acc](../images/kuka-demo/create_account.jpg)\n\n![accs](../images/kuka-demo/accounts.jpg)\n***\n## Running ipfs\nRun ipfs daemon:\n```bash\nipfs daemon\n```\n***\n## Running control package\nIn kuka_control package path you need to edit move_arm_client.py. \n```bash\ncd src/\nnano move_arm_client.py\n```\nChange kuka_address, kuka_key and work_address to you addresses and key, then change robonomics_path to your path to file robonomics.\n\n![code](../images/kuka-demo/code.jpg)\n\nNow you can run control script:\n```bash\npython move_arm_client.py\n```\n![control](../images/kuka-demo/control.jpg)\n\nThen in a new window send a transaction to make Kuka move:\n```bash\necho \"ON\" | ./robonomics io write launch -r <KUKA_ADDRESS> -s <WORK_KEY>\n```\nWhere <KUKA_ADDRESS> and <WORK_KEY> are address and key from your accounts:\n\n![transaction](../images/kuka-demo/transaction.jpg)\n\nIn the window with kuka_control package you will see:\n\n![done](../images/kuka-demo/done.jpg)\n\nThen go Developer/Chain state on the Robonomics portal, select datalog in query and add KUKA datalog with button '+':\n\n![datalog](../images/kuka-demo/datalog.jpg)\n\nNow you can find Kuka's telemetry using this hash in IPFS Companion:\n\n![ipfs](../images/kuka-demo/ipfs.jpg)\n\n![telemetry](../images/kuka-demo/telemetry.jpg)\n\n## Troubleshooting\n\nIf `catkin_make` doesn't work with the message that it can't find MoveArm.h, try to remove last four lines in CMakeLists.txt in kuka_manipulator_gazebo package:\n```\ninclude_directories(include ${catkin_INCLUDE_DIRS})\n\nadd_executable(move_arm_server src/move_arm_server.cpp)\ntarget_link_libraries(move_arm_server ${catkin_LIBRARIES})\nadd_dependencies(move_arm_server beginner_tutorials_gencpp)\n```\nDo `catkin_make` without these lines, then returm them and do `catkin_make` again.\n\n\n\n\n"}},{node:{id:"6ce1e7bf6ac314cc0b9e8975f1357a29",title:"Drone control with robonomics",path:"/docs/ru/iris-drone/",content:'\n**Drone starts moving after transcation and store file with the coordinates in IPFS. The control script is based on the [GAAS demo script](https://github.com/generalized-intelligence/GAAS)**  \n\nhttps://youtu.be/4CwtGAX1OwM\n\n## Requirements\n* dependencies for control:\n``` sh\nsudo apt install -y \\\n\tpython3-pip \\\n\tninja-build \\\n\texiftool \\\n\tpython-argparse \\\n\tpython-empy \\\n\tpython-toml \\\n\tpython-numpy \\\n\tpython-yaml \\\n\tpython-dev \\\n\tpython-pip \\\n\tninja-build \\\n\tprotobuf-compiler \\\n\tlibeigen3-dev \\\n\tgenromfs\n```\n```sh \npip3 install \\\n\tpandas \\\n\tjinja2 \\\n\tpyserial \\\n\tcerberus \\\n\tpyulog \\\n\tnumpy \\\n\ttoml \\\n\tpyquaternion\n```\n* ROS Melodic + Gazebo [installation tutorial](http://wiki.ros.org/melodic/Installation)\n* extra packages: \n``` bash \nsudo apt-get install ros-melodic-gazebo-ros-control ros-melodic-effort-controllers ros-melodic-joint-state-controller\nsudo apt-get install python-jinja2\nsudo apt-get install python-catkin-pkg\nsudo apt-get install python3-catkin-pkg-modules\n```\n* IPFS verson 0.4.22\n```bash\nwget https://dist.ipfs.io/go-ipfs/v0.4.22/go-ipfs_v0.4.22_linux-amd64.tar.gz\ntar -xvzf go-ipfs_v0.4.22_linux-amd64.tar.gz\ncd go-ipfs\nsudo bash install.sh\nipfs init\n```\n* ipfshttpclient\n```sh\npip3 install ipfshttpclient\n```\n* Robonomics node (binary file) (download latest release [here](https://github.com/airalab/robonomics/releases))\n## Environment Setup\n```bash \nsudo apt-get install ros-melodic-mavros ros-melodic-mavros-extras\nwget https://raw.githubusercontent.com/mavlink/mavros/master/mavros/scripts/install_geographiclib_datasets.sh\nsudo ./install_geographiclib_datasets.sh\ncd ~/catkin_ws/src\ngit clone https://github.com/PX4/Firmware.git\ncd Firmware\ngit checkout v1.9.0\nbash ./Tools/setup/ubuntu.sh\n```\n```bash\ncd ~/catkin_ws/src\ngit clone https://github.com/generalized-intelligence/GAAS.git\ncp -r ~/catkin_ws/src/GAAS/simulator/models/* ~/catkin_ws/src/Firmware/Tools/sitl_gazebo/models/\ncp -r ~/catkin_ws/src/GAAS/simulator/worlds/* ~/catkin_ws/src/Firmware/Tools/sitl_gazebo/worlds/\ncp -r ~/catkin_ws/src/GAAS/simulator/posix-config/* ~/catkin_ws/src/Firmware/posix-configs/SITL/init/ekf2/\n```\n\nModifying your `.bashrc` file, adding the following lines to the bottom:  \n\n`source ~/catkin_ws/devel/setup.bash `  \n`source ~/catkin_ws/src/Firmware/Tools/setup_gazebo.bash ~/catkin_ws/src/Firmware/ ~/catkin_ws/src/Firmware/build posix_sitl_default `   \n`export GAZEBO_MODEL_PATH=:~/catkin_ws/src/simulator/models`  \n`export ROS_PACKAGE_PATH=$ROS_PACKAGE_PATH:~/catkin_ws/src/Firmware`  \n`export ROS_PACKAGE_PATH=$ROS_PACKAGE_PATH:~/catkin_ws/src/Firmware/Tools/sitl_gazebo`  \n`export GAZEBO_MODEL_PATH=:~/catkin_ws/src/simulator/models:~/catkin_ws/src/GAAS/simulator/models`  \n\n  \n## Control Package Installation\nIn a new Terminal:\n```bash\ncd catkin_ws/src\ngit clone https://github.com/tubleronchik/robonomics_drone_sim.git\ncd ..\ncatkin build\n```\n## Robonomics Network\nTo create a local robonomics network go to the folder with the robonomic binary file and run:  \n`./robonomics --dev --rpc-cors all`  \n\nAdd robonomic\'s path to `config.py`\n\n![IPFS](../images/iris-drone-demo/IPFS.jpg)\n\nGo to the [Robonomics Portal](https://parachain.robonomics.network) and switch to local node.\n![localNode](../images/iris-drone-demo/localNode.jpg)\n\nGo to **Accounts** and create **DRONE** and **EMPLOYER** accounts. Save the account names and keys and path to **robonomics** to `~/catkin_ws/src/drone_sim/src/config.py`. Transfer some money into the accounts.\n\n![accounts](../images/iris-drone-demo/addingAcc.jpg)\n\n## Running Simulation\nRun IPFS daemon\n```bash\ncd go-ipfs\nipfs daemon\n```\nIn another terminal launch the simulation:\n```bash\nroslaunch px4 mavros_posix_sitl.launch\ncd ~/catkin_ws/src/robonomics_drone_sim/src\npython3 takeoff.py\n```\nWaiting till "Waiting for payment" \n\n![launch](../images/iris-drone-demo/launch.jpg)\n\nTo send a transaction run in another window:\n`echo "ON" | ./robonomics io write launch -r <drone_addres> -s <employer_key>` - where **<drone_address>** and **<employer_key>** should be replaced with the strings from `config.py` accordingly.\n\nAfter data was pushed to IPFS, go to the **Chain State** in [Robonomics Portal](https://parachain.robonomics.network). Select **datalog** in query and add DRONE datalog using `+` button.\n\n![datalog](../images/iris-drone-demo/datalog.jpg)\n\nYou can find drone\'s telemetry running `https://gateway.ipfs.io/ipfs/<hash>` inserting the hash from above.\n\n![output](../images/iris-drone-demo/output.jpg)\n\nIt\'s important to remove `db` derictory before next launches using  \n` rm -rf ~/.local/share/robonomics/chains/dev/db`\n'}},{node:{id:"fd9c22979db2f5833a8f434d188c9a84",title:"IPFS Common",path:"/docs/ru/ipfs-common/",content:'\nThe package handle IPFS connections, provides useful services for working with IPFS Network. \nIt\'s included in `robonomics_liability` launch file\n\n## ROS Parameters\n\n### ~lighthouse_contract\n\nThe name of a lighthouse you are working on. The type is `string`, defaults to `airalab.lighthouse.5.robonomics.eth`\n\n### ~ipfs_http_provider\n\nIPFS HTTP provider address. The type is `string`, defaults to `http://127.0.0.1:5001`\n\n### ~ipfs_public_providers\n\nA public IPFS node to pin result files. The type is `string`, defaults to `""`\n\n### ~ipfs_file_providers\n\nA list of public nodes to pin result files. The type is `list of strings`, defaults to `[ipfs_public_providers]`\n\n### ~ipfs_swarm_connect_addresses\n\nIPFS nodes to connect to. The type is `string`, defaults to `""`\n\n### ~ipfs_swarm_connect_to\n\nA list of IPFS nodes to connect to. The type is `list of strings`, defaults to `[ipfs_swarm_connect_addresses]`\n\n## Subscribed topics'}},{node:{id:"07a5054bd7da0b691b5aff534768466e",title:"IPFS Common Messages",path:"/docs/ru/ipfs-common-messages/",content:"\n## ipfs_common/Filepath.msg\n\n| Field         | Type                  | Description           |\n|------------   |-------------------    |--------------------   |\n| filepath      | std_msgs/String       | A path to a file      |\n\n## ipfs_common/Multihash.msg\n\n| Field         | Type              | Description                               |\n|-----------    |-----------------  |------------------------------------------ |\n| multihash     | std_msgs/String   | A wrapper for model and objective fields  |\n\n## ipfs_common/IpfsDownloadFile.srv\n\n**Request**\n\n| Field         | Type                                                  | Description               |\n|-------------- |---------------------------------------------------    |------------------------   |\n| ipfs_address  | [ipfs_common/Multihash](#ipfs_commonmultihashmsg)     | IPFS hash of a file       |\n| file          | [ipfs_common/Filepath](#ipfs_commonfilepathmsg)       | Where to save the file    |\n\n**Response**\n\n| Field         | Type              | Description           |\n|-----------    |-----------------  |---------------------  |\n| success       | std_msgs/Bool     | Status of execution   |\n| error_msg     | std_msgs/String   | Error message         |\n\n## ipfs_common/IpfsUploadFile.srv\n\n**Request**\n\n| Field     | Type                                              | Description                               |\n|-------    |-------------------------------------------------  |---------------------------------------    |\n| file      | [ipfs_common/Filepath](#ipfs_commonfilepathmsg)   | Path to a file to be uploaded to IPFS     |\n\n**Response**\n\n| Field         | Type                                                  | Description                   |\n|-------------- |---------------------------------------------------    |----------------------------   |\n| success       | std_msgs/Bool                                         | Status of execution           |\n| error_msg     | std_msgs/String                                       | Error message                 |\n| ipfs_address  | [ipfs_common/Multihash](#ipfs_commonmultihashmsg)     | IPFS hash of uploaded file    |\n"}},{node:{id:"76a7b929296defe740dd8dbf0d958866",title:"IoT Sensors Connectivity",path:"/docs/ru/iot-sensors-connectivity/",content:"\nRobonomics Network allows you to communicate with any sensor you wish and get data from the sensor all around the world. This data can be transferred to different destinations.\n\nOn this page you'll find step-by-step instructions to connect an ESP board to the connectivity server provided by AiraLab.\n\n## Requirements\n\n* ESP8266/ESP32 like board with WiFi\n\n## 1. Get the software\n\n### On Windows\n\nInstall [WSL](https://docs.microsoft.com/en-us/windows/wsl/install-win10).\n\nInstall Ubuntu via Windows Store:\n\n![Windows Store](../images/windows_store.jpg \"Windows Store\")\n\nand clone the [package](https://github.com/airalab/sensors-connectivity)\n\n```\ngit clone https://github.com/airalab/sensors-connectivity\n```\n\nThe next step is to install python and dependencies:\n\n```\nsudo apt update && sudo apt install python3-pip\ncd sensors-connectivity\npip3 install -r requirements.txt\n```\n\n### On Ubuntu\n\n```\nsudo apt update && sudo apt install python3-pip git\ngit clone https://github.com/airalab/sensors-connectivity\ncd sensors-connectivity\npip3 install -r requirements.txt\n```\n\n> You can ignore such warnings:\n>\n> ```\n> The script ... is installed in '...' which is not on PATH.\n> Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.\n> ```\n\n### On NixOS\n\n```\ngit clone https://github.com/airalab/sensors-connectivity\ncd sensors-connectivity\nnix build -f release.nix\nsource result/setup.bash\n```\n"}},{node:{id:"50b226410ee8272c83e44699789ef9ac",title:"IoT Firmware Upload",path:"/docs/ru/iot-firmware-upload/",content:" \n\nThere are few firmwares for ESP like boards:\n\n* [Ping](https://github.com/airalab/sensors-connectivity/tree/master/boards/esp/ping)\n* [TCP](https://github.com/airalab/sensors-connectivity/tree/master/boards/esp/tcp)\n* [Mobile GPS](https://github.com/airalab/sensors-connectivity/tree/master/boards/esp/mobile_gps)\n\nThere is a script to upload a firmware for each one, called `flash_firmware.py`. It's located in the root of the repository\n\n> **Requirements**\n> In order to install all dependencies run in the root of the repository folder:\n>\n> ```\n> pip install -r requirements.txt\n> ```\n>\n> Python3 is required!\n\nUsually in order to upload a firmware to your board follow these steps:\n\n1. Assemble the board and connect it to PC\n2. Edit a `config.yaml` in a corresponding folder (e.g. `boards/esp/tcp/config.yaml`)\n3. Run `python flash_firmware.py -s PATH_TO_FOLDER -c PATH_TO_CONFIG` where `PATH_TO_FOLDER` is a path to the desired firmware (e.g. `boards/esp/ping`) and `PATH_TO_CONFIG` is a path to the configuration file (e.g. `boards/esp/ping/config.yaml`)\n\n"}},{node:{id:"0f0458f9f322337b673756a4a01ef2fa",title:"Interact with AIRA",path:"/docs/ru/interact-with-aira/",content:'\nAt this point you should be familiar with a [DApp](/docs/get-weather-on-fuji-mountain/) and how to launch [AIRA image](/docs/aira-installation-on-vb/).\nNow you are ready to do more complicated stuff like installing a package and interacting with it via DApp.\n\n> **Important:**\n> Make sure you have covered previous lessons before you continue.\n\n\n> **Tip:**\n> During the lesson you will type a few commands in terminal. AIRA image doesn\'t support clipboard, so to make life easier have a look at [Connect via SSH](/docs/aira-connecting-via-ssh/) and log in via SSH to the VM.\n\nWalkthrough video:\n\nhttps://www.youtube.com/embed/QM06l07_wuA\n\n## Package installation\n\nAfter you launched AIRA and logged in using your terminal do the following:\n\n```\nsu liability && cd\ngit clone https://github.com/vourhey/hello_aira\ncd hello_aira\nnix build -f release.nix\nsource result/setup.bash\nrosrun hello_aira hello_aira\n```\n\nRun one by one commands above. After the last one you should see a link to DApp generated specifically for your instance.\n\n![Terminal with AIRA](../images/aira_hello_terminal.jpg "Terminal with AIRA")\n\nClick on the link, the DApp should be shown.\n\n## DApp \n\nConnect [MetaMask](http://metamask.io/) if prompted and click on the button\n\n![Request connection in Robonomics Dapp](../images/aira_hello_dapp.jpg "Request connection in Robonomics Dapp")\n\nSign the message as usual and wait for the result\n\n![Wait for Result of request](../images/aira_hello_dapp_2.jpg "Wait for Result of request")\n\nMeanwhile have a look at the terminal. You should see the greeting\n\n![AIRA greeting in terminal](../images/aira_hello_terminal_2.jpg "AIRA greeting in terminal")\n\nIn the end the greeting will appear in the DApp\n\n![Robonomics DApp Greeting for AIRA](../images/aira_hello_dapp_3.jpg "Robonomics DApp Greeting for AIRA")\n\n## Troubleshooting\n\n### You click "Request current values" but see no greeting\n\nProbably you have just launched AIRA and IPFS hasn\'t finished initialization. Wait a minute or so and try again.\n\n### I see response hash but the data doesn\'t appear\n\nAgain most probably the issue comes from IPFS connection. Click and the hash and you\'ll see the result. It\'s not necessary to download the file.\n\n## Home Task (optional)\n\nIf you are familiar with [Python](https://www.python.org/) change the shown text to something different and complete the lesson with your version of `hello_aira`\n\n- Make a fork of the [repository](https://github.com/vourhey/hello_aira)\n- The output text is located [here](https://github.com/Vourhey/hello_aira/blob/master/scripts/hello_aira#L45)\n'}},{node:{id:"1f6a9968edbaf9d5a7b6a5bce8a3235f",title:"Passing dynamic parameters",path:"/docs/ru/hardware-passing-dynamic-parameters/",content:'\nIn [previous](/docs/connect-simple-cps/) example we discussed how to create a simple CPS with Arduino. Our first CPS is able to do only one task: to blink a led. We suggest you to get through the first lesson. Now let\'s expand the example and teach our board to blink blue or red led depending on objective parameter.\n\n> The source code of this lesson is [here](https://github.com/airalab/robonomics_tutorials/tree/master/arduino_with_args).\n\n\n## Arduino\n\nThe only difference in Arduino source code is instead of subscribing to one topic now we subscribe to `/blink_red` and `/blink_blue` topics\n\n```c\n  #include <ros.h>\n  #include <std_msgs/Empty.h>\n\n  ros::NodeHandle nh;\n\n  void blink(int led, int mil) {\n\n    digitalWrite(led, HIGH);\n    delay(mil);\n    digitalWrite(led, LOW);\n    delay(mil);\n\n  }\n\n  void blinkRedCb(const std_msgs::Empty& msg) {\n    blink(13, 500);\n    blink(13, 500);\n    blink(13, 500);\n  }\n\n  void blinkBlueCb(const std_msgs::Empty& msg) {\n    blink(12, 500);\n    blink(12, 500);\n    blink(12, 500);\n  }\n\n  ros::Subscriber<std_msgs::Empty> subRed("blink_red", &blinkRedCb);\n  ros::Subscriber<std_msgs::Empty> subBlue("blink_blue", &blinkBlueCb);\n\n  void setup()\n  {\n    pinMode(13, OUTPUT);\n    pinMode(12, OUTPUT);\n\n    nh.initNode();\n    nh.subscribe(subRed);\n    nh.subscribe(subBlue);\n  }\n\n  void loop()\n  {\n    nh.spinOnce();\n    delay(1);\n  }\n```\n\n\x3c!-- Here is the diagram of all connections:\n\n.. image:: ../img/6.png\n  :alt: Arduino schema\n  :align: center --\x3e\n\n\n## ROS\n\nWe can pass arguments via objective which points to rosbag file. Have a look at `blink.py` script. The main difference is `blink()` method:\n\n```python\ndef blink(self, data):\n  if data.data == "blue":\n      rospy.loginfo("Blinking blue...")\n      self.blink_blue.publish(Empty())\n\n  if data.data == "red":\n      rospy.loginfo("Blinking red...")\n      self.blink_red.publish(Empty())\n\n  rospy.wait_for_service(\'/liability/finish\')\n  fin = rospy.ServiceProxy(\'/liability/finish\', FinishLiability)\n  fin(FinishLiabilityRequest(address=self.liability, success=True))\n  rospy.loginfo("Finished")\n```\n\nNow `/blink` topic has a `String` type. You can find prepared rosbags in `rosbag` folder.\n\n## AIRA\n\nConnect to AIRA client via SSH as described [here](/docs/aira-connecting-via-ssh/). Do not forget to add `COM1` port in settings. Run the following command:\n\n```\n$ rosrun arduino_with_args blink.py\n```\n\nAlso we need to add rosbag files to IPFS:\n\n```\n$ ipfs add rosbag/blink_blue.bag\n$ ipfs add rosbag/blink_red.bag\n```\n\n**Before the next step you should approve XRT tokens on the Factory.**\n\nThe last step is to build Dapp and launch. Take a look at the previous [lesson](/docs/connect-simple-cps/). To make Arduino blink the blue led send blue demand and blue offer messages. For the red one send corresponding messages.\n\nThat\'s it! Now you are able to pass dynamic parameters to your cyber-physical system agent!'}},{node:{id:"a4d547219e2f9675dd87ae7b45fa287e",title:"Connect an Air Pollution Sensor",path:"/docs/ru/hardware-connect-sensor/",content:"\nIn this lesson you are going to learn how to connect your sensor to the network and make it publish data. You will see how it is easy to become a member of a global sensor network!\n\nSource code is located [here](https://github.com/airalab/robonomics_tutorials/tree/master/sensor_city).\n\nIn this section we are not going to create a liability contract. Instead we will teach Arduino with sensors to publish the data by a request. All measurements will be published as a Result message.\n\n## Arduino\n\nLet's begin with an Arduino circuit. You need the following components:\n\n* Arduino Uno\n* Optical Dust Sensor Sharp GP2Y1010AU0F\n* Gas Sensor MQ-2\n* Gas Sensor MQ-7\n* Resistor 150 Ohm\n* Capacitor 220 uF\n* Wires\n\nConnect all parts as described below:\n\n\x3c!-- .. image:: ../img/7.png\n  :alt: Arduino schema\n  :align: center --\x3e\n\nA firmware for Arduino Uno is in `sensor_city/scetches` folder. In order to upload it to the board use [Arduino IDE](https://www.arduino.cc/en/Main/Software).\n\n\x3c!-- .. image:: ../img/8.png\n   :alt: Arduino IDE\n   :align: center\n --\x3e\n\n## Aira\n\nThe following steps are performed in Aira client. You can download the latest image from [this page](https://github.com/airalab/aira/releases). It's convenient to [connect via SSH](/docs/aira-connecting-via-ssh/).\n\nAfter you have imported the image to VirtualBox, connect Arduino via USB to your PC and enable serial port forwarding. You should check `Enable Serial Port` and assign `/dev/ttyACM0` in `Path/Address`. Inside the virtual machine `/dev/ttyS0` refers to your external Arduino.\n\n\x3c!-- .. image:: ../img/9.png\n   :alt: Set a port\n   :align: center --\x3e\n\nFinally launch the image and run these command:\n\n```\n$ roslaunch sensor_city publish_data.launch\n```\n\n**Check out the source code to learn how it works under the hood!**\n\nNow Aira patiently waits for a signal to publish the measurements. Go to [Dapp](https://dev.aira.life/smart-city/#/) and click on `Broadcast signal`. You should see the data!"}},{node:{id:"0e00b81abe56ec93b4674a4e11cf0baa",title:"Glossary",path:"/docs/ru/glossary/",content:'\n## Agent\n\nIn terms of Robonomics Network agent is a program module that uses IPFS or blockchain or both interfaces of the network and does some actual work.\nUsually it\'s represented as a ROS package and it may connect (but not necessarily) a real cyber-physical system to the Robonomics Network.\n\n## Cyber-physical system\n\nIt is a combination of a physical mechanism that is usually called a robot and a program algorithm that controls the behavior of the mechanism.\n\n## Dapp\n\nIt is a short form for Decentralized application. Usually it is a single page web based application that helps to interact with an agent.\n\n## IPFS\n\nAccording to the official [documentation](https://docs.ipfs.io/introduction/) "IPFS is a distributed system for storing and accessing files, websites, applications, and data".\nFor more detail how it works go to the official website.\n\n## Lighthouse\n\nA lighthouse is an autonomous workflow that allows us to distribute the running time of providers that serve a single broadcast channel.\n\nFor more information read [Robonomics Whitepaper](https://static.robonomics.network/docs/whitepaper/Robonomics-whitepaper-en.pdf) section 5.2.\n\n## Sidechain\n\nEthereum based blockchain network with Proof-of-Authority consensus owned by Airalab.\n\n'}},{node:{id:"2412f765e5ec9f151ce1b81f8b82a157",title:"Введение",path:"/docs/ru/",content:'\n## Что такое Робономика\n\nПлатформа Робономики предоставляет инструменты для экономического взаимодейтсвия с роботами. Робономика позволяет разработчикам умных городов и сервисов Индустрии 4.0 построить доверительные отношения между [автономными роботизированными сервисами](/docs/glossary#cyber-physical-system) и обеспечить прямой доступ к услугам умных фабрик и сетей датчиков для пользователей через [децентрализованные приложения](/docs/glossary#dapp). \n\nУзнайте больше в документе ["Robonomics whitepaper"](https://github.com/airalab/robonomics_specs/blob/master/pdf/whitepaper_ru.pdf) на русском.\n\n![Сценарий сети Робономика](../images/robonomics_network_basic_scheme_ru.jpg "Сценарий сети Робономика")\n\n*Схема работы сети Робономика*\n\n## What the documentation contains\n\n### Robonomics Network quick start\nStart with quick example of what Robonomics is able to do within 5 minutes: [DEMO "Get Weather on Fuji Mountain"](/docs/get-weather-on-fuji-mountain).\n\n### I\'m interested in using Robonomics services\n\nTake a look at the [Robonomics Dapp](https://dapp.robonomics.network/#/). Get familiar with the statistic, average miner reward etc.\nTry out existing [services](https://dapp.robonomics.network/#/services)\n\n### I\'m a Dapp developer\n\n- [Robonomics-js on GitHub](https://github.com/airalab/robonomics-js) - simple Javascript SDK for Robonomics Network dApp developers.\n- [dApp template](https://github.com/airalab/vue-dapp-robonomics-template) - uses Vue.js\n- [Wiki documentation](/docs/robonomics-js/)\n\n### I\'m a robotics engineer\n\nCheck out [cases](/docs/iot-sensors-connectivity/) section and start developing by [examples](/docs/agent-development-examples).\n\n'}},{node:{id:"eaa678091da8874311dc3decc396e423",title:'DEMO "Get Weather on Fuji Mountain"',path:"/docs/ru/get-weather-on-fuji-mountain/",content:'\n**Let\'s start from a quick example of what Robonomics is able to do within 5 minutes. Requirements: [Metamask extension](https://metamask.io/)**\n\nTo get the weather from sensor on Fuji Mountain, please, open the page of [Fuji Weather sensor](https://dapp.robonomics.network/#/sensors/airalab/QmbQT8cj9TJKfYVaidfShnrEX1g14yTC9bdG1XbcRX73wY/0x4D8a26e1f055c0b28D71cf1deA05f0f595a6975d/) in Robonomics dApp and follow instructions below.\n\nHere\'s a walkthrough video:\n\nhttps://www.youtube.com/embed/t098NlMELk4\n\n## 1. Open the Dapp\n\nIn case you don\'t have MetaMask extension you\'ll see the picture below. Go to the link provided above and install one.\n\n!["Robonomics dApp if no MetaMask installed"](../images/sensor-demo/sensor-demo-1.png "Robonomics dApp if no MetaMask installed")\n\n## 2. Allow connection to the extension\n!["Connection to Robonomics dApp via Metamask"](../images/sensor-demo/sensor-demo-2.png "Connection to Robonomics dApp via Metamask")\n\n## 3. Press "Request current values"\n!["Request sensor\'s data in Robonomics network via dApp"](../images/sensor-demo/sensor-demo-3.png "Request sensor\'s data in Robonomics network via dApp")\n\n## 4. Sign a message. No token or ether are needed\n!["Sign a message in Robonomics network via dApp"](../images/sensor-demo/sensor-demo-4.png "Sign a message in Robonomics network via dApp")\n\n## 5. Wait until the agent collects the data and sends it back\n!["Wait for response of the agent in Robonomics network via dApp"](../images/sensor-demo/sensor-demo-5.png "Wait for response of the agent in Robonomics network via dApp")\n\n## 6. Wait until the Dapp downloads the result file from IPFS\n!["Wait for IPFS file with results in Robonomics network via dApp"](../images/sensor-demo/sensor-demo-6.png "Wait for IPFS file with results in Robonomics network via dApp")\n\n## 7. Look at the weather data on Fuji Mountain\n!["The results of sensor network in Robonomics via dApp"](../images/sensor-demo/sensor-demo-7.png "The results of sensor network in Robonomics via dApp")\n\nJust now you have broadcasted a demand message and got a result from an autonomous agent! The result file is stored in IPFS, the result message is signed with the agent\'s private key.\n'}},{node:{id:"50a7edd0757b7dcc4d2fb8fb7335eecd",title:"Gaka-Chu setup and software Installation",path:"/docs/ru/gaka-chu/",content:"\nhttps://www.youtube.com/watch?v=GxlYxaykqTU\n\n**In this article we will go through some installation and launching steps to set up a robot-painter. Requirements:**\n- KUKA KR6 R900 sixx with KRC4 and a SmartPad;\n- Intel NUC with [ROS melodic](http://wiki.ros.org/melodic/Installation/Ubuntu) installed;\n- Table, paint, brush, water.\n\n## Software installation on KRC4\nEKI interface is required on both, KRC4 and NUC. Detailed information on how to set it up on KRC4 is presented [here](https://github.com/AlexeiOvcharov/kuka_experimental/tree/a915bf4e932990379c84164713e7ae11a24a2a13/kuka_eki_hw_interface/krl). Launch it on robot's controller.\n\n## Software installation on NUC\nCreate a catkin workspace:\n```\nmkdir -p ~/catkin_ws/src\ncd ~/catkin_ws/\ncatkin build\n```\nDownload ROS packages. All the scripts are stored [here](https://github.com/airalab/robot_painter/tree/test_branch). Clone the repository:\n```\ncd src\ngit clone --branch test_branch https://github.com/airalab/robot_painter\ncd robot_painter\nrm -rf scenes\nmv * ../\ncd ..\nrmdir robot_painter\n```\nYou may need some header files and libraries to make it all work correctly. Download them:\n```\ncd ~\ngit clone https://github.com/PaTara43/kuka_moveit_webots\ncd kuka_moveit_webots\nsudo mv -r headers/* usr/include/c++/7/\nsudo mv libs/* usr/local/lib/\ncd ~\nsvn checkout https://github.com/PX4/Matrix/trunk/matrix\nmv matrix -r /usr/include/c++/7/\nsudo apt-get install ros-melodic-brics-actuator\ncd ~/catkin_ws\ncatkin build\n```\nAdd source command to `.bashrc` file:\n```\necho “source ~/catkin_ws/devel/setup.bash” >> ~/.bashrc\nsource ~/.bashrc\n```\nUp to now. you should be able to launch the scripts. If something goes wrong, try some [troubleshooting](https://github.com/airalab/robot_painter/issues)\n\n## Filling in constants\nFirst of all, the robot needs to know canvas location and orientation as well as the paint tin position. All of this is specified in `fake_painter_enviroment_tf/src/tf_broadcaster.cpp`. Let's take a look into it.\n```\n// Plane constants\nconst double A = -0.0641;\nconst double B = 0.0214;\nconst double C = 0.9977;\nconst double D = -0.2198;\n\n// Canvas transform\nconst double px = 0.52;\nconst double py = -0.24;\nconst double qx = -0.011;\nconst double qy = -0.032;\nconst double qz = 0.0;\nconst double qw = 0.999;\n```\nThese are the plane equation constants which specify canvas position in 3-D space. They are to be obtained during a calibration process described below. Next goes the paint.\n```\ncolorTransform.transform.translation.x = 0.5;\ncolorTransform.transform.translation.y = 0.2;\ncolorTransform.transform.translation.z = 0.258;\n```\nThese are paint tin coordinates. They also may be specified while calibrating. Canvas size is specified in\n```\ncanvas.width = 0.5;\ncanvas.height = 0.4;\n```\nSeveral more important constants are stored in `local_task_planner/src/Drawing.cpp`:\n```\nconst double COLOR_BOTLE_HEIGHT = 0.06;\nconst double COLOR_HEIGHT = 0.045;\nconst double HEIGHT_OFFSET = COLOR_BOTLE_HEIGHT - COLOR_HEIGHT + 0.02;\nconst double BRUSH_HEIGHT = 0.01;\nconst double BRUSH_WIDTH = 0.01;\n```\nTheir names say it all, so fill them in according to the situation.\n\n## Calibrating Gaka-Chu\nThe calibration process itself is pretty simple.\n\n1) Start EKI interface on the KRC4:\n\nLog in in 'AUT' mode, turn on drivers and launch the script `eki_hw_interface`\n\n2) Start EKI interface on the NUC\n```\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\n```\nIt should output endless logs.\n\n3) Start RViz\n```\nroslaunch kuka_moveit_config demo.launch\n```\nYou should see the following:\n\n![KUKA in RViz](../images/kuka-real/kuka_rviz.png \"KUKA in RViz\")\n\nTry moving the end effector and clicking 'Plan and Execute'. The robot should move. On SmartPad go to **Display -> Actual position** and observe end effector's coordinate. Place a canvas horizontally to the robot base. Plug a brush into the brush holder and carefully move it till it barely touches the canvas. At this position, save end effector's coordinates. Repeat 12-15 times. Also, save the coordinates of the canvas center and paint tin.\nWhen you have a set of coordinates, use [these](https://github.com/nakata5321/Matlab_scripts_gaka-chu) Matlab scripts to resolve the missing constants and quaternion. Paste them. Rebuild your workspace with\n```\ncd ~/catkin_workspace\nrm -rf build logs devel\ncatkin build\n```\n\n## Testing Gaka-Chu calibration\nWhen calibrated, Gaka-Chu needs to be tested by drawing the borders of canvas. To make him do so execute each in new terminal:\n```\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\nroslaunch kuka_moveit_config demo.launch\nrosrun fake_painter_enviroment_tf tf_broadcaster\nrosrun local_task_planner draw_workspace\n```\nAfter this, you should see a canvas contour in RViz:\n\n![KUKA in RViz canvas](../images/kuka-real/kuka_rviz_canvas.png \"KUKA in RViz canvas\")\n\nIn terminal press \"S\" to perform testing. Robot's end effector should move right above the borders of the canvas and the brush should gently touch the canvas during the entire movement. If not so, try recalibrating. If the canvas model is rotated wrong, you can rotate it by changing quaternion in Matlab.\n\n## Making art\nYou need 6 basic modules to make it all work:\n- EKI interface;\n- MOVEit + RViz;\n- Environment frames broadcasting;\n- Picture converter service;\n- Trajectories drawing module;\n- Starting trigger.\n\nLet's launch them one by one.\n\n### Eki interface\nOn KRC4 launch `eki_hw_interface`, on NUC in a new terminal do:\n```\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\n```\n\n### RViz and MOVEit\nYou need a planner and a simulation. Launch them with\n```\nroslaunch kuka_moveit_config demo.launch\n```\n\n### Environment\nTell the robot where the paint tin and the canvas are. Note that it is not necessary to launch `draw workspace` node, the `tf_broadcaster` shares the canvas size. It just doesn't show it in RViz.\n```\nrosrun fake_painter_enviroment_tf tf_broadcaster\n```\n\n### Pictures processor\nAll incoming pictures need to be processed. Launch the service.\n```\nrosrun picture_preprocessing TextConverter.py\n```\nWhen it receives the call, it processes a picture with a HP filter and creates a rosbag file with trajectories.\n\n### Trajectories drawer\nThe mainest script here is the trajectories drawer itself. It waits for the picture, calls TextConverter service and draws the painting.\n```\nrosrun local_task_planner trajectory_drawing\n```\n\n## Send the robot a picture to draw\nThe robot listens to a specific ROS-topic where you need to pass the path to a desired picture. The picture should be square (width equals height) and made of lines. Send the path:\n```\nrostopic pub /run std_msgs/String \"data: '<path_to_picture>'\"\n```\nAfter that. Two windows pop up showing the contours and the tracks. Close them and see Gaka-Chu drawing. Watch out for safety and alwasy be ready to press emergency stop button.\nWhen Gaka-Chu finishes his art, you can send another path to picture and painter repeats the whole process.\n"}},{node:{id:"57bff9b173a46c19da69c362882f4d7f",title:"Connect an Amazon FreeRTOS Device to Robonomics by MQTT",path:"/docs/ru/freertos-mqtt/",content:"\nHere's the demonstration of how a microcontroller running [Amazon Web Services FreeRTOS](https://aws.amazon.com/freertos/) may be connected to Robonomics Network via MQTT. Please check [this repository](http://github.com/khssnv/freertos_mqtt_robonomics_example) for the project source code.\n\nWe use [ESP32 DevKitC](https://devices.amazonaws.com/detail/a3G0L00000AANtjUAH/ESP32-WROOM-32-DevKitC/) with FreeRTOS distribution and MQTT implementation provided by [Espressif IoT Development Framework](https://github.com/espressif/esp-idf) while Espressif is a vendor of the microcontroller used.\n\nAlso there is a [PMS-3003](http://www.plantower.com/en/content/?107.html) sensor for demonstration purposes. Sensor measures presence of particulated matter in the air and one may use it to estimate air quality.\n\nAir quality is not a topic of the article, you may find more about it at WHO's website: [Ambient (outdoor) air pollution](https://www.who.int/news-room/fact-sheets/detail/ambient-(outdoor)-air-quality-and-health). A goal of the system is to publish sensor measurements to Airalab's Robonomics network.\n\n## Hardware setup\n\nWe connect PMS3003 TXD PIN5 to ESP32 DevKitC IO17 to transfer measurements by UART.\nAlso both devices require power and common ground.\n\n![Wiring Diagram](../images/freertos-mqtt/wiring.png)\n\n## Data Flow\n\nIn order to deliver sensor measurements to Robonomics network, on a firmware level our goal is to get data from a sensor by embedded communication protocol it supports (UART in our case) and pass it to AIRA instance by MQTT / TCP.\n\n![Sending](../images/freertos-mqtt/send.svg)\n\nIn our example we use AIRA cloud deployment available by public IP address and domain name assigned.\nOn AIRA instance we setup `mosquitto` MQTT broker and subscribe to `/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4` topic to get messages from MQTT.\n\nThen we pass messages to `robonomics io` writer by pipe.\n\n![Receiving](../images/freertos-mqtt/recv.svg)\n\nNow data available in Robonomics Network and we can be read it with `robonomics io` again.\n\n## Firmware\n\nWe use [ESP-MQTT sample application with TCP transport](https://github.com/espressif/esp-idf/tree/master/examples/protocols/mqtt/tcp) as a basis.\n\nWe only modify `main/app_main.c` for UART connection to the sensor, SNTP time synchronization and periodic MQTT publisher routine.\n\nIf you are trying to repeat the project, and it's your first ESP IDF based project, at first please follow [Espressif's ESP-IDF Programming guide](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/index.html#installation-step-by-step) introduction in order to familiarize with firmware operations like configuration, build and upload with `idf.py` tool.\n\n### Wi-Fi Configuration\n\nIn order to communicate with AIRA instance deployed in cloud, our microcontroller requires Internet connection.\nWe use ESP32's Wi-Fi for it.\nEspressif provides utilities to configure on-board Wi-Fi.\nIn our example we use development environment with Ubuntu 20.04 GNU/Linux.\nTo configure Wi-Fi we go to project folder and run SDK configuration tool.\n\n```console\ncd freertos_mqtt_robonomics_example/firmware\nidf.py menuconfig\n```\n\nThen we set Wi-Fi access point SSID and password in `Example Connection Configuration` section.\n\n![Menuconfig Wi-Fi](../images/freertos-mqtt/menuconfig-wi-fi.png)\n\n### MQTT Endpoint Configuration\n\nThere are two things to configure for MQTT.\nThe first is a MQTT broker address.\nIt is configurable with SDK configuration tool.\n\n```console\ncd freertos_mqtt_robonomics_example/firmware\nidf.py menuconfig\n```\n\nSet `Broker URL` in `Example Configuration` section.\n\n![Menuconfig MQTT](../images/freertos-mqtt/menuconfig-mqtt.png)\n\nThe second thing is a MQTT topic.\nWe set it in the firmware with the project name prefix followed with our ESP32 MAC address.\nIt gives us `/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4` for our particular microchip.\n\n## From MQTT to Robonomics\n\nAt first let's check we receive data by MQTT.\nWe can subscribe to our Mosquitto MQTT broker topic device publish to.\n\n```console\n$ nix-shell -p mosquitto --run \"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\"\nts=1615651809, PM1=2, PM2.5=6, PM10=3\n```\n\nHere we bring `mosquitto` package into our environment to use `mosquitto_sub` utility.\nThen we subscribe to the topic set in the firmware.\nWe got our measurements that means AIRA receives data by MQTT correctly.\nNow let's pipe these messages to Robonomics Network.\n\n```console\nnix-shell -p mosquitto --run \"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\" | robonomics io write pubsub --bootnodes=/ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\n```\n\nHere we use `robonomics` utility to publish messages in pubsub channel `/freertos_mqtt_robonomics_example`.\nWe specify `bootnodes` to ensure at least one connection established.\n\nNow we are read these messages from the same pubsub channel.\n\n```console\n$ robonomics io read pubsub --listen /ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\n2021-03-27 15:15:51  Generated random peer id: 12D3KooWB2nym5E6c3aPpnPKK5wB9Z6n9eZzcXSpyUBozxhi6dam\n2021-03-27 15:15:51  Subscribed to topic: _robonomics_pubsub_peer_discovery\n2021-03-27 15:15:51  Subscribed to topic: /freertos_mqtt_robonomics_example\n2021-03-27 15:15:56  New peer connected: PeerId(\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\")\n2021-03-27 15:15:56  GRAFT: Mesh link added for peer: PeerId(\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\") in topic: TopicHash { hash: \"_robonomics_pubsub_peer_discovery\" }\nts=1616843855, PM1=3, PM2.5=4, PM10=3\n```\n\n## Original Resources Used\n\n* ESP32 DevKitC pinout from GoJimmy's blog https://gojimmypi.blogspot.com/2017/03/jtag-debugging-for-esp32.html\n* PSM3003 data structure and decoder from OpenAirProject https://github.com/openairproject/sensor-esp32\n\n**Thank you all!**\n"}},{node:{id:"55eae94f73899b4b85963c1aac99b2cb",title:"Ethereum Common",path:"/docs/ru/ethereum-common/",content:'\nThe packages contains two launch files: `erc20.launch` and `signer.launch`. The last one is included in [Robonomics Liability](/docs/robonomics-liability).\n\nBelow is the description for `erc20` node which contains utils for convenient work with Ethereum accounts and XRT token.\n\n## ROS Parameters\n\n###  ~web3_http_provider\n\nWeb3 HTTP provider address. The type is `string`, defaults to `http://127.0.0.1:8545`\n\n### ~erc20_token\n\nERC20 token to work with. Type is `string`, defaults to `xrt.5.robonomics.eth`\n\n### ~factory_contract\n\nThe name of the liability factory. The type is `string`, defaults to `factory.5.robonomics.eth`\n\n### ~ens_contract\n\nThe checksumed address of ENS registry. The type is `string`, defaults to `""`\n\n### ~keyfile\n\nPath to keyfile. The type is `string`, defaults to `""`. **Required parameter**\n\n### ~keyfile_password_file\n\nPath to a file with password for the keyfile. The type is `string`, defaults to `""`. **Required parameter**\n\n## Published topics\n\n### /eth/event/transfer (ethereum_common/TransferEvent)\n\nThe event [ethereum_common/TransferEvent](/docs/ethereum-common-messages#ethereum_commontransfereventmsg) is emitted after the transfer of tokens was made\n\n### /eth/event/approval (ethereum_common/ApprovalEvent)\n\nThe event [ethereum_common/ApprovalEvent](/docs/ethereum-common-messages#ethereum_commonapprovaleventmsg) is emitted after the approval of tokens was made\n\n## Services\n\n### /eth/accounts (ethereum_common/Accounts)\n\nList of available Ethereum accounts. See [ethereum_common/Accounts](/docs/ethereum-common-messages#ethereum_commonaccountssrv)\n\n### /eth/account_eth_balance (ethereum_common/AccountBalance)\n\nReturns the balance of the given address in Wei. See [ethereum_common/AccountBalance](/docs/ethereum-common-messages#ethereum_commonaccountbalancesrv)\n\n### /eth/eth_balance (ethereum_common/Balance)\n\nReturns the balance of the default address. See :ref:`Ethereum-common-Balance.srv`\n\n### /eth/current_block (ethereum_common/BlockNumber)\n\nReturns current block number. See :ref:`Ethereum-common-BlockNumber.srv`\n\n### /eth/transfer (ethereum_common/Transfer)\n\nTransfers tokens from the default account to a given one. See :ref:`Ethereum-common-Transfer.srv`\n\n### /eth/transfer_from (ethereum_common/TransferFrom)\n\nTransfers tokens from a given account to another one. See :ref:`Ethereum-common-TransferFrom.srv`\n\n### /eth/approve (ethereum_common/Approve)\n\nApproves tokens from the default account to a given one. See :ref:`Ethereum-common-Approve.srv`\n\n### /eth/account_xrt_balance (ethereum_common/AccountBalance)\n\nReturns the XRT balance of a given account. See :ref:`Ethereum-common-AccountBalance.srv`\n\n### /eth/xrt_balance (ethereum_common/Balance)\n\nReturn the XRT balance of the default account. See :ref:`Ethereum-common-Balance.srv`\n\n### /eth/account_xrt_allowance (ethereum_common/AccountToAddressAllowance)\n\nReturns how much one account is allowed to spend from another account. See :ref:`Ethereum-common-AccountToAddressAllowance.srv`\n\n### /eth/xrt_allowance (ethereum_common/Allowance)\n\nReturns how much the Factory is allowed to spend from the default account. See :ref:`Ethereum-common-Allowance.srv`'}},{node:{id:"561afe2ef0f44347c69a9812a6009e2c",title:"Ethereum Common Messages",path:"/docs/ru/ethereum-common-messages/",content:"\n## ethereum_common/Address.msg\n\n| Field   \t| Type            \t| Description                    \t|\n|---------\t|-----------------\t|--------------------------------\t|\n| address \t| std_msgs/String \t| Address in Ethereum blockchain \t|\n\n## ethereum_common/UInt256.msg\n\n| Field   \t| Type            \t| Description                \t|\n|---------\t|-----------------\t|----------------------------\t|\n| uint256 \t| std_msgs/String \t| A wrapper for big integers \t|\n\n## ethereum_common/TransferEvent.msg\n\n| Field      \t| Type                                                  \t| Description      \t|\n|------------\t|-------------------------------------------------------\t|------------------\t|\n| args_from  \t| [ethereum_common/Address](#ethereum_commonaddressmsg) \t| Sender address   \t|\n| args_to    \t| [ethereum_common/Address](#ethereum_commonaddressmsg) \t| Receiver address \t|\n| args_value \t| [ethereum_common/UInt256](#ethereum_commonuint256msg) \t| Amount of tokens \t|\n\n## ethereum_common/ApprovalEvent.msg\n\n| Field        \t| Type                                                  \t| Description      \t|\n|--------------\t|-------------------------------------------------------\t|------------------\t|\n| args_owner   \t| [ethereum_common/Address](#ethereum_commonaddressmsg) \t| Owner address    \t|\n| args_spender \t| [ethereum_common/Address](#ethereum_commonaddressmsg) \t| Spender address  \t|\n| args_value   \t| [ethereum_common/UInt256](#ethereum_commonuint256msg) \t| Amount of tokens \t|\n\n## ethereum_common/AccountBalance.srv\n\n**Request**\n\n| Field   \t| Type                                                  \t| Description      \t|\n|---------\t|-------------------------------------------------------\t|------------------\t|\n| account \t| [ethereum_common/Address](#ethereum_commonaddressmsg) \t| Ethereum address \t|\n\n**Response**\n\n| Field   \t| Type                                                  \t| Description    \t|\n|---------\t|-------------------------------------------------------\t|----------------\t|\n| balance \t| [ethereum_common/UInt256](#ethereum_commonuint256msg) \t| Balance in Wei \t|\n\n## ethereum_common/AccountToAddressAllowance.srv\n\n**Request**\n\n| Field   \t| Type                                                  \t| Description      \t|\n|---------\t|-------------------------------------------------------\t|------------------\t|\n| account \t| [ethereum_common/Address](#ethereum_commonaddressmsg) \t| Ethereum address \t|\n| to      \t| [ethereum_common/Address](#ethereum_commonaddressmsg) \t| Ethereum address \t|\n\n**Response**\n\n| Field  \t| Type                                                  \t| Description   \t|\n|--------\t|-------------------------------------------------------\t|---------------\t|\n| amount \t| [ethereum_common/UInt256](#ethereum_commonuint256msg) \t| Balance in Wn \t|\n\n## ethereum_common/Accounts.srv\n\n**Request**\n\nRequest is empty\n\n**Response**\n\n| Field     | Type                                                      | Description                   |\n|---------- |-------------------------------------------------------    |----------------------------   |\n| accounts  | [ethereum_common/Address[]](#ethereum_commonaddressmsg)     | List of available accounts    |\n\n## ethereum_common/Allowance.srv\n\n**Request**\n\nRequest is empty\n\n**Response**\n\n| Field     | Type                                                      | Description                                       |\n|--------   |-------------------------------------------------------    |-----------------------------------------------    |\n| amount    | [ethereum_common/UInt256](#ethereum_commonuint256msg)     | Amount of XRT the Factory is allowed to spend     |\n\n## ethereum_common/Approve.srv\n\n**Request**\n\n| Field     | Type                                                      | Description                   |\n|---------  |-------------------------------------------------------    |-----------------------------  |\n| spender   | [ethereum_common/Address](#ethereum_commonaddressmsg)     | Who is allowed to spend       |\n| value     | [ethereum_common/UInt256](#ethereum_commonuint256msg)     | How much tokens are allowed   |\n\n**Response**\n\n| Field     | Type                  | Description       |\n|--------   |--------------------   |------------------ |\n| txhash    | std_msgs/Uint8[32]    | Transaction hash  |\n\n## ethereum_common/Balance.srv\n\n**Request**\n\nRequest is empty\n\n**Response**\n\n| Field     | Type                                                      | Description                       |\n|---------  |-------------------------------------------------------    |--------------------------------   |\n| balance   | [ethereum_common/UInt256](#ethereum_commonuint256msg)     | The balance of default account    |\n\n## ethereum_common/BlockNumber.srv\n\n**Request**\n\nRequest is empty\n\n**Response**\n\n| Field     | Type              | Description           |\n|--------   |-----------------  |---------------------- |\n| number    | std_msgs/Uint64   | Current block number  |\n\n## ethereum_common/Transfer.srv\n\n**Request**\n\n| Field     | Type                                                      | Description           |\n|-------    |-------------------------------------------------------    |---------------------- |\n| to        | [ethereum_common/Address](#ethereum_commonaddressmsg)     | Ethereum address      |\n| value     | [ethereum_common/UInt256](#ethereum_commonuint256msg)     | The amount of tokens  |\n\n**Response**\n\n| Field     | Type                  | Description       |\n|--------   |--------------------   |------------------ |\n| txhash    | std_msgs/Uint8[32]    | Transaction hash  |\n\n## ethereum_common/TransferFrom.srv\n\n**Request**\n\n| Field     | Type                                                      | Description           |\n|-------    |-------------------------------------------------------    |---------------------- |\n| owner     | [ethereum_common/Address](#ethereum_commonaddressmsg)     | Owner's address       |\n| to        | [ethereum_common/Address](#ethereum_commonaddressmsg)     | Another account       |\n| value     | [ethereum_common/UInt256](#ethereum_commonuint256msg)     | The amount of tokens  |\n\n**Response**\n\n| Field     | Type                  | Description       |\n|--------   |--------------------   |------------------ |\n| txhash    | std_msgs/Uint8[32]    | Transaction hash  |\n"}},{node:{id:"f7b2d922a0cdf138a9c424b405a5b589",title:"Как редактировать Вики",path:"/docs/ru/edit-wiki/",content:'\n**Робономика – это набор репозиториев с открытым программным кодом. Корневая команда разработчиков приветствует любые правки со стороны сообщества: исправление багов, опечаток, неясной или устаревшей информации, перевод на любые языки. Вам понадобится аккаунт [GitHub](https://github.com/).**\n\n## Правка уже существующего документа\n\n1. Выберите страницу для редактирования\n2. Нажмите на кнопку "Редактировать страницу"\n3. Вас переведет на страницу GitHub репозитория, а именно страницу нужного .md файла.\n4. При редактировании придерживайтесь общих правил разметки [Markdown](https://ru.wikipedia.org/wiki/Markdown) с учётом некоторых особенностей стека Вики:\n\n### Метаданные\nНекоторые сведения о странице в документации указываются в блоке метаданных. Этот блок должен быть расположен вверху markdown файла, использовать корректный синтаксис YAML и ограничен разделителем (---). Вы можете указать следующие параметры:\n\n```YAML\n---\ntitle: How to contribute # Заголовок статьи. Заголовок не нужно дублировать в тексте статьи\ncontributors: [positivecrash] # Основные контрибьюторы (добавляются вручную, исходя из внесенного вклада). Нужно указывать свой Github ник без доп символов\ntranslated: true # "true" если страница переведена на текущий язык (ориентируйтесь на название папки локали, содержащей .md файл)\n---\n```\n\n### YouTube видео\nВ документацию можно встраивать YouTube видео без дополнительной разметки, вставив ссылку на видео. Например: `https://youtu.be/kQaSwNYHJQ8`\n\n### Asciinema\nВики Робономики поддерживает встраивание Asciinema. Для этого ознакомьтесь, пожалуйста, со следующей инструкцией:\n* Импортируйте компонент сразу после блока метаданных сверху `import Asciinema from \'~/components/Asciinema.vue\'`\n* Вставьте как отдельный параграф `<Asciinema vid="WCFcx8C6M8e52UKDNei1xZloU"/>`, где vid это ID вашего аскикаста.\n\n> You can get the widget script for a specific asciicast by clicking on “Embed” link on asciicast page.\n> It looks like this:\n> `<script src="https://asciinema.org/a/14.js" id="asciicast-14" async><\/script>`\n[Документация Asciinema](https://asciinema.org/docs/embedding)\n\nВ этом примере vid равно 14.\n\n## Добавление нового документа\n\nЕсли вы хотите добавить новый документ в Вики Робономики:\n\n1. Найдите папку с локалью, соответствующей языку добавляемой статьи, например `/docs/ru/`\n2. Создайте файл .md, используя в имени латинские символы и следуйте общим правилам для [структуры url](https://developers.google.com/search/docs/advanced/guidelines/url-structure)\n3. Заполните файл, придерживаясь рекомендаций выше\n4. Продублируйте созданный файл в папки с другими локалями, даже если вы не планируете переводить документ на другие языки. Не забудьте в неперееденных документах поставить параметр `translated: false`\n5. Добавьте документ в меню:\n* Откройте файл `/data/sidebar_docs.yaml`\n* Выберите место размещения ссылки\n* Если вы хотите создать новый раздел, то напишите только заголовок без ссылки\n* Добавляйте заголовки только с локалью, для которого есть перевод страницы. Если заголовок указывается для названия раздела, то правило такое: указываем названия только на тех языках, для которых есть хотя бы одна переведенная статья в разделе.\n* Для документа добавьте ещё и ссылку. Ссылка должна быть одна для всех языков и не должна содержать код языка. Правильно: `/docs/url-of-your-doc`, неправильно: `/docs/en/url-of-your-doc`\n* Для работы с `/data/sidebar_docs.yaml` используйте корректный синтаксис YAML и ориентируйтесь на существующую структуру документа\n\n## Отправьте PR\n\nОтправьте PR с соблюдением некоторых принципов, указанных [здесь](/docs/ru/contributing/#создание-pr).'}},{node:{id:"32727d898f8249f20a8d2096cb7a0afb",title:"Cross-chain Message",path:"/docs/ru/cross-chain-messages/",content:"\nXCM (Cross-chain Message) allows sending messages between parachains. You can send launchXcm transaction to run/stop your robot or datalogXcm transaction to save data to blockchain.\n\nhttps://www.youtube.com/watch?v=a6XrqoaYhK8&feature=emb_logo\n\n## Create Account\n\nLets try to send message from Earth to Mars.\nGo to [parachain.robonomics.network](https://parachain.robonomics.network/#/explorer) and choose `Airalab Rococo` testnet:\n\n![testnets](../images/cross-chain/testnet.jpg)\n\nIn `Network/Parachains` you will see two parachains with their id:\n\n![ids](../images/cross-chain/Parachains_id.jpg)\n\nThen go to Earth parachain and [create](https://wiki.robonomics.network/docs/create-account-in-dapp/) two accounts (for example `ROBOT` and `EMPLOYER`). In a new tab go to Mars parachain.\n\n## LaunchXcm\n\nIn Earth parachain go to `Developer/Extrinsics` and choose your `EMPLOYER` account and launchXcm. Then write Mars parachain id (2000) and choose the `ROBOT` account:\n\n![launch](../images/cross-chain/launch.jpg)\n\nNow press `Submit Transaction`.\n\nTo see your transaction in Mars parachain go to `Network/Explorer` and look at Recent Events.\n\n![recent_launch](../images/cross-chain/recent_launch.jpg)\n\n## DatalogXcm\n\nIn Earth parachain go to `Developer/Extrinsics` and choose your `ROBOT` account and datalogXcm. Write Mars parachain id (2000) and the message:\n\n![datalog](../images/cross-chain/datalog.jpg)\n\nNow press `Submit Transaction`.\n\nYou can see your transaction in Recent Events in Mars parachain:\n\n![recent_datalog](../images/cross-chain/recent_datalog.jpg)\n\n\n"}},{node:{id:"b716e6f613b1d1473641f96ebcb7662c",title:"Create digital identity run by Ethereum",path:"/docs/ru/create-digital-identity-run-by-ethereum/",content:'\nOne of the Robonomics services is [Digital Passport Registration](https://dapp.robonomics.network/#/passport/) for arbitrary data. The service allows you to create a digital identity saving the hashes of the data to the public blockchain and assigning a unique address.\n\nYou may find "Digital passport registration" service in [Robonomics DApp](https://dapp.robonomics.network/) in the "Services" section or just follow this [direct link](https://dapp.robonomics.network/#/passport/).\n\n\n## Video walkthrough\n\nThe following video shows a progress of Robonomics Whitepaper registration:\n\nhttps://www.youtube.com/embed/E8R6VbZvf9w\n\n## Step-by-step in pictures\n\n### 1. Open the service\n\n![Digital passport registration applying form](../images/case_digital_passport_1.jpg "Digital passport registration applying form")\n\n### 2. Add necessary information and files\n\nPlease note, it is possible to add multiple images.\n\n![Filled Form](../images/case_digital_passport_2.jpg "Filled Form")\n\n### 3. Sign the demand\n\n![Sign the demand for digital passport creation](../images/case_digital_passport_3.jpg "Sign the demand for digital passport creation")\n\n\n### 4. Approve tokens\n\nThe service charges a small fee. But first you must approve the required amount of tokens to be spent from your account.\n\n![Approve Tokens](../images/case_digital_passport_4.jpg "Approve Tokens")\n\n\n### 5. Accept the offer and sign the message again\n\n![Send Order](../images/case_digital_passport_5.jpg "Send Order")\n\n### 6. Have a look at the created passport\n\n![The Digital Identity](../images/case_digital_passport_6.jpg "The Digital Identity") \n\nThe process of registration takes some time. In the end you will see a link to the created identity.\n'}},{node:{id:"b2ae5b9414ba424ca67c0b26c0b33342",title:"Create an Account on Robonomics Portal",path:"/docs/ru/create-account-in-dapp/",content:'\n**In order to be able to complete all the playground tutorials below, one should have several accounts on Robonomics portal. These accounts do not contain any personal data, neither they are anyhow valuable (if you play on a local dev network or on a self-owned test one). But still their keys, both public and private, are necessary for launching any demo.**\n\n## 1. Choose your network and navigate to Robonomics portal\nGlobally, there are 3 different ways to work with Robonomics:\n- Launch your own local network with [robonomics binary](https://github.com/airalab/robonomics/releases/) by `./robonomics --dev`. This method is used in all playground tutorials. (_tip: to avoid failures on next launches clean chain data by `rm -rf /home/$USER/.local/share/robonomics/chains/dev/db` after each session_)\n- Launch your own test network following [this](/docs/robonomics-test-network-manual/) manual\n- Connect to an existing network on a portal (more information on this below)\n\nRegardless of method chosen, go to [parachain.robonomics.network](https://parachain.robonomics.network) and draw your attention to the top-left corner:\n\n![Portal top-left](../images/creating-an-account/portal-top-left.jpg "Portal top-left")\n\nPress on the current network icon and choose you network:\n- **Development -> Local Node** if you have launched local network\n- **Custom Endpoint -> insert endpoint** if you have created a test network on a remote server\n- **Live Networks** or **Test Networks** if you are operating in a public one\nDon\'t forget to press `Switch` button to confirm network choice. In all the playgrounds we will use local networks.\n\n![Choosing local network](../images/creating-an-account/choosing-local-node.jpg "Choosing local network")\n\n## 2. Create accounts\nNow that you have chosen your network, go to **Accounts -> Accounts** and press `Add account` button\n\n![Accounts page](../images/creating-an-account/accounts-page.jpg "Accounts page")\n\nYou should see the following panel:\n\n![Add account panel](../images/creating-an-account/add-account-panel.jpg "Add account panel")\n\n- *Name* is just you account\'s name in this exact browser. It makes no sense but convenience.\n- *Seed*. Each transaction must be signed by account\'s unique seed. It has two forms: *Mnemonic* (human-readable) and *Raw* (a sequence of digits and letters). Change *Mnemonic* to *Raw* and copy the seed. **It\'s very important to store it somewhere securely** since secret seeds are used for transactions in [Robonomics IO](/docs/rio-overview/) module. If you have created an account before, you can insert its secret seed here to restore its balance and history.\n- *Password* is used to sign transactions on a portal (in GUI). Create one and remember it.\n\nClick `Save`, `Create and backup account`. A downloaded JSON-file is another way to restore account\'s data on the portal.\n\n## 3. Manage your accounts\nNow you can fully operate with your fresh-created account. Send and receive tokens, messages, write datalog and more. You can forget this account for this exact browser by clicking three dots in opposite of your account\'s name and choosing *Forget this account*. Feel free to explore all the features of portal. To copy your account\'s address simply click on its icon, address will be copied to clipboard.\n\n## 4. Some notes before proceeding to playground\nMost of the playground demos require "Control" account and one or several "Worker" accounts. Transfer units to both before starting, since "Control" needs to send "ON"/"OFF" transactions and "Worker" publishes datalog. Also, each "ON"/"OFF" transaction requires target address, so don\'t forget to copy it from the portal.\n'}},{node:{id:"4113122abf080efc4d2720d51b87056c",title:"Как стать контрибьютором",path:"/docs/ru/contributing/",content:"\nРобономика – сеть с открытым программным кодом, которая строится основной командой разаботчиков и активными участниками сообщества. Вы тоже можете принять участие: предлагать изменения как в основной код наших репозиториев, так и улучшать другие материалы, связанные с Робономикой – редактировать документацию, писать собственные туториалы, предлагать изменения в Вики.\n\n## Основные репозитории команды Аиралаб\n\n- [aira](https://github.com/airalab/aira) - AIRA клиент в сети Робономика. \n- [robonomics_comm](https://github.com/airalab/robonomics_comm) - коммуникационный стек в сети Робономика.\n- [robonomics_contracts](https://github.com/airalab/robonomics_contracts) - смарт контракты Робономики.\n\n## Обнаружение багов и предложения по улучшению\n\nЕсли вы нашли баг в клиенте AIRA, репозиториях Робономики, этой документации или хотели бы предложить улучшения, откройте [Issue или сделайте PR](https://docs.github.com/desktop/contributing-and-collaborating-using-github-desktop/creating-an-issue-or-pull-request) в соотвествующем репозитории.\n\n### Правила создания Issue\n\nНе забывайте об общих правилах, когда создаете Issue:\n\n1. Обратите внимание, в том ли репозитории вы публикуете обращение.\n\n2. Если вы сообщаете о баге, убедитесь, что подобного Issue ещё нет.\n\n3. Заполняйте заголовок и описание как можно точнее.\n\n4. Желательно включать в заголовок Issue следующие флаги: [BUG], [PROPOSAL], [QUESTION].\n\n\n## Создание PR\n\nЛюбой репозиторий корневой команды Аиралаб или документация могут быть изменены посредством [PR (Pull Request)](https://docs.github.com/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request) любым участником сообщества. Пожалуйста, не забудьте о простых правилах контрибуции.\n\n### Правила констрибуции в репозиториях\n\n1. Если вы хотели бы предложить небольшие изменения, например такие, как правки опечаток, форматирования, то предпочительнее PR.\n\n2. Понятно опишите проблему и её решение, которое вы предлагаете. При необходимости, можете указать номер Issue.\n\n3. Прежде чем править форматирование, убедитесь, что это действительно нужно.\n\n4. Пожалуйста, постарайтесь придерживаться преобладающего стиля оформления кода и разметки Markdown.\n\n\n"}},{node:{id:"19a438bca3c860db2885746c3416e62a",title:"Connect the simplest CPS",path:"/docs/ru/connect-simple-cps/",content:'\nIn this section we will build the simplest real cyber-physical system!\n\nWe will buy a "wink" from Arduino, e.g. make Arduino blink with its onboard led. The lesson is tested on Arduino Uno, but any other board with a led will do the job.\n\n> The source code of this lesson is [here](https://github.com/airalab/robonomics_tutorials/tree/master/arduino_blink).\n\n## Arduino\n\nThe firmware for the board is located in [arduino_blink/misc/arduino/arduino.ino](https://github.com/airalab/robonomics_tutorials/blob/master/arduino_blink/misc/arduino/arduino.ino). Use [Arduino IDE](https://www.arduino.cc/en/Main/Software) to load the code to your Arduino board.\n\nIn the code we subscribe for the ``/blink_led`` topic and set a callback. The type of the topic is ``Empty``, so the board waits until someone publishes to the topic and performs the LED blinking.\n\n```\n  #include <ros.h>\n  #include <std_msgs/Empty.h>\n\n  ros::NodeHandle  nh;\n\n  void blink(int led, int mil) {\n\n    digitalWrite(led, HIGH);\n    delay(mil);\n    digitalWrite(led, LOW);\n    delay(mil);\n\n  }\n\n  void messageCb( const std_msgs::Empty& toggle_msg){\n    blink(LED_BUILTIN, 500);\n    blink(LED_BUILTIN, 500);\n    blink(LED_BUILTIN, 500);\n  }\n\n  ros::Subscriber<std_msgs::Empty> sub("blink_led", &messageCb );\n\n  void setup()\n  {\n    pinMode(LED_BUILTIN, OUTPUT);\n    nh.initNode();\n    nh.subscribe(sub);\n  }\n\n  void loop()\n  {\n    nh.spinOnce();\n    delay(1);\n  }\n```\n\n\n## AIRA client\n\n> You can download the latest release from [here](https://github.com/airalab/aira/releases).\n\nSet up the COM port forwarding. You should forward your `/dev/ttyUSB0` or `/dev/ttyACM0` port (depending on the system) to `COM1`. In the client `/dev/ttyS0` will represent the board. After this launch the virtual machine.\n\n## ROS\n\nWhen new liability is created it goes to `/liability/ready` topic. We have to remember the address and call `/liability/start` service to get the data from objective.\n\n```\n  def newliability(l):\n    self.liability = l.address\n    rospy.loginfo("Got new liability {}".format(self.liability))\n\n    prefix = "/liability/eth_" + self.liability\n    rospy.Subscriber(prefix + \'/blink\', Empty, self.blink)\n\n    rospy.wait_for_service("/liability/start")\n    rospy.ServiceProxy(\'/liability/start\', StartLiability)(StartLiabilityRequest(address=self.liability))\n  rospy.Subscriber("/liability/ready", Liability, newliability)\n```\n\nA message in the `/blink` topic come from the objective field. Have a look at [Basic usage](/docs/aira-basic-usage) page.\n\n## AIRA\n\nConnect to AIRA client via SSH as described [here](/docs/aira-connecting-via-ssh). All tutorials are pre-installed. To launch the ros package run the following command:\n\n```\n$ rosrun arduino_blink blink.py\n```\n\nAlso we need to add a rosbag file to IPFS::\n\n```\n$ ipfs add rosbag/blink.bag\n```\n\n> Before the next step you should approve XRT tokens on the Factory.\n\nOn your host system build and launch an Dapp for the lesson:\n\n```\n$ git clone https://github.com/airalab/robonomics_tutorials/\n$ cd robonomics_tutorials/arduino_blink_dapp\n$ npm i && npm run dev\n```\n\nOpen [http://localhost:8000/](http://localhost:8000/) and press "Demand" then "Offer" buttons. Wait until a new liability is created and you should see the board blinking. Congratulations on the first agent!\n'}},{node:{id:"c7eddb3f26c1e15b7e1d2f8382b21c23",title:"Connect Sensor To Robonomics Network",path:"/docs/ru/connect-sensor-to-robonomics/",content:'\n## Requiremets\n* ESP8266 Node MCU v3\n* particle sensor SDS011\n* micro USB cable\n* connecting wires\n\n## Assembling\n### Connection Diagram\n\n![scheme](../images/sensors-connectivity/schema.jpg)\n\n### Connecting SDS011\n\n* Pin 1 (TX) -> (RX) Pin D1 (GPIO5)\n* Pin 2 (RX) -> (TX) Pin D2 (GPIO4)\n* Pin 3 (GND) -> GND\n* Pin 4 (2.5m) -> unused\n* Pin 5 (5V) -> VU\n* Pin 6 (1m) -> unused\n\nSensor is shipped with a USB adapter and connection wires. You don\'t need USB adapter, so disconnect wires from it.\n\n![disconnect](../images/sensors-connectivity/2_assembly_usb.jpg)\n\nYou may connect it to ESP via connecting wires "Female-Male":\n\n![f-m](../images/sensors-connectivity/3_conn.jpg)\n\nAnd connect them to your ESP according to the connection diagram.\n\nOr you can use wires from USB adapter. Disconnect one wire: push on it with some sharp object and carefully pull the wire:\n\n![extreme_con](../images/sensors-connectivity/4_assembly_wires.jpg)\n\nInsert it to last connector:\n\n![extr](../images/sensors-connectivity/5_wires1.jpg)\n\nThen cut the connector in the middle:\n\n![cut](../images/sensors-connectivity/6_assembly_wires2.jpg)\n\nAnd connect them to ESP according to the diagram:\n\n![esp_con](../images/sensors-connectivity/6_esp_con.jpg)\n\n### Connecting DHT22\n\n\n* Pin 1 => 3V3\n* Pin 2 => Pin D7 (GPIO13)\n* Pin 3 => unused\n* Pin 4 => GND\n\n### Connecting BME280/HTU21D\n\n* VCC -> Pin 3V3\n* GND -> Pin GND\n* SCL -> Pin D4 (GPIO2)\n* SDA -> Pin D3 (GPIO0)\n\n\n## Device Firmware\nDownload `airrohr-flasher` from the [latest release](https://github.com/airalab/sensors-connectivity/releases) for your OS. \nConnect ESP to computer via micro-USB and run flasher. \n\n### For Linux:\nFirstly you need to add the user to `dialout` group:\n```bash\nsudo usermod -a -G dialout $USER\n```\nThen logout and login or restart computer.\n\nNow you can run flasher (don\'t forget to give it permission to execute):\n```bash\nchmod +x airrohr-flasher-linux\n./airrohr-flasher-linux\n```\n\n### For Windows:\nUnpack flasher and run it with double click.\nYou need to install drivers for the USB2serial chipset (Windows 10 should be able to automatically download these):\n\n* Drivers for NodeMCU v3 (CH340): [Windows](http://www.wch.cn/downloads/file/5.html) ([2018/09/04 v3.4 mirror](https://d.inf.re/luftdaten/CH341SER.ZIP))\n\n\n### For MacOS\nDownload flasher and run it.\nYou need to install drivers for the USB2serial chipset: \n* Drivers for NodeMCU v3 (CH340): [MacOS](http://www.wch.cn/downloads/file/178.html) ([2018/09/04 v1.4 mirror](https://d.inf.re/luftdaten/CH341SER_MAC.ZIP))\n\n\nChoose firmware (English or Russian) and press upload. It will take a few minutes.\n\n![flasher](../images/sensors-connectivity/7_flasher.jpg)\n\n\n## Configuration\nReboot your ESP (simply reconnect USB to computer).\nThen connect to airRohr--xxxxxxx Wi-Fi network and in your browser write address 192.168.4.1:\n\n![menu](../images/sensors-connectivity/8_menu1.jpg)\n\nGo to Configuration -> Wi-Fi Settings and add the information about your Wi-Fi network:\n\n![config](../images/sensors-connectivity/9_W-fi.jpg)\n\nThen press "Save configuration and restart" and ESP will be connected to the provided Wi-Fi network.\n\n![save](../images/sensors-connectivity/10_save.jpg)\n\n\nThen find ESP in local network (for that your computer and ESP must be in one network). You can do it using airrohr-flasher. Run it, go to the Discovery tab and press Refresh, then you\'ll be able to see the address.\n\n![addr](../images/sensors-connectivity/11_flaser2.jpg)\n\n\n\nOpen ESP local address in your browser, go to `APIs` tab in  `Configuration` and click `Robonomics`. \n\n![robonomics](../images/sensors-connectivity/12_APIrobonomics.jpg)\n\n> If you want to send data to your own server, enable `Custom API` and write your address and port \n\nThen go to `Sensors` tab, enable GPS and put in your coordinates. Also enable the sensors you connected:\n\n![gps](../images/sensors-connectivity/13_gps.jpg)\n\nThen press `Save configuration and restart`.\n\n\n\n## Results\nGo to [sensors.robonomics.network](https://sensors.robonomics.network/#/), and you will see your sensor on the map.\n\n![map](../images/sensors-connectivity/14_map.jpg)\n'}},{node:{id:"014c142832f57f070a312aabee48621b",title:"Connect Mars Curiosity rover under Robonomics parachain control",path:"/docs/ru/connect-mars-curiosity-rover-under-robonomics-parachain-control/",content:'\n**Let\'s see how Robonomics Parachain control allows to make Mars Curiosity rover move. Requirements:**\n- Ubuntu 18.04 LTS\n- ROS Melodic + Gazebo + RViz (installation manual [here](http://wiki.ros.org/melodic/Installation))\n- extra packages:\n```shell\nsudo apt-get install ros-melodic-gazebo-ros-control ros-melodic-effort-controllers ros-melodic-joint-state-controller\n```\n- IPFS 0.4.22 (download from [here](https://dist.ipfs.io/go-ipfs/v0.4.22/go-ipfs_v0.4.22_linux-386.tar.gz) and install)\n- Python dependencies:\n```\npip install ipfshttpclient\n```\n- Robonomics node (binary file) (download latest release [here](https://github.com/airalab/robonomics/releases))\n- IPFS browser extension (optional)\n\nHere is the video showing successful launch:\n\nhttps://youtu.be/pl3eIEC_T2o\n\n## 1. Set up a simulation\nDownload Curiosity rover package:\n```\nmkdir -p robonomics_ws/src\ncd robonomics_ws/src\ngit clone https://bitbucket.org/theconstructcore/curiosity_mars_rover/src/master/\ncd ..\n```\nWe need to adjust starting conditions to make our rover spawn smoothly:\n- Go to\n\n`/robonomics_ws/src/master/curiosity_mars_rover_description/worlds` and change line 14 of the file` mars_curiosity.world` to\n`<pose>0 0 9 0 0 0</pose>`.\n\n- Go to\n\n`/robonomics_ws/src/master/curiosity_mars_rover_description/launch` and change line 4 of the file `mars_curiosity_world.launch` to\n`<arg name="paused" default="false"/>`.\n\nDon’t forget to add source command to `~/.bashrc`:\n```\necho "source /home/$USER/robonomics_ws/devel/setup.bash" >> ~/.bashrc\n```\n\n## 2. Download controller package\nIn terminal do the following. This will download a sample script used in the demo:\n```\ncd ~/robonomics_ws/src\ngit clone https://github.com/PaTara43/robonomics_sample_controller\ncd ../..\ncatkin build\n```\n\n## 3. Manage accounts in DAPP\nSince we are testing, let\'s create a local robonomics network node with robonomics binary file:\n```\n./robonomics --dev --rpc-cors all\n```\n**Important!** Before next launches it is necessary to remove a directory `db` with\n\n```\nrm -rf /home/$USER/.local/share/robonomics/chains/dev/db\n```\n\nAfter a successful launch create accounts for the rover and for it\'s employer following [this](/docs/create-account-in-dapp) manual. **Do not forget to save each account\'s seed (RAW SEED) and address! You will need them for transactions**. Add these addresses, seeds and path to robonomics binary file to file `config.config` in `robonomics_ws/src/robonomics_sample_controller/src`. Transfer some money (units) to these accounts:\n\n![Config](../images/curiosity-demo/config.jpg "Config")\n\n![Balances](../images/curiosity-demo/balances.jpg "Balances")\n\n## 4. Start Robonomics\nUp to now the **only thing running** should be the robonomics local node.\nIn a separate terminal launch IPFS:\n```\nipfs init # you only need to do this once\nipfs daemon\n```\nIn another separate terminal launch Curiosity simulation:\n```\nroslaunch curiosity_mars_rover_description main_real_mars.launch\n```\nWait till it stays still and after that in another terminal launch the controller:\n```\nrosrun robonomics_sample_controller sample_controller.py\n```\n\n![Curiosity](../images/curiosity-demo/curiosity.jpg "Curiosity")\n\nNow you can send a transaction triggering the Rover to start moving and collecting data. To do so, you should use the [Robonomics IO](https://wiki.robonomics.network/docs/rio-overview/)  `write` subcommand of robonomics binary file:\n```\necho "ON" | ./robonomics io write launch -r <CURIOSITY ADDRESS> -s <EMPLOYER’S KEY>\n```\nWhere `<CURIOSITY ADDRESS>`  and `<EMPLOYER’S KEY>` are replaced with  previously saved strings accordingly.\nYou should see the log `"Arming..."` and the robot should start moving its camera and arm. Later, when the job is done (there is a log informing user when the program has finished), on the Robonomics portal go to `Developer` -> `Chain state` and add a CURIOSITY datalog using `“+”` button with selected `datalog` as state query:\n\n![Datalog](../images/curiosity-demo/hash_in_chain.jpg "Datalog")\n\nThe IPFS hash of the telemetry has been saved in the blockchain. To see the data simply copy the hash and add it to the local [gateway](https://gateway.ipfs.io/ipfs/QmeYYwD4y4DgVVdAzhT7wW5vrvmbKPQj8wcV2pAzjbj886/docs/getting-started/) address `localhost:8080/ipfs/`:\n\n![Voila](../images/curiosity-demo/datalog.jpg "Voila")\n\n## Troubleshooting\n\nIf due to some reason addresses in IO module and on the portal are displayed unequally (e.g. `5...` and `4...`) and the program outputs "Not my job is paid", fill in configuration file with address of the same type as in IO module.\n'}},{node:{id:"782010570441ea15a0e42841a41fd279",title:"Connect any ROS-compatitable robot under Robonomics parachain control. Part 2, IPFS",path:"/docs/ru/connect-any-ros-compatitable-robot-under-robonomics-parachain-control-2/",content:'\n**In this article we will continue using Robonomics tools to make a drone be controlled by a parachain. This time we will add sending data to IPFS and hash storing in chain options. Below is the instruction and code snippets. Requirements:**\n- [**Part 1 of this tutorial**](/docs/connect-any-ros-compatitable-robot-under-robonomics-parachain-control-1)\n- Ubuntu 18.04 LTS\n- ROS Melodic + Gazebo + RViz (installation manual [here](http://wiki.ros.org/melodic/Installation))\n- IPFS 0.4.22 (download from [here](https://dist.ipfs.io/go-ipfs/v0.4.22/go-ipfs_v0.4.22_linux-386.tar.gz) and install)\n- Robonomics node (binary file) (download latest release [here](https://github.com/airalab/robonomics/releases))\n- Python dependencies:\n```\npip install cv_bridge ipfshttpclient\n```\nThe entire process of coding this part of demo is presented in a video below.\n\nhttps://www.youtube.com/watch?v=dliLb6GHgpo&feature=youtu.be\n\n\n## 1. Add dependencies\nIf we launch a simulation and look at the topic list (see previous tutorial), we will see, that there is one topic containing front camera data and using `sensor_msgs/Image` message type:\n\n![front_camera](../images/drone-demo/front_camera.jpg "front_camera")\n\nLet\'s try to take a picture every 1 second and after the flight publish these photos to IPFS. If you have completed the first tutorial, you don\'t need to download anything else. It\'s the `drone_sample_controller_pictures.py` script.\n## 2. Manage accounts in DAPP\nAs done in a previous tutorial, create a local robonomics network node with robonomics binary file:\n```\n./robonomics --dev\n```\n**Important!** Before next launches it is necessary to remove a directory `db` with\n```\nrm -rf /home/$USER/.local/share/robonomics/chains/dev/db\n```\nAfter a successful launch create accounts following [this](/docs/create-account-in-dapp) manual. **Do not forget to save each account\'s seed and address! You will need them for transactions**. Add these addresses, seeds and path to robonomics binary file to file `config.config` in `robonomics_ws/src/robonomics_sample_controller/src`. Transfer some money (units) to these accounts:\n\n![balances](../images/drone-demo/balances.jpg "balances")\n## 3. Launch\nUp to now the **only thing running** should be the robonomics local node. In a separate terminal launch drone simulation:\n```\nroslaunch sjtu_drone simple.launch\n```\nIn another one launch ipfs daemon:\n```\nifps init # you only need to do this once\nipfs daemon\n```\nRun the script:\n```\nrosrun drone_simulator_controller drone_sample_controller_pictures.py\n```\nNow you can send a transaction triggering the drone to start flying and taking pictures. To do so, you should use the Robonomics IO `write` subcommand of robonomics binary file:\n```\necho "ON" | ./robonomics io write launch -r <DRONE_ADDRESS> -s <EMPLOYER’S_KEY>\n```\nWhere `<DRONE_ADDRESS>`  and `<EMPLOYER’S_KEY>` are replaced with  previously saved strings accordingly.\nYou should see the log `"Taking Off"` and the drone should start flying and taking pictures:\n\n![flying_picturing](../images/drone-demo/flying_picturing.jpg "flying_picturing")\n\nLater, when the job is done, on the Robonomics portal go to `Developer` -> `Chain state` and add a `DRONE` datalog using `“+”` button with selected `datalog` as state query. The IPFS hash of the telemetry has been saved in the blockchain. To see the data simply copy the hash and add it to the local [gateway](https://gateway.ipfs.io/ipfs/QmeYYwD4y4DgVVdAzhT7wW5vrvmbKPQj8wcV2pAzjbj886/docs/getting-started/) address `localhost:8080/ipfs/`:\n\n![Voila](../images/drone-demo/datalog.jpg "Voila")\n'}},{node:{id:"e696b9631fc5682156120e64af456a01",title:"Connect ROS-compatibale Drone To Robonomics Parachain. Part 1. Launch by Transaction",path:"/docs/ru/connect-any-ros-compatitable-robot-under-robonomics-parachain-control-1/",content:'\n**In this article we will show that with the help of Robonomics tools you can control any ROS-compatitable device. We will find a random drone simulation package on the web and adjust it to run with Robonomics.**\n**Requirements:**\n- Ubuntu 18.04 LTS\n- ROS Melodic + Gazebo + RViz (installation manual [here](http://wiki.ros.org/melodic/Installation))\n- Robonomics node (binary file) (download latest release [here](https://github.com/airalab/robonomics/releases))\n\nThe entire process of coding this part of demo is presented in a video below.\n\nhttps://www.youtube.com/watch?v=fDpwhBasQ5o&feature=youtu.be\n\n## 1. Find a simulation\nLet\'s surf the web. Google for `ROS drone simulator`. The first link will mostly likely show you the `tum_simulator` page on [http://wiki.ros.org/tum_simulator](http://wiki.ros.org/tum_simulator)\n\n![tum_simulator](../images/drone-demo/tum_simulator.jpg "tum_simulator")\n\nIt\'s pretty outdated, so we better find a fork for our system. Google for `tum_simulator Ubuntu 18 Gazebo 9 fork`. The first result is a GitHub [repo](https://github.com/tahsinkose/sjtu-drone) with an appropriate package. Dowload it\n```\nmkdir -p drone_simulator_ws/src\ncd drone_simulator_ws/src\ngit clone https://github.com/tahsinkose/sjtu-drone\ncd ..\ncatkin build\n```\nDon’t forget to add source command to `~/.bashrc`:\n```\necho "source /home/$USER/drone_simulator_ws/devel/setup.bash" >> ~/.bashrc\nsource "~/.bashrc"\n```\nNow we can run the simulation to see what do we need to do to take the drone under parachain control.\n```\nroslaunch sjtu_drone simple.launch\n```\n\n## 2. Inspect ROS topics\nWhen the simulation is runnung, in a new tab run the following command to see the list of topics used by the drone:\n```\nrostopic list\n```\nLet\'s take a look at `/cmd_vel`, `/drone/takeoff` and `/drone/land`:\n```\nrostopic info /cmd_vel\nrostopic info /drone/takeoff\nrostopic info /drone/land\n```\n\n![topics_info](../images/drone-demo/topics_info.jpg "topics_info")\n\nAs may be seen, there should be messages of `Twist` and `Empty` types, they are parts of `std_msgs` and `geometry_msgs`, we\'ll use this in the controller. Shut the simulation for a while.\n## 3. Download controller package\nGlobally, the main difference from the casual ROS robot controller is a block of code, which checks all the transactions in the network using [Robonomics IO](https://wiki.robonomics.network/docs/rio-overview/). The package itself is available on GitHub. Download it and build the workspace:\n```\ncd ~/drone_simulator_ws/src\ngit clone https://github.com/PaTara43/drone_simulator_controller\ncd drone_simulator_controller/src\nchmod +x *.py\ncd ~/drone_simulator_ws/src\ncatkin build\n```\n## 4. Manage accounts in DAPP\nSince we are testing, let\'s create a local robonomics network node with robonomics binary file:\n```\n./robonomics --dev\n```\n**Important!** Before next launches it is necessary to remove a directory `db` with\n\n```\nrm -rf /home/$USER/.local/share/robonomics/chains/dev/db\n```\nAfter a successful launch create accounts following [this](/docs/create-account-in-dapp) manual. **Do not forget to save each account\'s seed and address! You will need them for transactions**. Add these addresses, seeds and path to robonomics binary file to file `config.config` in `robonomics_ws/src/robonomics_sample_controller/src`. Transfer some money (units) to these accounts:\n\n![balances](../images/drone-demo/balances.jpg "balances")\n## 5. Launching the drone under parachain control\nUp to now the **only thing running** should be the robonomics local node. In a separate terminal launch drone simulation:\n```\nroslaunch sjtu_drone simple.launch\n```\nRun the script:\n```\nrosrun drone_simulator_controller drone_sample_controller.py\n```\n\n![launched_drone](../images/drone-demo/launched_drone.jpg "launched_drone")\n\nNow you can send a transaction triggering the drone to start flying. To do so, you should use the Robonomics IO `write` subcommand of robonomics binary file:\n```\necho "ON" | ./robonomics io write launch -r <DRONE_ADDRESS> -s <EMPLOYER’S_KEY>\n```\nWhere `<DRONE_ADDRESS>`  and `<EMPLOYER’S_KEY>` are replaced with  previously saved strings accordingly.\nYou should see the log `"Taking Off"` and the drone should start flying:\n\n![flying](../images/drone-demo/flying.jpg "flying")\n\nThat\'s how any ROS-compatitable robot can be controlled by Robonomics parachain control. Proceed to [part 2](/docs/connect-any-ros-compatitable-robot-under-robonomics-parachain-control-2) to learn more\n'}},{node:{id:"bc82c01b7a4e599133a92df5625ef3ea",title:"Configuration Options Description",path:"/docs/ru/configuration-options-description/",content:'\nBasically, you can think of the package as a black box with one input (sensor data) and many outputs.\nFor now only SDS011 sensor is supported, but if you are familiar with Python it\'d be easy to add other sensors as well.\n\nHave a look at [configuration](https://github.com/airalab/sensors-connectivity/blob/master/config/default.json) file:\n\n```json\n{\n   "general":{\n      "publish_interval":30\n   },\n   "comstation":{\n      "enable":false,\n      "port":"/dev/ttyUSB0",\n      "work_period":300,\n      "geo":"",\n      "public_key":""\n   },\n   "httpstation":{\n      "enable":true,\n      "port":8001\n   },\n   "mqttstation": {\n      "enable": true,\n      "host": "connectivity.robonomics.network",\n      "port": 1883\n   },\n   "luftdaten":{\n      "enable":true\n   },\n   "robonomics":{\n      "enable":true,\n      "ipfs_provider":"/ip4/127.0.0.1/tcp/5001/http",\n      "ipfs_topic":"airalab.lighthouse.5.robonomics.eth"\n   },\n   "datalog":{\n      "enable":false,\n      "path":"",\n      "suri":"",\n      "remote":"wss://substrate.ipci.io",\n      "dump_interval":3600,\n      "temporal_username":"",\n      "temporal_password":""\n   },\n   "dev":{\n      "sentry":""\n   }\n}\n```\nAt the moment it\'s possible to publish data to [Luftdaten](https://luftdaten.info/), [Robonomics Network](https://robonomics.network/) and [Datalog](https://github.com/airalab/robonomics).\nThe last one is experimental!\n\n> DO NOT edit `config/default.json` file. Instead make a copy\n\nPlay around with the configuration!\n\nExplanation of options:\n\n| Field                         | Description                                                                                                                                                                                                                                           |\n|------------------------------    |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------    |\n| `general/publish_interval`         | integer number from 1 and above. Tells how often send measurements. Keep in mind that if measurements from sensors come less often than this number connectivity sends last data      |\n| `comstation/enable`                | true/false. Enabling/disabling the station      |\n| `comstation/port`                  | valid path to com port, for example `/dev/ttyUSB0`. It is where a sensor is connected to      |\n| `comstation/work_period`           | integer from 0 to 1800. For SDS011 sensor 0 means continuous work. Recommended period is 300 seconds     |\n| `comstation/geo`                   | `lat,lon` a string with two floats separated by a comma. It represents latitude and longitude of a sensor     |\n| `comstation/public_key`            | Ed25519 verifying key in hex format. If not provided connectivity generates a new one      |\n| `httpstation/enable`                | true/false. Enabling/disabling the station   |\n| `httpstation/port`                  | what port listen to      |\n| `mqttstation/enable`                | true/false. Enabling/disabling the station   |\n|`mqttstation/host`                   | the hostname or IP address of the remote broker |\n|`mqttstation/port`                   | the network port of the server host to connect to |\n| `luftdaten/enable`                 | true/false. Whether or not publish data to [Luftdaten](https://devices.sensor.community/). Don\'t forget to register the sensor\'s mac address on the site         |\n| `robonomics/enable`                | true/false. Whether or not publish data to IPFS topic according to Robonomics communication protocol      |\n| `robonomics/ipfs_proveder`         | an endpoint for IPFS daemon. By default it\'s `/ip4/127.0.0.1/tcp/5001/http` that means local daemon. The endpoint must by in multiaddr format. For example for [Infura.io](https://infura.io/) it would be `/dns/ipfs.infura.io/tcp/5001/https`       |\n| `robonomics/ipfs_topic`            | IPFS topic\'s name. If you want to use [DApp](https://sensors.robonomics.network) provided by Robonomics team leave it untouched                 |\n| `datalog/enable`                   | true/false. Enable/Disable saving log to [Robonomics on Substrate chain](https://ui.ipci.io/)    |\n| `datalog/path`                     | full path to `robonomics` executable file. You can find the latest release on [this](https://github.com/airalab/robonomics/releases) page  |\n| `datalog/suri`                     | a private key from substrate chain account  |\n| `datalog/remote`                   | an endpoint to substrate instance                                                           |\n| `datalog/dump_interval`            | specify a period of time for collecting log in seconds                                      |\n| `datalog/temporal_username`        | set username to upload files to [Temporal.Cloud](https://temporal.cloud/) (Optional)                  |\n| `detalog/temporal_password`        | set password to upload files to [Temporal.Cloud](https://temporal.cloud/) (Optional)                  |\n| `dev/sentry`                       | for development purpose. If you have a [Sentry.io](https://sentry.io/) account you can put sentry\'s credentials in here   |\n\n## Scenario #1: Connect SDS011 to serial port\n\nThe easiest and the most straightforward way to connect your sensor to the network is using the serial port\n\nConnect you SDS011 sensor to a USB port, let\'s assume it got `/dev/ttyUSB0` address\n\n```json\n{\n   "general":{\n      "publish_interval":30            \n   },\n   "comstation":{\n      "enable":true,\n      "port":"/dev/ttyUSB0",\n      "work_period":300,\n      "geo":"59.944954,30.294534",\n      "public_key":""\n   },\n   "httpstation":{\n      "enable":false,\n      "port":8001\n   },\n   "luftdaten":{\n      "enable":true\n   },\n   "robonomics":{\n      "enable":true,\n      "ipfs_provider":"/ip4/127.0.0.1/tcp/5001/http",\n      "ipfs_topic":"airalab.lighthouse.5.robonomics.eth"\n   },\n   "datalog":{\n      "enable":false,\n      "path":"",\n      "suri":"",\n      "remote":"wss://substrate.ipci.io",\n      "dump_interval":3600,\n      "temporal_username":"",\n      "temporal_password":""\n   },\n   "dev":{\n      "sentry":""\n   }\n}\n```\n\n## Scenario #2: Connect SDS011 via HTTP\n\n### Connectivity Configuration\n\n```json\n{\n   "general":{\n      "publish_interval":30            \n   },\n   "comstation":{\n      "enable":false,\n      "port":"/dev/ttyUSB0",\n      "work_period":300,\n      "geo":"59.944954,30.294534",\n      "public_key":""\n   },\n   "httpstation":{\n      "enable":true,\n      "port":8001\n   },\n   "luftdaten":{\n      "enable":true\n   },\n   "robonomics":{\n      "enable":true,\n      "ipfs_provider":"/ip4/127.0.0.1/tcp/5001/http",\n      "ipfs_topic":"airalab.lighthouse.5.robonomics.eth"\n   },\n   "datalog":{\n      "enable":false,\n      "path":"",\n      "suri":"",\n      "remote":"wss://substrate.ipci.io",\n      "dump_interval":3600,\n      "temporal_username":"",\n      "temporal_password":""\n   },\n   "dev":{\n      "sentry":""\n   }\n}\n```\n\n> Do not forget to open the port in system firewall\n>\n> On NixOS you can do:\n> ```\n> networking.firewall.allowedTCPPorts = [ 31313 ];\n> ```\n\n## Scenario #3: Connect SDS011 via MQTT\n\n### Connectivity Configuration\n\n```json\n{\n   "general":{\n      "publish_interval":30\n   },\n   "comstation":{\n      "enable":false,\n      "port":"/dev/ttyUSB0",\n      "work_period":300,\n      "geo":"",\n      "public_key":""\n   },\n   "httpstation":{\n      "enable":true,\n      "port":8001\n   },\n   "mqttstation": {\n      "enable": true,\n      "host": "connectivity.robonomics.network",\n      "port": 1883\n   },\n   "luftdaten":{\n      "enable":true\n   },\n   "robonomics":{\n      "enable":true,\n      "ipfs_provider":"/ip4/127.0.0.1/tcp/5001/http",\n      "ipfs_topic":"airalab.lighthouse.5.robonomics.eth"\n   },\n   "datalog":{\n      "enable":false,\n      "path":"",\n      "suri":"",\n      "remote":"wss://substrate.ipci.io",\n      "dump_interval":3600,\n      "temporal_username":"",\n      "temporal_password":""\n   },\n   "dev":{\n      "sentry":""\n   }\n}\n```\n\n## Scenario #4: Connect Multiple Sensors and Publish to Datalog\n\n### Install Robonomics\n\nFrom `root` user do:\n\n```\necho "https://github.com/airalab/airapkgs/archive/nixos-unstable.tar.gz nixos" > /root/.nix-channels\nnix-channel --update\n```\n\nThen edit `/etc/nixos/configuration.nix` and add:\n\n```\n...\n  environment.systemPackages = with pkgs; [\n        substrate-node-robonomics-bin\n  ];\n...\n```\n\nRun rebuild and find out where `robonomics` is:\n```\nnixos-rebuild switch\nwhereis robonomics\n```\n\nLet\'s assume you got the following path: `/nix/store/2gz2ik17w5xad8w819bsb05a23pbjbya-system-path/bin/robonomics`\n\n### Configuration\n\n```json\n{\n   "general":{\n      "publish_interval":30            \n   },\n   "comstation":{\n      "enable":false,\n      "port":"/dev/ttyUSB0",\n      "work_period":300,\n      "geo":"59.944954,30.294534",\n      "public_key":""\n   },\n   "httpstation":{\n      "enable":true,\n      "port":8001\n   },\n   "luftdaten":{\n      "enable":true\n   },\n   "robonomics":{\n      "enable":true,\n      "ipfs_provider":"/ip4/127.0.0.1/tcp/5001/http",\n      "ipfs_topic":"airalab.lighthouse.5.robonomics.eth"\n   },\n   "datalog":{\n      "enable":true,\n      "path":"/nix/store/2gz2ik17w5xad8w819bsb05a23pbjbya-system-path/bin/robonomics",\n      "suri":"0x...",\n      "remote":"wss://substrate.ipci.io",\n      "dump_interval":3600,\n      "temporal_username":"temporaluser",\n      "temporal_password":"temporalpass"\n   },\n   "dev":{\n      "sentry":""\n   }\n}\n```\n\n\n'}},{node:{id:"6d4cdad1623c3fa47063e2a1f9eab850",title:"Community",path:"/docs/ru/community/",content:"\n**Here you can learn how to get involved in the Robonomics Network Community.**\n\nThere are many ways to contribute to Robonomics Network: you can contribute directly based on your skills and professional background, you can attend an event, join the conversation online or watch for our latest news and release.\n\n## For Developers\n\n- [Robonomics' code base and new releases on GitHub](https://github.com/airalab)\n- [Ask your technical question on Riot](https://riot.im/app/#/room/#robonomics:matrix.org)\n\n## For Researchers & Academics\n\n- [Read Robonomics White Paper and our scientific articles](https://robonomics.network/community/#science)\n\nIf you have a background in mathematics, cryptography, or economics you might be interested for collaboration with us, write us to [research@aira.life](mailto:research@aira.life)\n\n## For All, even non-technical\n\n- [Get familiar with Robonomics services and statistics in dApp - open in browser with Metamask](https://dapp.robonomics.network)\n- [Read our blog](https://blog.aira.life)\n- [Stay tuned by following us on Twitter](https://twitter.com/AIRA_Robonomics)\n\nIf you are not a developer or a researcher, you can start with other suggestions for getting involeved in Robonomics Network Community. If you want to organize a meetup in your city, write content about Robonomics, translate Robonomics content into your native language, write to [community@aira.life](mailto:community@aira.life)\n"}},{node:{id:"ece893ddccda24f5c700ee5dc7cfca0d",title:'Say "Hello Baxter!" with robonomics',path:"/docs/ru/baxter2/",content:'\nExample of how it works is available [here][db1].\n\n## Requirements:\n - Ubuntu 18.04\n - ROS Melodic + Gazebo (installation manual [here][db2])  \n - extra packages:\n```sh\nsudo apt-get install ros-melodic-qt-build ros-melodic-driver-common ros-melodic-gazebo-ros-control ros-melodic-gazebo-ros-pkgs ros-melodic-ros-control ros-melodic-control-toolbox ros-melodic-realtime-tools ros-melodic-ros-controllers ros-melodic-xacro python-wstool ros-melodic-tf-conversions ros-melodic-kdl-parser python-wstool python-catkin-tools qt4-default\n```\n\n- IPFS 0.4.22 (download from [here][db3] and install)\n- pip:\n```sh\nsudo apt install python-pip\n```\n\n- ipfshttpclient\n```sh\npip install ipfshttpclient\n```  \n\n\n - Robonomics node (binary file) (download latest [release][db4] here)\n - Create __Baxter__ and __Employer__ accounts  on **Robonomics Portal**  \n (you can find tutorial ["Create an Account on Robonomics Portal"][db8] here).\n - IPFS browser extension (not necessary)\n\n## 1. Download Baxter model\nDownload packages:\n```sh\ncd ~\nmkdir -p robot_ws/src\ncd robot_ws/src/\nwstool init .\nwstool merge https://raw.githubusercontent.com/RethinkRobotics/baxter_simulator/master/baxter_simulator.rosinstall\nwstool update\ngit clone https://github.com/nakata5321/Baxter_simulation_controller.git\n```\nThis packages were created for ROS indigo. We have to change some files to run them on ROS melodic.\nWe will use **patch** files.\n```sh\npatch ./baxter_simulator/baxter_sim_io/include/baxter_sim_io/qnode.hpp ./Baxter_simulation_controller/patch/qnode_patch\npatch ./baxter_simulator/baxter_sim_kinematics/src/arm_kinematics.cpp ./Baxter_simulation_controller/patch/arm_patch\n```\nAnd let\'s build  all our packages:\n```sh\ncd ..\ncatkin build\n```\nDont forget to add source command:\n```sh\necho "source /home/$USER/robot_ws/devel/setup.bash" >> ~/.bashrc\nsource ~/.bashrc\n```  \n__Important!__ At the end save *Robonomics node (binary file)* in **robot_ws** directory.\n\n## 2. Start simulation\nFirst of all copy and edit `baxter.sh`\n```sh\ncp src/baxter/baxter.sh .\n```\n\nFind your local ip adress with command:\n```\nip a\n```\n![ip_a][im14]\n\nEdit the following values in `baxter.sh` :\n```\nnano baxter.sh\n```\n\nEdit the following values in `baxter.sh` :\n\n- your_ip - put your local ip address. See `ip a`\n- ros_version - for example "melodic"\n\n![baxtersh][im15]\n\nRun the baxter shell script with sim specified:\n```sh\n./baxter.sh sim\nroslaunch baxter_gazebo baxter_world.launch\n```\nYou can put some models in front of our baxter. It will be more intresting.\n![baxter][im2]\n\n## 3.Manage accounts in DAPP\n\nSince we are testing, let us create a local robonomics network with robonomics binary file. Go to folder with robonomics file and run:\n```sh\n./robonomics --dev --rpc-cors all\n```\n![robonomics][im3]\n\nDon\'t forget to remove `db` folder after every launch:\n```sh\nrm -rf /home/$USER/.local/share/robonomics/chains/dev/db\n```\n\nGo to [https://parachain.robonomics.network][db5] and switch to local node\n![local node][im4]\n\nGo to Accounts and transfer some money to __Baxter__ and __Employer__ accounts.\n\nYou can find The manual "Create an Account on Robonomics Portal" [here.][db8]\n\n\nAdd Baxter\'s secret key and adress to `config.yaml` in `robot_ws/src/Baxter_simulation_controller/config/`\n\n## 4.Beginning of work\n\nIn new window run:\n```sh\nifps init #you only need to do this once\nipfs daemon\n```\nOpen separate terminal and start *controller package*:\n```sh\nrosrun robot_controller robot_control.py\n```\n![waiting][im7]\n\nReturn to the first terminal, open new window and send command to [**robonomics io**][db6]. This command will turn ON your robot:\n```sh\necho "ON" | ./robonomics io write launch -r <BAXTER ADDRESS> -s <EMPLOYER’S KEY>\n```\nWhere `<BAXTER ADDRESS>`  and `<EMPLOYER’S KEY>` are replaced with previously saved strings accordingly.\n\n![rob_message][im8]\n\nYou should see the following:\n\n![working][im9]\n\nwhen the work is over go to the Robonomics Portal to `Developer > Chain state`. Choose *datalog* in **state query** and add Baxter datalog message using "+" button.\n\n![datalog][im10]\n\nNow the IPFS hash of the telemetry and photos is saved in the blockchain. To see the data simply copy the hash and insert it in the search bar with URL: `gateway.ipfs.io/ipfs/<put your hash here>`\n\n\nThat\'s all!\n\n![result1][im12]\n![result2][im13]\n\n[db1]: <https://youtu.be/2AQGFVzkGdg>\n[db2]: <http://wiki.ros.org/melodic/Installation>\n[db3]: <https://dist.ipfs.io/go-ipfs/v0.4.22/go-ipfs_v0.4.22_linux-386.tar.gz>\n[db4]: <https://github.com/airalab/robonomics/releases>\n[db8]: </docs/create-account-in-dapp>\n[im1]: <../images/baxter_demo/empty_world.jpg>\n[im2]: <../images/baxter_demo/baxter_simulation.jpg>\n[im3]: <../images/baxter_demo/robonomics.jpg>\n[db5]: <https://parachain.robonomics.network>\n[im4]: <../images/baxter_demo/local_node.jpg>\n[im7]: <../images/baxter_demo/waiting.jpg>\n[im8]: <../images/baxter_demo/rob_message.jpg>\n[im9]: <../images/baxter_demo/working.jpg>\n[im10]: <../images/baxter_demo/datalog.jpg>\n[im11]: <../images/baxter_demo/ipfs.jpg>\n[im12]: <../images/baxter_demo/result1.jpg>\n[im13]: <../images/baxter_demo/result2.jpg>\n[db6]: </docs/rio-overview>\n[im14]:<../images/baxter_demo/ip_a.png>\n[im15]:<../images/baxter_demo/baxter_sh.jpg>\n'}},{node:{id:"c5634d454f6ec5c4fa912b9964465993",title:"Control Baxter robot with robonomics",path:"/docs/ru/baxter/",content:'\nExample of how it works:\n\nhttps://youtu.be/AeufQmaNRWk\n\n## Requirements:\n - Ubuntu 18.04\n - ROS Melodic + Gazebo (installation manual [here][db2])  \n - extra packages:\n```sh\nsudo apt-get install ros-melodic-gazebo-ros-control ros-melodic-effort-controllers ros-melodic-joint-state-controller\n```\n- IPFS 0.4.22 (download from [here][db3] and install)\n- pip:\n```sh\nsudo apt install python-pip\n```\n\n- ipfshttpclient:\n```sh\npip install ipfshttpclient\n```\n\n\n - Robonomics node (binary file) (download latest [release][db4] here)\n - Create __Baxter__ and __Employer__ accounts  on **Robonomics Portal**  \n (you can find tutorial ["Create an Account on Robonomics Portal"][db6] here).\n - IPFS browser extension (not necessary)\n\n## 1. Download Baxter model and controller packages\nDownload packages:\n```sh\ncd ~\nmkdir -p robot_ws/src\ncd robot_ws/src\ngit clone https://github.com/nakata5321/Baxter_simulation_controller.git\ncd Baxter_simulation_controller\ngit checkout old_version\ncd ../..\ncatkin build\n```\nDont forget to add source command:\n```sh\necho "source /home/$USER/robot_ws/devel/setup.bash" >> ~/.bashrc\nsource ~/.bashrc\n```\n\n## 2. Create simulation world\nLet\'s start gazebo world and put our baxter in it:\n```sh\nroslaunch gazebo_ros empty_world.launch\n```\n![empty world][im1]\n\nOpen one more window in terminal:\n```sh\nrosrun gazebo_ros spawn_model -file `rospack find baxter_description`/urdf/baxter.urdf -urdf -z 1 -model baxter\n```\nYou can put some models in front of our baxter. It will be more intresting.\n![baxter][im2]\n\n## 3.Manage accounts in DAPP\n\nSince we are testing, let us create a local robonomics network with robonomics binary file. Go to folder with robonomics file and run:\n```sh\n./robonomics --dev --rpc-cors all\n```\n![robonomics][im3]\n\nDon\'t forget to remove `db` folder after every launch:\n```sh\nrm -rf /home/$USER/.local/share/robonomics/chains/dev/db\n```\n\nGo to [https://parachain.robonomics.network][db5] and switch to local node\n![local node][im4]\n\nGo to Accounts and transfer some money to __Baxter__ and __Employer__ accounts.\n\nYou can find The manual "Create an Account on Robonomics Portal" [here.][db6]\n\nAdd Baxter\'s secret key and adress to `configuration.txt` in `robot_ws/src/robot_controller/src/`\n\n## 4.Start simulation\n\nIn new window run:\n```sh\nifps init #you only need to do this once\nipfs daemon\n```\nOpen separate terminal and start *controller package*:\n```sh\nrosrun robot_controller robot_control.py\n```\n![waiting][im7]\n\nReturn to the first terminal, open new window and send command to [**robonomics io**][db7]. This command will turn ON your robot:\n```sh\necho "ON" | ./robonomics io write launch -r <CURIOSITY ADDRESS> -s <EMPLOYER’S KEY>\n```\nWhere `<CURIOSITY ADDRESS>` and `<EMPLOYER’S KEY>` are replaced with previously saved strings accordingly\n\n![rob_message][im8]\n\nYou should see the following:\n\n![working][im9]\n\nwhen the work is over go to the Robonomics Portal to `Developer > Chain state`. Choose *datalog* in **state query** and add Baxter datalog message using "+" button.\n\n![datalog][im10]\n\nNow the IPFS hash of the telemetry and photos is saved in the blockchain. To see the data simply copy the hash and insert it in IPFS Companion:\n\n![ipfs][im11]\n\nClick  __View on Gateway__ and that\'s all!\n\n![result1][im12]\n![result2][im13]\n\n[db2]: <http://wiki.ros.org/melodic/Installation>\n[db3]: <https://dist.ipfs.io/go-ipfs/v0.4.22/go-ipfs_v0.4.22_linux-386.tar.gz>\n[db4]: <https://github.com/airalab/robonomics/releases>\n[im1]: <../images/baxter_demo/empty_world.jpg>\n[im2]: <../images/baxter_demo/baxter_simulation.jpg>\n[im3]: <../images/baxter_demo/robonomics.jpg>\n[db5]: <https://parachain.robonomics.network>\n[im4]: <../images/baxter_demo/local_node.jpg>\n[im7]: <../images/baxter_demo/waiting.jpg>\n[db6]: </docs/create-account-in-dapp>\n[im8]: <../images/baxter_demo/rob_message.jpg>\n[im9]: <../images/baxter_demo/working.jpg>\n[im10]: <../images/baxter_demo/datalog.jpg>\n[im11]: <../images/baxter_demo/ipfs.jpg>\n[im12]: <../images/baxter_demo/result1.jpg>\n[im13]: <../images/baxter_demo/result2.jpg>\n[db7]: </docs/rio-overview>\n'}},{node:{id:"d64cd8cbb9e44e58aa922d71f030e665",title:"AIRA Overview",path:"/docs/ru/aira-overview/",content:"\n## Introduction\n\nAIRA stands for \"Autonomous Intelligent Robot Agent\". It implements the standard of economic interaction between human-robot and robot-robot. AIRA makes it possible to connect a variety of different robots under decentralized computer's control (currently supported Ethereum and Polkadot/Substrate).\n\nBasically it is the client for Robonomics Network developed by [Airalab](https://aira.life).\n\nAIRA is NixOS based operating system and officially supports the following architectures: x86, Raspberry Pi 3 B+ and Raspberry Pi 4.\n\nThe most simple way to get familiar with AIRA is to try installing AIRA as a [virtual machine](/docs/aira-installation-on-vb/).\n\nAIRA comes with a few preinstalled and configured services to help you focus on [agent](/docs/glossary#agent) development.\n\nMeanwhile it's highly customizable, but it's recommended to understand [NixOS](http://nixos.org/) and [Nix](https://nixos.org/nix/) language.\n\n## What's included? \n\nThe following services are included in the default distribution:\n\n* [Robonomics communication stack](https://github.com/airalab/robonomics_comm)\n* [IPFS](https://ipfs.io/)\n* OpenSSH\n* [cjdns](https://github.com/cjdelisle/cjdns)\n* [Yggdrasil-go](https://yggdrasil-network.github.io/)\n\nBesides at the first launch AIRA [generates](/docs/aira-installation-on-vb#launch-the-machine) for you new Ethereum address and IPNS identifier.\n\nIt's possible to use AIRA as a virtual machine or install as a main operating system. Also you can install only the services you need.\n"}},{node:{id:"a7a334d4b1ab885e04e4ece8f98d6551",title:"AIRA Installation",path:"/docs/ru/aira-installation/",content:"\n- [**How to launch AIRA on VirtualBox**](/docs/aira-installation-on-vb/)\n\n- **The installation on Raspberry Pi** is as simple as writing an image of AIRA on SD card using `dd` or [Etcher](https://www.balena.io/etcher/), for example.\n\n\n"}},{node:{id:"48123c82d1cf67b9dbe18bb8ec9cfd4a",title:"AIRA Installation on VirtualBox",path:"/docs/ru/aira-installation-on-vb/",content:'\nAIRA stands for "Autonomous Intelligent Robot Agent". It is the client for Robonomics Network developed by [Airalab](https://aira.life). It is an operating system based on [NixOS](https://nixos.org/). With AIRA you can  turn any cyber-physical system in an economic agent, where robots operate as a services for the reasonable payments. [More theory about AIRA here](/docs/aira-overview).\n\nIt\'s possible to install AIRA on a x86_64 PC. Also there are images for Raspberry Pi 3 and 4 supported by the team.\n\nThe best way to try AIRA is to start from installing it as a virtual machine on [VirtualBox](https://www.virtualbox.org/).\n\n## Requirements\n\n* VirtualBox\n* [VirtualBox Extension Pack](https://www.virtualbox.org/wiki/Downloads#VirtualBox6.1.2OracleVMVirtualBoxExtensionPack)\n* 2Gb of RAM for the machine\n* 40Gb of free disk space\n\n## Obtain the image\n\nAIRA has [stable](https://aira.life/channels/aira-stable/) and [unstable](https://aira.life/channels/aira-unstable/) channels.\n\nTo get stable image download the file with `.ova` extension.\n\tThe link for stable image is [here](https://releases.aira.life/channels/aira/stable/862-aira-stable/nixos-20.03pre-git-x86_64-linux.ova)\n\nDon\'t forget to compare checksum of the downloaded image with the last column `SHA-256 hash` on the [download page](https://aira.life/channels/aira-stable/). It must be equal to the output of the following command (it is an example, please check the name of downloaded by you .ova file first):\n\n```\nsha256sum nixos-20.03pre-git-x86_64-linux.ova\n```\n\nYou may wish to check out the walkthrough video:\n\nhttps://www.youtube.com/embed/cDcaypYPBhI\n\n## Troubleshooting\n\nIf you have fresh installed VirtualBox, you need to install the [extension](https://www.virtualbox.org/wiki/Downloads) pack or disable USB 2.0 controller.\n\nAlso VirtualBox may show a warning about `Display settings`. Consider switching `Graphics Controller` in settings of the VM to `VMSVGA`.\n\n## Import to VirtualBox\n\nOpen VirtualBox and press `Ctrl+I` or go to `File > Import Applicance...`\n\n![AIRA import VB image](../images/aira-installation/aira_import_vb_image.jpg "AIRA import VB image")\n\nAt this moment the next step is not necessary but it will help you to connect to the VM via SSH easily.\n\nFirst add `Host-Only` adapter in VirtualBox menu `File > Host Network Manager...` or by pressing `Ctrl+H`\n\n![Host Only](../images/aira-installation/host_only_adapter.jpg "Host Only")\n\nThen go to the image\'s settings, Network and add the second network adapter\n\n![Second adapter](../images/aira-installation/add_second_adapter.jpg "Second adapter")\n\nFor more details look at the standalone [lesson](/docs/aira-connecting-via-ssh/).\n\nOptionally you can increase the amount of video memory and switch `Graphics Controller` to `VMSVGA`.\n\n## Launch the machine\n\nFinally press Start and you\'ll see AIRA welcoming you with generated Ethereum address and IPFS identifier\n\n![AIRA image ready, Welcome screen](../images/aira-installation/aira_image_ready.jpg "AIRA image ready, Welcome screen")\n\nAt the very first initialization AIRA generates new Ethereum address and IPNS identifier for you.\n\n'}},{node:{id:"a011775572e4ad0d172cc88867e316d1",title:"Frequently Asked Questions about AIRA",path:"/docs/ru/aira-faq/",content:"\n## How to see logs from main services?\n\nIPFS in real time:\n\n    journalctl -u ipfs -f\n\nand Liability::\n\n    journalctl -u liability -f\n\n## How to check the quantity of IPFS peers?\n\n    ipfs pubsub peers \n\n## IPFS can't connect to the daemon, what should I do?\n\nTry to specify `--api` option\n\n    ipfs swarm peers --api=/ip4/127.0.0.1/tcp/5001/\n\n## How to change ethereum address of AIRA?\n\nDelete `keyfile` and `keyfile-psk` in `/var/lib/liability` and restart the service\n\n```\nsystemctl restart liability\n```\n\n## IPFS daemon doesn't start\n\nThe error mostly occurs on single-board computers like Raspberry Pi or LattePanda after unexpected electricity lost.\n\nUsually the file `/var/lib/ipfs/api` is corrupted and one may see error:\n\n```\nError: Failed to parse '/var/lib/ipfs/api' file.\n  error: failed to parse multiaddr \"\": empty multiaddr\nIf you're sure go-ipfs isn't running, you can just delete it.\nOtherwise check:\n  ps aux | grep ipfs\n```\n\nYou can delete `/var/lib/ipfs/api` file and restart the service\n\n"}},{node:{id:"f3df71a7591e32ac83efeda8cede6018",title:"Connecting AIRA via SSH",path:"/docs/ru/aira-connecting-via-ssh/",content:'\nIt is more convenient to work with virtual machine via ssh connection. In this section we will configure VM.\n\n> **It\'s required to have your ssh public key on Github. In case you don\'t have one, please follow the [link](https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/)**\n\nBelow is the walkthrough video:\n\nhttps://www.youtube.com/embed/R6waDG5iwm0\n\n## Add Host Adapter\n\nGo to `File` -> `Host Network Manager...` or press `Ctrl+H`\n\n![VirtualBox Network Manager](../images/virtualbox_network_manager.png "VirtualBox Network Manager")\n\nClick `Create` button.\n\n## Add the Second Adapter to the VM\n\nSelect imported VM and click `Settings`. Go to `Network` tab and enable the second adapter\n\n![Add Second Adapter](../images/add_second_adapter_to_vm.png "Add Second Adapter")\n\n## Populate Authorized Keys\n\nLaunch the VM and run the following command replacing `<username>` with your Github user name:\n\n```\nmkdir .ssh\nchmod 700 .ssh\ncurl -sSL https://github.com/<username>.keys >> .ssh/authorized_keys\n```\n\nFind out the VM\'s IP address by running:\n\n```\nip a\n```\n\nYou should look for an address which starts with `192.168.xx.xx`\n\n## Log in via SSH\n\nNow open your terminal and log in via SSH as usual using the address from the previous step:\n\n```\nssh root@192.168.xx.xx\n```\n'}},{node:{id:"87681d6e7594efcbde5260488adbae2f",title:"Basic usage of AIRA",path:"/docs/ru/aira-basic-usage/",content:"\nTo get familiar with AIRA, let's see what is under the hood.\n\nOnce you launch the client several ros nodes will already be on the run. Here's a list of robonomics communication stack nodes:\n\n```bash\n$ rosnode list\n/eth/erc20_token\n/eth/eth_node\n/graph/aira_graph\n/liability/executor\n/liability/infochan/eth/signer\n/liability/infochan/ipfs_channel\n/liability/persistence\n/liability/listener\n/rosout\n```\n\n- `/eth/erc20_token`, `/eth/eth_node` - proved services for Ethereum blockchain and ERC20 tokens\n- `/graph/aira_graph` - service node for exploring other AIRA instances\n- `/liability/executor` - gets rosbag file from IPFS and plays it\n- `/liability/infochan/ipfs_channel` - is responsible for offer, demand and result messages. It catches messages from the channel and sends signed messages back\n- `/liability/infochan/eth/signer` - offers services for signing offer, demand and result messages\n- `/liability/listener` - watches for a new liability contracts. When the event is received the node calls executor node\n- `/liability/persistence` - helps to store incoming liabilities and restart them after shutdown\n\nAnd here's a list of robonomics stack topics.\n\n```bash\n$ rostopic list\n/eth/event/approval\n/eth/event/transfer\n/graph/greetings\n/liability/complete\n/liability/finalized\n/liability/incoming\n/liability/infochan/eth/sending/demand\n/liability/infochan/eth/sending/offer\n/liability/infochan/eth/sending/result\n/liability/infochan/eth/signing/demand\n/liability/infochan/eth/signing/offer\n/liability/infochan/eth/signing/result\n/liability/infochan/incoming/demand\n/liability/infochan/incoming/offer\n/liability/infochan/incoming/result\n/liability/persistence/add\n/liability/persistence/del\n/liability/persistence/update_timestamp\n/liability/ready\n/liability/result\n/rosout\n/rosout_agg\n```\n\nThe most important topics for us are:\n\n- `/liability/incoming` - when a new liability is created, this topic publishes Ethereum address of the contract\n- `/liability/result` - this topic is for publishing results. But don't publish a result directly to this topic! Use a service instead\n- `/liability/infochan/incoming/*` - a CPS gets information about offer, demand or result from corresponding topics\n- `/liability/infochan/eth/signing/*` - a CPS sends offer, demand or result messages to corresponding topics\n\nFor the details check out the [API page](/docs/robonomics-liability/).\n\nLet's start with greetings - say hello to AIRA!\n\nYou should just launch a pre-installed package `hello_aira`:\n\n```\n$ rosrun hello_aira hello_aira\n```\n\nWe've launched our agent. It will wait for a demand message. Now it's time to send the message. Go to [dapp](https://airalab.github.io/robonomics_tutorials/) and press Order.\nNow go back to the console and see the result!"}},{node:{id:"2d8bee2dbc4ede05215fc143c5113647",title:"Agent development examples",path:"/docs/ru/agent-development-examples/",content:"\nUseful pieces of code and a few scenarios. All source code is [here](https://github.com/vourhey/robonomics_tutorials).\n\n1. [Broadcast Demand](https://github.com/Vourhey/robonomics_tutorials/tree/master/01_broadcast_demand/)\n2. [Broadcast Offer](https://github.com/Vourhey/robonomics_tutorials/tree/master/02_broadcast_offer/)\n3. [Trader](https://github.com/Vourhey/robonomics_tutorials/tree/master/03_trader/)\n4. [Trader with ACL](https://github.com/Vourhey/robonomics_tutorials/tree/master/04_trader_with_acl/)\n5. [Open Sensor Data](https://github.com/Vourhey/robonomics_tutorials/tree/master/05_open_sensor_data/)\n\n"}},{node:{id:"bbf9e1cf1565e2440f446715fadbd97e",title:"Lesson 4, Robonomics parachain in practice",path:"/docs/ja/wschool2021-robonomics-parachain-in-practice/",content:"import Asciinema from '~/components/Asciinema.vue'\n\nRobonomics parachain is not a general purpose parachain on Polkadot ecosystem. The target of Robonomics\nis building economy of machines, the parachain in this scope of aims helps to integrate Polkadot ecosystem\nwith IoT, Smart Cities and Industry 4.0 concepts.\n\n## Requirements\n\n* Docker, please [install it](https://docs.docker.com/engine/install/).\n* Polkadot-launch, please [install it](https://github.com/paritytech/polkadot-launch#install).\n\n## Launch the relay\n\nThe relay chain is a core of Polkadot, it provides [shared security](https://wiki.polkadot.network/docs/en/learn-security)\nfor all child parachains and implements message passing mechanics for them. Let's launch local instance of Rococo (polkadot testnet)\nrelay chain with two robonomics-based parachains as a childs. I'll use prepared [Docker image tag: \"winter-school-2\"](https://hub.docker.com/layers/robonomics/robonomics/winter-school-2/images/sha256-92f4795262f3ded3e6a153999d2777c4009106a7d37fd29969ebf1c3a262dc85?context=explore) but all source code of examples\navailable in [Robonomics GitHub](https://github.com/airalab/robonomics/tree/master/scripts/polkadot-launch).\n\n<Asciinema vid=\"419Jrg22ziFfMFPZlh2WtiLvg\"/>\n\nIt could take a time, but be partient. As result you should have three chain instances at ports:\n\n* `9944` - local rococo relay chain.\n* `9988` - robonomics parachain with `id=100`\n* `9989` - robonomics parachain with `id=200`\n\nIf you use remote server, you need to create some ssh tunnels on local machine:\n```\nssh -f -N -L 9944:127.0.0.1:9944 root@REMOTE_SERVER_IP\nssh -f -N -L 9988:127.0.0.1:9988 root@REMOTE_SERVER_IP\nssh -f -N -L 9989:127.0.0.1:9989 root@REMOTE_SERVER_IP\n```\nAfter that, you can use `ws://127.0.0.1:9944`, `ws://127.0.0.1:9988`and `ws://127.0.0.1:9989` in https://parachain.robonomics.network/\n\n![relay](https://ipfs.io/ipfs/QmR9Tj86yPkrXQsSwereJwqDxsZgkAdySB16G4SMHrhpBu/upcoming.png)\n\nSome time ago parachains should be registered.\n\n![relay2](https://ipfs.io/ipfs/QmR9Tj86yPkrXQsSwereJwqDxsZgkAdySB16G4SMHrhpBu/parachains.png)\n\nAnd start to produce blocks.\n\n![relay3](https://ipfs.io/ipfs/QmR9Tj86yPkrXQsSwereJwqDxsZgkAdySB16G4SMHrhpBu/parachains2.png)\n\nAs next step let's create HRMP channel to pass messages between parachains. I'll use `sudo` module call on relay chain page.\n\n![hrmp](https://ipfs.io/ipfs/QmR9Tj86yPkrXQsSwereJwqDxsZgkAdySB16G4SMHrhpBu/hrmp.png)\n\nWhen channel created, the XCM calls is available. Let's use `datalogXcm` pallet - a XCM version of `datalog` pallet.\n\n![datalogXcmSend](https://ipfs.io/ipfs/QmR9Tj86yPkrXQsSwereJwqDxsZgkAdySB16G4SMHrhpBu/datalogXcmSend.png)\n\nAs result message on second parachain will call `datalog` pallet and write data on chain.\n\n![datalogXcmRecv](https://ipfs.io/ipfs/QmR9Tj86yPkrXQsSwereJwqDxsZgkAdySB16G4SMHrhpBu/datalogXcmRecv.png)\n\nAs result, this example demonstrate how XCM could be used for cross chain usage of standard robonomics pallets.\n"}},{node:{id:"b8722d50ca16de4db896fffa11c203a9",title:"Lesson 3, Robonomics IO in practice",path:"/docs/ja/wschool2021-robonomics-io-in-practice/",content:'import Asciinema from \'~/components/Asciinema.vue\'\n\n## Requirements\n\n* the Docker is required, please [install](https://docs.docker.com/engine/install/) it first.\n* the [Nova SDS011](https://aqicn.org/sensor/sds011) sensor is *optional*.\n\n### SDS011 check (optional)\n\nIf you have connected SDS011 sensor then please check that it presented in `/dev` and have correct access rights.\n\n<Asciinema vid="WCFcx8C6M8e52UKDNei1xZloU"/>\n\n## Quick start\n\nWhen docker is installed let\'s launch robonomics docker image from [Official repository](https://hub.docker.com/r/robonomics/robonomics). I\'ll use `winter-school` tag during this lesson.\n\n<Asciinema vid="wM43jozIVfcRmt52ENrJ6yPlH"/>\n\nWhen docker image is ready let\'s try to read a data using `robonomics io` command (optiona if you have SDS011 device).\n\n<Asciinema vid="iztt22tKGaV8wq3cMXY1oUEYv"/>\n\nIf you have no SDS011 sensor then feel free to use virtual SDS011 sensor available in the same docker container via `vsds011.sh`. And everywhere in folloding command please use it as transparent replacement for physical sensor.\n\n<Asciinema vid="GCkSiJBA1DgpLAAHiMhIOSpgG"/>\n\nThe Robonomics IO subsystem have two kind of commands:\n\n* `read` - get data from device that support read access;\n* `write` - write data into device that support write access.\n\nSome devices support them both, in that case devices presented in both command arguments.\n\n> For example, virtual device `ipfs` supports `read` data from IPFS by hash as same as `write` data into IPFS.\n\nFull list of supported devices is possible to get running `robonomics io read` or `robonomics io write` without arguments.\n\n## IPFS access\n\nOn next step runned IPFS daemon is required. For this purpose let\'s run init IPFS and run daemon on dedicated\nterminal tab.\n\n<Asciinema vid="ir6ziXSBUDrRltTmNxg7sdXVY"/>\n\nWhen daemon launched is possible to connect docker image in separate tab and use `robonomics io` for writing and reading a data.\n\n<Asciinema vid="ZtwcmpB9Lhum2Sc221QmNwHG4"/>\n\nThe output forwarding is also works here, that means it\'s possible to forward SDS011 sensor data into IPFS using `|` (pipe) symbol in console. Let\'s try to do it.\n\n<Asciinema vid="XS0QESWG7f8ELsQe1bGQllb9O"/>\n\nWhere JSON data from SDS011 forwarded as input for IPFS writer and result is published on stdout.\n\nThis approach permits engineer extrimely quickly make a simple program just combine a primitive readers and writers from `robonomics io` tools.\n\n```bash\nrobonomics io read sds011 | gz | robonomics io write pubsub my-sensor-data\n```\n\n## Robonomics Datalog\n\n> The target of Robonomics [Datalog](https://crates.robonomics.network/robonomics_protocol/datalog/index.html) is data blockchainization. This pallet provides function to store custom data on blockchain to make it immutable, impossible to change in future.\n\nFor the final part of this lesson runned robonomics node is required. Development mode is preffered because of quick block time and already distributed balances on preset accounts. Let\'s launch it on separate terminal tab in the same container.\n\n<Asciinema vid="QnN9l0sdaZZOyK9ah0DntvCXt"/>\n\nThen private seed also required as argument for `datalog` device. This seed is used to sign transaction and presents account as a sender. Let\'s generate it using embedded `robonomics key` command.\n\n<Asciinema vid="4Cdfl9F0GgjNWv1c1ZcTBBktF"/>\n\nSave generated address and seed on safe place for use it later.\n\nCurrently address balance is zero and the network don\'t permits to send transactions from this address. To fix it let\'s transfer a bit of tokens from `Alice` account. I\'ll use Robonomics Portal on https://parachain.robonomics.network connected to local node with address `ws://127.0.0.1:9944`.\n\n![portal transfer](https://ipfs.io/ipfs/QmbpArfthyor5wFWRexgPAyjK7GaFduasc1eoReaf9TpJg/tran.png)\n\nAnd then `datalog` device could be used for saving any data on blockchain. The key `-s` is used to set secret seed of account. Account should have non-zero balance to send transactions.\n\n<Asciinema vid="FzERH9TmFB8oRuas8ZU202Pv8"/>\n\nIf every thing is correct the you should see `Datalog` event on `Explorer` page of Robonomics portal.\n\n![portal datalog](https://ipfs.io/ipfs/QmbpArfthyor5wFWRexgPAyjK7GaFduasc1eoReaf9TpJg/datalog.png)\n\nThe final step is a bit complex but it\'s good to try use all knowledge of this lesson. Let\'s make a simple program\nthat collects data from SDS011 sensor (or file), pack it into IPFS and then send `datalog` transaction to save hash on blockchain.\n\n```\nSDS011 -> IPFS -> Blockchain\n```\n\nIt\'s easy to implement using Robonomics IO, let\'s do that.\n\n<Asciinema vid="MTpiawGo8DKEn081OozbYb5mU"/>\n\nIf everything well the `Datalog` event with IPFS hash should be presented.\n\n![portal datalog complex](https://ipfs.io/ipfs/QmbpArfthyor5wFWRexgPAyjK7GaFduasc1eoReaf9TpJg/datalog_complex.png)'}},{node:{id:"adc6f102aafce66839070b2b89175612",title:"Lesson 2, Robonomics GitHub overview",path:"/docs/ja/wschool2021-robonomics-github-overview/",content:"\n## Step 1: AIRA Installation on VirtualBox\n\nhttps://youtu.be/ISKilRfY3Ow\n\n## Step 2: Connecting Aira via SSH\n\nhttps://youtu.be/W0rOcRA2sEc\n\n## Step 3: Interact with AIRA\n\nhttps://youtu.be/fhRTF2mddfU"}},{node:{id:"5c25db9a6812a9895efd3ac8d1fd8b0b",title:"Robonomics Winter School 2021 introduction",path:"/docs/ja/wschool2021-intro/",content:"\nRobonomics Winter School 2021 is held from 10 to 24 February **online**. It's **free**.\n\nWe are publishing **lessons** online in different ways: text here in Wiki, video on our [YouTube channel](https://www.youtube.com/channel/UCrSiho1uB-1n6F8cZpCLhjQ), announce in [Twitter account](https://twitter.com/AIRA_Robonomics). Please, keep in mind, that video lessons and text lessons are not the same. For the start we plan to publish two language versions: English and Russian. \n\nJoin us, take your steps through the lessons, **discuss and ask questions** in [Discord](https://discord.gg/5UWNGNaAUf).\n\n## Watch opening ceremony\n\nhttps://youtu.be/kQaSwNYHJQ8\n\n## Basic information\n\nTake a look at [page about school](https://robonomics.network/blog/winter-robonomics-school/) on our website. We are collecting there all basic information: shedule, infopartners, links.\n\n## Links, links, links\n\nLets repeat what links do we have for following Robonomics Winter School 2021:\n\n- [Summary on website](https://robonomics.network/blog/winter-robonomics-school/)\n- Wiki for text lessons, YOU ARE HERE 🤓\n- [Video lessons](https://www.youtube.com/channel/UCrSiho1uB-1n6F8cZpCLhjQ)\n- [Fast announce on Twitter](https://twitter.com/AIRA_Robonomics)\n- [Questions, Discussions, Quizes in Discord](https://discord.gg/5UWNGNaAUf)\n\n**Lets start learn Robonomics!**"}},{node:{id:"5aeba103b56518ed2e6f8fbb9c80f44d",title:"Lesson 5, Connectivity",path:"/docs/ja/wschool2021-connectivity-service/",content:'\n## IoT as a Multiple Pie\n\n* Device Software\n    * FreeRTOS\n    * ESP/Arduino\n    * Single-board computers (RPi, LattePanda etc)\n* Connectivity\n    * IoT Hub\n    * IoT Manager\n* Analytics Services\n    * AWS\n    * Google Cloud IoT Core\n    * ThingsBoard\n\nAs a rule, most are not interested in sensors and servers, but data analytics.\nTo get it, you need to decide which device to use, how to work with it and where to connect\n\n## Device Software\n\nConsider the example of a home weather station. It is necessary to collect data on air pollution (SDS011), temperature and humidity (BME). The ESP8266 microcontroller can handle this task.\n\nRequirements:\n\n* Correctly read data from sensors\n* Have a unique identifier\n* Transfer data to a known server\n* Provide digital signature of data (optional)\n\nYou can find the current firmware [here](https://github.com/LoSk-p/sensors-software/tree/366b19bf447a5fc19220ef89eab0f2440f8db1c2)\n\n## What is Connectivity? \n\nIn the IoT world, connectivity refers to the connection of various IoT devices to the Internet to send data and / or control the device.\n\nWell-known architectural solutions can be roughly divided into 3 groups:\n\n* Fully decentralized. For example, devices are connected by a mesh network. Not suitable for wide area networks due to high hardware requirements\n* Centralized. For example, AWS. Provides a single entry point and ease of connection, but there is a high risk of failure in case of server problems\n* Hybrid. For example, [Robonomics Connectivity](https://github.com/airalab/sensors-connectivity). Provides an address for devices on a "local" network and publishes data to a distributed IPFS message channel\n\n## Comparison of AWS and Robonomics Connectivity\n\n| Management services \t| AWS                               \t|               Robonomics              \t|\n|---------------------\t|-----------------------------------\t|---------------------------------------\t|\n| Transaction type    \t| Technical                         \t| Technical and economic                \t|\n| Security            \t| IT-company cloud control          \t| Polkadot and Ethereum                 \t|\n| Protocol            \t| HTTPS, MQTT                       \t| IPFS, Robonomics                      \t|\n| Ecosystem           \t| Private                           \t| Shared                                \t|\n| Access to DeFi      \t| No                                \t| Yes                                   \t|\n| Costs               \t| Pushing data - $1-2 a sensor      \t| Pushing data - $0                     \t|\n|                     \t| Shadow         - from $10 a month \t| Digital Twin    - $0,01 a transaction \t|\n\n## Installing Connectivity on Aira\n\nhttps://www.youtube.com/watch?v=JbBNMHAzJKM\n\n### Requirements\n\n* [VirtualBox 6.1](https://www.virtualbox.org/wiki/Downloads) and above\n* [Aira OS ova image](https://static.aira.life/ova/airaos-21.03_robonomics-winter-school.ova)\n\nImport Aira image in VirtualBox as described [here](/docs/aira-installation-on-vb/)\n\nSet up a connection over [SSH](/docs/aira-connecting-via-ssh/)\n\nWhen everything is set and you successfully log in via SSH, let\'s clone the main package and build it \n\n```\ngit clone https://github.com/airalab/sensors-connectivity\ncd sensors-connectivity\nnix build -f release.nix\n```\n\nNow let\'s create a copy of the default configuration file for later usage. \nTo learn about all the options check [this article](/docs/configuration-options-description/) out.\nThen launch the package with `roslaunch`\n\n```\ncp config/default.json config/my.json\nsource result/setup.zsh\nroslaunch sensors_connectivity agent.launch config:=$PWD/config/my.json\n```\n\n## Connect Sensor to Connectivity\n\nhttps://www.youtube.com/watch?v=yxqxBk-6bpI\n\n### Requirements\n\n* [Nova SDS011](https://aqicn.org/sensor/sds011) sensor \n* [Yarn Packet Manager](https://yarnpkg.com/getting-started/install)\n\nNow let\'s connect a real sensor, forward USB port to the virtual machine, set up a map and look at our own measurements\n\nFirst, stop the Aira OS if it was running and add a corresponding USB device\n\n![VB USB Forwarding](../images/vb_forward_usb.jpg)\n\nStart the VM, connect via SSH and set `comstation/port` option according to your USB device in the VM. Also enable `comstation` and set your latitude and longitude. In the end `config/my.json` should look like this:\n\n```\n{\n   "general":{\n      "publish_interval":30\n   },\n   "comstation":{\n      "enable":true,\n      "port":"/dev/ttyUSB0",\n      "work_period":0,\n      "geo":"59.944917,30.294558",\n      "public_key":""\n   },\n   "httpstation":{\n      "enable":false,\n      "port":8001\n   },\n   "mqttstation": {\n      "enable": false,\n      "host": "connectivity.robonomics.network",\n      "port": 1883\n   },\n   "luftdaten":{\n      "enable":false\n   },\n   "robonomics":{\n      "enable":true,\n      "ipfs_provider":"/ip4/127.0.0.1/tcp/5001/http",\n      "ipfs_topic":"airalab.lighthouse.5.robonomics.eth"\n   },\n   "datalog":{\n      "enable":false,\n      "path":"",\n      "suri":"",\n      "remote":"wss://substrate.ipci.io",\n      "dump_interval":3600,\n      "temporal_username":"",\n      "temporal_password":""\n   },\n   "dev":{\n      "sentry":""\n   }\n}\n```\n\n> If you don\'t have a real sensor, you can use `sensors-connectivity/utils/virtual-sensor.py` script to emulate one\n> \n> Enable `HTTPStation` and disable `COMStation` by changing the configuration file as:\n> ```\n> {\n>    "general":{\n>       "publish_interval":30\n>    },\n>    "comstation":{\n>       "enable":false,\n>       "port":"/dev/ttyUSB0",\n>       "work_period":0,\n>       "geo":"59.944917,30.294558",\n>       "public_key":""\n>    },\n>    "httpstation":{\n>       "enable":true,\n>       "port":8001\n>    },\n>    ...\n> }\n> ```\n>\n> and launching `utils/virtual-sensor.py` in a dedicated terminal in the VM\n\nSave the file and launch connectivity from `sensors-connectivity` folder:\n\n```\nsource result/setup.zsh\nroslaunch sensors_connectivity agent.launch config:=$PWD/config/my.json\n```\n\nYou should see first measurements in the console output\n\nLook for your IPFS ID in the VM. It appears right after booting the image or via `ipfs id` command. We will need it later.\n\nNow let\'s set up our own instance of the map. On your laptop (not in the VM) clone [this](https://github.com/airalab/sensors.robonomics.network) repository and build the app:\n\n```\ngit clone https://github.com/airalab/sensors.robonomics.network\ncd sensors.robonomics.network\nyarn install\n```\n\nEdit `src/agents.json` file and put your IPFS ID. For example:\n\n```\n[\n  "12D3KooWSCFAD3Lpew1HijniE6oFTuo4jsMwHzF87wNnXkpCRYWn"\n]\n```\n\nLaunch the map:\n\n```\nyarn serve\n```\n\nGo to [http://localhost:8080/](http://localhost:8080/) or the address yarn gave you and look for the sensor.\n\n## Practice\n\n### Trajectory 1. Flash a sensor ESP + SDS011\n\nRequirements:\n\n* ESP8266\n* At least one of sensors SDS011, BME280, HTU21D\n\nUse the [instruction](https://wiki.robonomics.network/docs/connect-sensor-to-robonomics/) to connect a sensor to Robonomics Connectivity. \n\nCheck that your sensor appears on our [map](https://sensors.robonomics.network/#/).\n\n### Trajectory 2. Launch Connectivity\n\nRequirements:\n\n* ROS\n* Python\n* Nix (optional)\n\nBuild and launch [sensors-connectivity](https://github.com/airalab/sensors-connectivity#get-a-package-and-build)\n\n> How it build, install [here](https://wiki.robonomics.network/docs/iot-sensors-connectivity/) and configure [here](https://wiki.robonomics.network/docs/configuration-options-description/)\n\nGeneral scheme of the package:\n\n```\n    station1 \\                        / feeder1\n    station2 -  sensors-connectivity  - feeder2\n    station3 /                        \\ feeder3\n```\n\nThe choice is proposed to implement either a new station, for example, a random number generator, or a new feeder, for example, displaying a string on the screen.\n\nInterface `IStation` [here](https://github.com/airalab/sensors-connectivity/blob/master/src/stations/istation.py#L73).\n\nInterface `IFeeder` [here](https://github.com/airalab/sensors-connectivity/blob/master/src/feeders/ifeeder.py#L5)\n\n'}},{node:{id:"b5c495fc456f59b073a64f93052498a1",title:"Lesson 1, Connect robotics to user app",path:"/docs/ja/wschool2021-connect-robotics-to-user-app/",content:"\nhttps://youtu.be/NOQxyojvaao\n\n- [Reference tutorial on Wiki](https://wiki.robonomics.network/docs/get-weather-on-fuji-mountain/)\n- [Dapp](https://dapp.robonomics.network/#/)"}},{node:{id:"8a3a94c1f0b4791fb118a9637c89559f",title:"Lesson 6.2, Build IoT Dapps For End Users",path:"/docs/ja/wschool2021-build-dapp-interface/",content:'\n![Building User Interface for Decentralized Applications, on top of Robonomics and Polkadot](../images/build-dapp-interface/sum.gif "Building User Interface for Decentralized Applications, on top of Robonomics and Polkadot")\n\n## Introduction\n\nThis tutorial continues the previous lesson, where you have already built simple application and were focused on connecting an account to a node, sending transactions and other vital functions of the dapp. Now we will **build user-friendly interface** for this application.\n\n## Prerequisites\n\nThis tutorial is designed for people who are familiar with **HTML, CSS, JavaScript** a bit and want to learn how to apply these skills for decentralized applications.\n\nFor building your dapp\'s interface you can choose any JavaScript framework which is comfortable for you or even try to build interface without any framework. In Robonomics 2021 we use [Vue.js](https://vuejs.org) as it is quite scalable and easy to use.\n\n## Set up for this tutorial\n\nIf you start with this step and prefer to **learn by doing**, please, follow this to-do list to launch the resulting dapp from the previous lesson:\n\n1. Download a local Robonomics node from [releases page](https://github.com/airalab/robonomics/releases/) that fits your OS. If you do not find your system in the latest release, please, find the most recent version in the previous releases.\n\n2. Launch the Robononomics node in the Developer mode by typing `./robonomics --dev` in your terminal.\n\n3. Download the Polkadot Extension for Chrome or Firefox [here](https://polkadot.js.org/extension/)\n\n4. Clone [this repository](https://github.com/vol4tim/example-robonomics-dapp/).\n\n5. Install [Yarn](https://yarnpkg.com).\n\n6. Install [@vue/cli](https://cli.vuejs.org/guide/installation.html)\n\n7. Start developing dapp with `yarn serve` command in your terminal.\n\n\n**You should get this screen in your browser:**\n\n![Dapp Start](../images/build-dapp-interface/dapp-start.png "Dapp Start")\n\n\n<details>\n\n  <summary>Some additional tips for launching</summary>\n\n  - Make sure your **node is running**:\n    ![Example of running a Robonomics node](../images/build-dapp-interface/robonomics-node-launch.png "Example of running Robonomics node")\n\n  - In **macOS** you may need to change the **access permissions** `chmod +x robonomics`\n\n  - Make sure you allowed **access for Polkadot Extension**:\n    ![Polkadot Extension giving access](../images/build-dapp-interface/polkadot-permission.png "Polkadot Extension giving access")\n\n  - If you have errors in log of the running node and dapp is not loading correctly, please, try to delete data base of dev chain: `sudo rm -rf <YOUR LOCAL PATH>/robonomics/chains/dev/db/` and restart the node. If it does not help, restart your machine.\n\n</details>\n\n## Inspecting the code\n\nLet\'s inspect the structure of the dapp to clear up what and where we can fix in order to change UI.\n\n```\n.\n├── public/\n│   ├── favicon.ico           # Icon for your dapp\n│   └── index.html            # The template file (injects icons links, JavaScript and CSS files for the app)\n├── src/\n│   ├── assets/               # Folder for images and global styles\n│   ├── components/           # Folder with components\n│   │   ├── Datalog.vue       # Tab \'Datalog\' in dapp\n│   │   ├── Demo.vue          # Tab \'Demo\' in dapp\n│   │   ├── Launch.vue        # Tab \'Launch\' in dapp\n│   ├── utils/                # Folder with important for app js functions (we will touch api.js in this tutorial)\n│   ├── App.vue               # The root of our app, contains HTML, CSS, JS for the whole page. In fact it is Vue Component also\n│   ├── main.js               # The app’s entry file, we will import here global styles\n├── ...                       # There are config files and dependencies files, that we will not change mannually\n├── README.md                 # You can write here any instructions for your dapp\n\n```\n\n> **The code of this tutorial is in this [repository](https://github.com/positivecrash/wscool21-ui-dapp)**\n\n## CSS-in-JS VS. Global stylesheets\n\nIn this tutorial I show how to change the interface of a small dapp from scratch without any stable library of UI components. So I will import and create not only different Vue components, but also write my own styles.\n\nIf your application is big or your project has the whole bunch of dapps, in future you\'d better look for building library of components specifically for your project to make UI more organized and efficient ([for example, here is a tool for organizing components](https://storybook.js.org)). Or if you are okay with standart interface themes, you can use any UI Libraries of third party ([for example](https://vuetifyjs.com/)).\n\n## First import or where to start\n\nI don\'t have any specific design for this dapp, but I have [Brandbook](https://static.robonomics.network/assets/Robonomics-Visual-Identity.pdf) and [quit well-established](https://robonomics.network) typography, fonts, button styles etc. So for the start I will import the following css files globally:\n\n```\n...\n├── src/\n│   ├── assets/\n│   │   ├── styles/\n│   │   │   ├── reset.css         # The goal is to reduce browser inconsistencies\n│   │   │   ├── variables.css     # Contains specific values to be reused such as colors, font-names, space values etc.\n│   │   │   ├── typography.css    # Global typography for the whole dapp\n│   │   │   ├── animation.css     # Keyframe animations used throughout the dapp\n...\n\n```\n\nThe content of any of these files you can write in App.vue instead, if it fits your perception better. But I recommend to import some CSS files globally for this example to keep App.vue a little bit more clear.\n\nImport these CSS files into your app by editing **main.js** file:\n\n![Import global CSS in Vue app](../images/build-dapp-interface/import-css-vue-1.png "Import global CSS in Vue app")\n\n```JS\nimport \'./assets/styles/reset.css\'\nimport \'./assets/styles/variables.css\'\nimport \'./assets/styles/typography.css\'\nimport \'./assets/styles/animation.css\'\n```\n\n**Check if fonts have been changed in the dapp:**\n\n![Dapp Interface changing step 1](../images/build-dapp-interface/dapp-1.png "Dapp Interface changing step 1")\n\n\n## Change layout and prettify the title\n\nLet\'s change layout of the application. As I mentioned earlier, you can write your styles directly in App.vue, but for this example I prefer to separate this process.\n\n- Comment or delete styles from tag `<style>` in **App.vue**\n\n- Create css file **app.css** in styles folder for this application and import it into **main.js**\n\n```JS\nimport \'./assets/styles/app.css\'\n```\n\n<details>\n\n<summary>Write in app.css first basic styles for the app:</summary>\n\n```css\n#app {\n  display: grid;\n  grid-template-rows: auto 1fr;\n  align-items: stretch;\n\n  text-align: center;\n}\n\nbody {\n  background-color: var(--color-gray-light);\n}\n```\n\n</details>\n\n\n<details>\n\n<summary>Change the title of the app [App.vue]</summary>\n\n```html\n<div class="top">\n    <h1>dApp Robonomics Demo</h1>\n    <i>Winter School 2021</i>\n    <img class="label" alt="" src="./assets/images/robonomics-winter-school-2021-logo.png"/>\n</div>\n```\n\n</details>\n\n\n\n<details>\n\n<summary>Write styles for the title [app.css]</summary>\n\n```css\n.top {\n  position: relative;\n  padding-top: var(--space);\n  padding-bottom: calc(var(--space)*2);\n\n  border-bottom: 2px solid var(--color-dark);\n  background-color: var(--color-light);\n}\n\n.top h1 {\n  font-size: 1.8rem;\n}\n\n.top i {\n  display: block;\n}\n\n.top .loader-label {\n  display: block;\n  margin: calc(var(--space)/3) auto;\n  max-width: 150px;\n\n  visibility: hidden;\n  opacity: 0;\n  animation: 0.5s FadeIn 0.3s ease forwards, 0.5s ScaleDown 0.1s ease forwards;\n}\n\n.top .label {\n  position: absolute;\n  width: 100px;\n  bottom: -50px;\n  left: calc(50% - 50px);\n  display: block;\n\n  transform: translateY(1rem);\n  visibility: hidden;\n  opacity: 0;\n  animation: 0.7s FadeIn 0.5s ease forwards, 1s ScaleUp 0.5s ease forwards;\n}\n```\n\n</details>\n\n- Place a file with the logo of the Robonomics winter school 2021 in the folder **./src/assets/images**\n\n**You will get the following screen:**\n![Dapp Interface changing step 2](../images/build-dapp-interface/dapp-2.png "Dapp Interface changing step 2")\n\n## Define styles according to the dapp\'s data\n\nNow I will wrap the app\'s content in `<div>` element. Also I will need different styles for different states of the dapp (loaded or not loaded).\n\n- Open the **App.vue** and write a wrapping element:\n```html\n<div class="content">\n  \x3c!--here is everything going after the title--\x3e\n</div>\n```\n- Find the variable `load`, it has already been defined in `<script>`.\n- Pass an object to `v-bind:class` to dynamically toggle classes (I use shortened version `:class`):\n```html\n<div class="content" :class="{ load: load }">\n  \x3c!--here is everything going after the title--\x3e\n</div>\n```\nThat\'s how you can easily toggle styles in your app according to the data you get. You will see the usage of this class below.\n\n## Define views according to the dapp\'s data\n\nLet\'s change the loader for the app.\n- For this purpose I will import my component from another Robonomics project \n\n<details>\n\n<summary>./src/components/AnimatedRobonomicsLogo.vue</summary>\n\n```HTML\n<template>\n  <div class="logo-animated" :style="{transform: \'scale(\'+scale+\')\'}">\n      <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="196.9px" height="170.3px" viewBox="0 0 196.9 170.3" style="enable-background:new 0 0 196.9 170.3;" xml:space="preserve">\n\t\t<g transform="translate(2530 155)">\n            <path class="line" d="M-2523.4,7.9l184.2,0.5l-91.7-158.1L-2523.4,7.9z"/>\n\n            <circle class="dot" cx="-2339.7" cy="8.7" r="6.6"/>\n            <circle class="dot" cx="-2523.4" cy="8.2" r="6.6"/>\n            <circle class="dot" cx="-2430.8" cy="-148.4" r="6.6"/>\n            \n            <path class="triangle-1" d="M-2477.3-18.3l92.1,0.3l-45.8-79L-2477.3-18.3z"/>\n            <path class="triangle-2" d="M-2431.2-18.1l46,0.1l-45.8-79L-2431.2-18.1z"/>\n            <path class="triangle-3" d="M-2477.3-18.3l92.1,0.3l-46-20.3L-2477.3-18.3z"/>\n          </g>\n\t</svg>\n  </div>\n</template>\n\n<script>\n\nexport default {\n\n  props: {\n    scale: {\n      type: String,\n      default: \'1\'\n    },\n  },\n\n};\n<\/script>\n\n<style scoped>\n    /*\n    Global styles required:\n    FadeIn - keyframe animation from animation: .css\n    all --color- variables from variables.css\n    */\n\n    .logo-animated {\n        transform-origin: 0 0;\n    }\n\n    .logo-animated .dot {\n        fill: var(--color-blue);\n        visibility: hidden;\n        opacity: 0;\n        animation: 1s FadeIn 0.3s ease forwards;\n    }\n\n    .logo-animated .line {\n        fill: transparent;\n        stroke: var(--color-blue);\n        stroke-miterlimit:10;\n        stroke-dasharray: 700;\n        stroke-dashoffset: 700;\n        animation: 1s DrawSvgPath 0.5s ease-in-out forwards; \n    }\n\n    .logo-animated .triangle-1 {\n        fill: var(--color-blue);\n        visibility: hidden;\n        opacity: 0;\n        animation: 0.5s FadeIn 0.3s ease forwards, 5s logo-triangle-1 0.1s linear infinite;\n    }\n\n    .triangle-2 {\n        fill: var(--color-violet-light);\n        visibility: hidden;\n        opacity: 0;\n        animation: 0.5s FadeIn 0.3s ease forwards, 5s logo-triangle-2 0.1s linear infinite;\n    }\n\n    .triangle-3 {\n        fill: var(--color-violet-mid);\n        visibility: hidden;\n        opacity: 0;\n        animation: 0.5s FadeIn 0.3s ease forwards, 5s logo-triangle-3 0.1s linear infinite;\n    }\n\n\n    @keyframes DrawSvgPath\n        {\n        to {\n            stroke-dashoffset: 0;\n        }\n        }\n\n    @keyframes logo-triangle-1\n    {\n        0% { fill: var(--color-blue); }\n        25% { fill: var(--color-blue); }\n        50% { fill: var(--color-blue); }\n        75% { fill: var(--color-violet-light); }\n        100% { fill: var(--color-blue); }\n    }\n\n    @keyframes logo-triangle-2\n    {\n        0% { fill: var(--color-violet-light); }\n        25% { fill: #E0BDED; }\n        50% { fill: var(--color-blue); }\n        75% { fill: var(--color-blue); }\n        100% { fill: var(--color-violet-light); }\n    }\n\n    @keyframes logo-triangle-3\n    {\n        0% { fill: var(--color-violet-mid); }\n        25% { fill: var(--color-violet-light); }\n        50% { fill: var(--color-violet-light); }\n        75% { fill: var(--color-violet-dark); }\n        100% { fill: var(--color-violet-mid); }\n    }\n</style>\n```\n\n</details>\n\n- Register this component in **App.vue**\n```JS\nexport default {\n  components: {\n    Loader: () => import("./components/AnimatedRobonomicsLogo")\n  }\n}\n```\n- Insert it with conditional Vue directive `v-if`, using the already known variable `load`:\n```HTML\n<div class="content" :class="{ load: load }">\n  <Loader v-if="load" />\n  <template v-else>\n    \x3c!-- here will be main content of loaded dapp --\x3e\n  </template>\n</div>\n```\n- Watch the result in browser. It has some issues that we will fix now:\n\n1. Loader pops up to the title (it should be in the center). Let\'s insert these lines to **app.css**:\n```css\nbody, html, #app {\n  height: 100%;\n  position: relative;\n}\n```\n2. If your connection goes too fast, you will see just blinking loader for a moment. It may confuse a lot. Let\'s set a timeout for the app\'s responce. To do that open **api.js** and find in the function `initAccount` this code:\n```JS\nconst timeout = new Promise(resolve => {\n  setTimeout(resolve, 300);\n});\n```\nI set `1700` instead of `300` and check the result:\n\n![Dapp Interface changing step 3](../images/build-dapp-interface/dapp-3.gif "Dapp Interface changing step 3")\n\n\n## Using reusable components\n\nYou have already watched how to register and use a component in the previous section about Loader, but now I want to focus on it more carefully.\n\nLet\'s change the Account section. Here I will use self-written components (box, button, icon) and the third party\'s one ([from Vue Polkadot Library](https://vue-polkadot.js.org/vue-ui/vue-identicon/#vue-polkadot-vue-identicon )).\n\n### Adding the box\n\n<details>\n\n<summary>Create Box component in ./src/components/Box.vue file </summary>\n\n```HTML\n<template>\n    <section class="box" :class="classList">\n        <slot />\n    </section>\n</template>\n\n<script>\n\nexport default {\n\n  props: {\n    classList: {\n      type: String\n    },\n  },\n\n};\n<\/script>\n\n<style>\n    /*\n    Global styles required for css variables from variables.css\n    */\n\n    .box {\n        background-color: var(--color-light);\n        border: 1px solid var(--color-dark);\n        padding: calc(var(--space)*0.5) var(--space);\n        box-shadow: 2px 2px 0 var(--color-dark);\n        margin-bottom: calc(var(--space)*1.5);\n    }\n</style>\n```\n</details>\n\nNow we can use it many times throught out the dapp. Let\'s see this on the Account section example:\n\n- Register component (**App.vue**):\n\n```JS\nexport default {\n  components: {\n    Box: () => import("./components/Box")\n  }\n}\n```\n\n- Use it for the Account section with an additional class passed with prop `classList`:\n\n```HTML\n<Box :classList="\'account\'">\n  Account: <b>{{ account }}</b> {{ balance }} |\n  <button @click="faucet">\n    faucet\n  </button>\n</Box>\n```\n\n**Check the result:**\n![Dapp Interface changing step 4](../images/build-dapp-interface/dapp-4.png "Dapp Interface changing step 4")\n\n### Adding the button\n\nYou may even not notice the button in the box that we have added. Let\'s fix it and add a component for buttons as it is not the only button in the app.\n\n<details>\n\n<summary>Create Button component in ./src/components/Button.vue file </summary>\n\n```HTML\n<template>\n  <button type="button" :class="classList" @click="onClick" :disabled="disabled" class="inline-block">\n    {{ label }}\n  </button>\n</template>\n\n<script>\n\nexport default {\n\n  components: {\n    Icon: () => import("./Icon")\n  },\n\n  props: {\n    label: {\n      type: String,\n    },\n    type: {\n      type: String,\n      default: \'primary\',\n      validator: function (value) {\n        return [\'primary\', \'secondary\'].indexOf(value) !== -1;\n      }\n    },\n    disabled: {\n      type: Boolean,\n      default: false,\n    },\n    size: {\n      type: String,\n      default: \'medium\',\n      validator: function (value) {\n        return [\'small\', \'medium\', \'large\'].indexOf(value) !== -1;\n      }\n    }\n  },\n\n  computed: {\n    classList() {\n      return {\n        \'button\': true,\n        [`${this.type}`]: true,\n        [`button__${this.size}`]: true,\n      };\n    },\n  },\n\n  methods: {\n    onClick() {\n      this.$emit(\'onClick\');\n    },\n  },\n\n};\n<\/script>\n\n<style>\n    /*\n    Global styles required for css variables from variables.css\n    */\n\n    .button {\n        appearance: none;\n        -webkit-appearance: none;\n        outline: 0;\n        border: 0;\n\n        transition: 0.1s all linear;\n\n        padding: .15rem 0.6rem;\n        border-width: 1px;\n        border-style: solid;\n        border-radius: .25rem;\n  \n        cursor: pointer;\n\n        font-family: var(--font-family);\n        font-size: calc(var(--font-size)*0.9);\n        line-height: 1;\n        font-weight: 500;\n\n        text-transform: uppercase;\n        letter-spacing: 1px;\n    }   \n\n    .button:not([disabled]):hover {\n    filter: saturate(1.5);\n    }\n\n    .button[disabled] {\n        cursor: default;\n        opacity: 0.6;\n    }\n\n    button.primary {\n        border-color: var(--color-green);\n        background-color: var(--color-green);\n        color: var(--color-light);\n    }\n\n    button.secondary {\n        border-color: var(--color-blue);\n        color: var(--color-blue);\n    }\n\n    button.secondary:not([disabled]):hover {\n        background-color: var(--color-blue);\n        color: var(--color-light);\n    }\n\n    .button__small {\n        font-size: .85rem;\n        padding: .1rem 0.45rem;\n    }\n\n    .button__large {\n        font-size: 1.2rem;\n        padding: .5rem 1.7rem;\n    }\n\n</style>\n```\n</details>\n\n\n- Register the component (**App.vue**):\n\n```JS\nexport default {\n  components: {\n    Button: () => import("./components/Button")\n  }\n}\n```\n\n- Use it for the \'Faucet\' button with props defined in the \'Button\' component\n\n```HTML\n<Box :classList="\'account\'">\n  Account: <b>{{ account }}</b> {{ balance }}\n  <Button label="Faucet" size="large" @onClick="faucet" />\n</Box>\n```\n\n**We get this view:**\n![Dapp Interface changing step 5](../images/build-dapp-interface/dapp-5.png "Dapp Interface changing step 5")\n\nFor the Button component we have emited the click from prop with `@onClick`, so I will pay attention if the faucet function is working correctly now (the balance should change on click):\n\n![Dapp Interface changing step 6](../images/build-dapp-interface/dapp-6.gif "Dapp Interface changing step 6")\n\n### Adding the icon\n\nLet\'s add an icon to this button to attract more attention to this element of the interface, as user can\'t interact with the dapp properly without units and clicking on this button.\n\nFor this purpose you can use any ready Vue library for icons, I will create my own component with the icon.\n\n- I found an appropriate icon on [the big online archive of icons](https://www.flaticon.com).\n- Downloaded .svg file and edited it in the vector graphics editor to make the proper size.\n- Inserted svg as a text in the Icon.vue component.\n\n<details>\n\n<summary>Here is what I got as the Icon.vue component</summary>\n\n```JS\n<template>\n  <div class="icon inline-block" :class="classList">\n    <svg v-if="icon == \'faucet\'" class="icon-fill" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" :width="SvgWidth(20)"  viewBox="0 0 20 24.9" style="enable-background:new 0 0 20 24.9;" xml:space="preserve">\n      <path d="M2.7,24.9c0.2,0,2.4,0,2.4-2.4c0-2-2.2-5.2-2.2-5.2s-2.5,3.3-2.5,5.3C0.4,24.6,2.4,24.9,2.7,24.9z M20,10.8V7.2V3.1h-2.6v2.6h-3.1V1.5h2.6c0.4,0,0.8-0.3,0.8-0.8S17.3,0,16.9,0h-6.7C9.8,0,9.5,0.3,9.5,0.8s0.3,0.8,0.8,0.8h2.6v4.1H7.9c-4.7,0-6.2,3.2-6.3,4.8c0,0,0,0.1,0,0.1v2.8H0v2.1h6.2v-2.1H4.6v-2.7c0-0.3,0.4-1.9,3.3-1.9h9.6v2.1L20,10.8L20,10.8z"/>\n    </svg>\n\n  </div>\n</template>\n\n<script>\n\nexport default {\n  props: {\n    icon: {\n      type: String\n    },\n    classList: {\n      type: String\n    },\n    scale: {\n      type: String,\n      default: \'1\'\n    },\n  },\n\n  methods: {\n    SvgWidth(SvgWidth) {\n      return `${SvgWidth * this.scale}px`;\n    }\n  }\n};\n<\/script>\n\n<style>\n.icon {\n    line-height: 1;\n}\n</style>\n\n```\n\n</details>\n\nTo use it with the button, edit the Button component.\n\nImport the Icon in **Button.vue**:\n\n```JS\ncomponents: {\n    Icon: () => import("./Icon")\n}\n```\n\nRegister prop:\n\n```JS\nprops: {\n  icon: {\n    type: String,\n    default: \'none\'\n  }\n}\n```\n\nAdd the Icon to the button (we can specify different templates with `v-if` condition):\n\n```HTML\n<template v-if="icon != \'none\'">\n  <Icon :icon="icon" />\n  <span v-if="label != \'\'" class="inline-block">{{ label }}</span>\n</template>\n<template v-if="icon == \'none\' & label != \'\'">\n  {{ label }}\n</template>\n```\n\nAdd styles:\n\n```CSS\n.button .icon-fill path {\n  fill: var(--color-light);\n}\n\n.button > *:not(:last-child) {\n  margin-right: calc(var(--space)/2);\n}\n\n```\n\nAdd the icon prop into the button in **App.vue**:\n\n```HTML\n<Button label="Faucet" size="large" icon="faucet" @onClick="faucet" />\n```\n\n**Check:**\n\n![Dapp Interface changing step 7](../images/build-dapp-interface/dapp-7.png "Dapp Interface changing step 7")\n\n### Add the Polkadot avatar\n\n- Install [@vue-polkadot/vue-identicon](https://vue-polkadot.js.org/vue-ui/vue-identicon/#vue-polkadot-vue-identicon)\n\n- Import to App.vue:\n```JS\ncomponents: {\n    Identicon: () => import("@vue-polkadot/vue-identicon")\n}\n```\n\n- Insert the avatar instead of the word \'Account\', pass props according to the documentation, use `account` data as a value prop:\n```HTML\n<Identicon\n  :value="account"\n  :theme="\'polkadot\'"\n  :size="40"\n  :class="\'inline-block\'"\n/>\n```\n\n**Check:**\n\n![Dapp Interface changing step 8](../images/build-dapp-interface/dapp-8.png "Dapp Interface changing step 8")\n\n## Data manipulation for the better view\n\nLet\'s cut the account address:\n\n- Wrap the variable `account` in the computed property:\n\n```JS\ncomputed: {\n  AccountAddress() {\n    return this.account.slice(0, 6) + "..." + this.account.slice(-4);\n  }\n}\n```\n\n- Replace the variable `account` with `AccountAddress` in the template\n\n**Check:**\n\n![Dapp Interface changing step 9](../images/build-dapp-interface/dapp-9.png "Dapp Interface changing step 9")\n\n## CSS magic\n\nLet\'s prettify the account section a little bit more:\n\n<details>\n\n<summary>Template</summary>\n\n```HTML\n<Box :classList="\'account\'">\n              \n  <div class="account__address">\n    <Identicon\n      :value="account"\n      :theme="\'polkadot\'"\n      :size="40"\n      :class="\'inline-block\'"\n    />\n\n    <code class="inline-block">{{ AccountAddress }}</code>\n  </div>\n  \n  <div class="account__balance">{{ balance }}</div>\n\n  <Button label="Faucet" size="large" @onClick="faucet" />\n  \n</Box>\n```\n\n</details>\n\n\n<details>\n\n<summary>Styles (in app.css)</summary>\n\n```CSS\n.account {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  align-items: center;\n  justify-items: stretch;\n  column-gap: var(--space);\n}\n\n.account__balance {\n    font-size: 150%;\n    font-weight: 500;\n    font-family: var(--font-family-code);\n    white-space: nowrap;\n}\n\n.account__address > *:not(:last-child) {\n    margin-right: calc(var(--space)/2);\n}\n```\n\n</details>\n\n![Dapp Interface changing step 10](../images/build-dapp-interface/dapp-10.gif "Dapp Interface changing step 10")\n\nLet\'s edit styles for the tabs:\n\n<details>\n\n<summary>Styles (in app.css)</summary>\n\n```CSS\n.tabs {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  margin-top: calc(var(--space)*2.5);\n}\n\n.tabs button {\n  text-transform: uppercase;\n  letter-spacing: 1px;\n  border-width: 0 0 1px;\n  font-family: var(--font-family);\n  font-size: calc(var(--font-size)*1.5);\n  font-weight: 300;\n  cursor: pointer;\n  transition: 0.2s all linear;\n}\n\n.tabs button:not(.active) {\n  opacity: 0.5;\n  border-color: var(--color-gray)\n}\n\n.tabs-content {\n  padding-top: var(--space);\n}\n```\n\n</details>\n\n<details>\n\n<summary>Minimal template changes:</summary>\n\n```HTML\n<div class="tabs-content">\n  <Demo v-if="tab === \'demo\'" :api="api" :account="account" />\n  <Launch v-if="tab === \'launch\'" :api="api" :account="account" />\n  <Datalog v-if="tab === \'datalog\'" :api="api" :account="account" /> \n</div>\n```\n\n</details>\n\n![Dapp Interface changing step 11](../images/build-dapp-interface/dapp-11.gif "Dapp Interface changing step 11")\n\n> Let me remind you that the finished code for this tutorial is in [this](https://github.com/positivecrash/wscool21-ui-dapp) repository. And let\'s shift to the next steps :)\n\n## Datalog\n\nStart with fixing UI elements that are already known in the dapp: buttons (same as we have done for the \'Faucet\', but with different props).\n\nThen I will wrap these elements in `<fieldset>` to separate them by meaning. And I will write my own styles for the fieldset and input elements.\n\n<details>\n\n<summary>Template in Datalog.vue:</summary>\n\n```HTML\n<div class="tools">\n  <fieldset>\n    <Button label="Read data" size="large" type="secondary" @onClick="read" />\n  </fieldset>\n\n  <fieldset>\n    <input v-model="data" :disabled="isWrite" class="large" />\n    <Button label="Write" :disabled="isWrite" size="large" type="secondary" @onClick="write" />\n  </fieldset>\n</div>\n```\n\n</details>\n\n\n<details>\n\n<summary>Styles for input elements in app.css - it\'s supposed to be global:</summary>\n\n```CSS\ninput, select{\n  padding: .3rem 0.6rem;\n  border: 1px solid var(--color-gray);\n  background-color: var(--color-light);\n  border-radius: var(--radius);\n  font-size: var(--font-size);\n  font-family: var(--font-family-code);\n  border-radius: .25rem;\n  transition: 0.2s ease all;\n}\n\ninput:focus {\n  border-color: var(--color-dark);\n}\n\ninput.large, select.large {\n  font-size: 1.2rem;\n  padding: .35rem 1rem;\n}\n\n\n.tools *, .tools fieldset:not(:last-child):after {\n  display: inline-block;\n  vertical-align: middle;\n  vertical-align: -moz-middle-with-baseline;\n  vertical-align: -webkit-baseline-middle;\n}\n\n.tools fieldset {\n  border: 0;\n}\n\n.tools fieldset:not(:last-child):after {\n  content: "•";\n}\n\n.tools fieldset > *,  .tools > * {\n  margin-right: calc(var(--space)/2)\n}\n```\n\n</details>\n\n**Let\'s check that everything works fine after updates:**\n\n![Dapp Interface changing step 12](../images/build-dapp-interface/dapp-12.gif "Dapp Interface changing step 12")\n\nWe have a datalog section through out the dapp, so I\'ll make a component for it.\n\n<details>\n\n<summary>I have got the following code for a new component DatalogSection.vue</summary>\n\n```HTML\n<template>\n    <div v-if="log" class="log">\n        <h4 class="log-title">Datalog</h4>\n\n        <div class="log-content">\n\n          <p v-if="log.length === 0" class="error">Not found</p>\n\n          <details v-for="(item, k) in log" :key="k" class="box" :open="k === 0">\n              <summary>{{ item[0] }}</summary>\n              <pre>{{ item[1] }}</pre>\n          </details>\n        </div>\n    </div>\n</template>\n\n<script>\n\nexport default {\n\n  props: {\n    log: {\n      type: Array\n    }\n  },\n\n}\n\n<\/script>\n\n<style>\n\n.log {\n  text-align: left;\n  margin: var(--space) auto;\n  width: 100%;\n}\n\n.log-content {\n  border: 1px solid var(--color-gray);\n  max-height: 500px;\n  overflow-y: auto;\n  padding: var(--space);\n  background-color: var(--color-gray-middark);\n  outline: 1px solid #fff;\n  box-shadow: 0 0 60px 20px #fff inset;\n}\n\n.log-title {\n  color: var(--color-gray-dark);\n  font-weight: 300;\n  font-family: var(--font-family-code);\n\n  border-bottom: 1px solid var(--color-gray);\n}\n\n.log .box {\n  margin-bottom: var(--space);\n}\n\ndetails {\n  transition: 0.2s all ease;\n}\n\ndetails summary {\n  cursor: pointer;\n}\n\ndetails.box {\n  padding-top: 0;\n  padding-bottom: 0;\n}\n\ndetails.box[open] {\n  padding-bottom: calc(var(--space)*0.5);\n}\n\ndetails.box:focus {\n  box-shadow: 0 0 5px var(--color-gray)\n}\n\ndetails.box summary {\n  padding-top: calc(var(--space)*0.5);\n  padding-bottom: calc(var(--space)*0.5);\n}\n\ndetails.box[open] summary {\n  border-bottom: 1px solid var(--color-dark);\n  margin-bottom: calc(var(--space)*0.5);\n  font-weight: 500;\n}\n\n.log details.box summary {\n  font-family: var(--font-family-code);\n}\n\n</style>\n```\n\n</details>\n\nWhat you should pay attention to here: we pass prop `log` as an array. I assume that this multidimensional array will contain log of entries and every entry has a title (I wrote there date for all logs in the dapp) and content. We need to reformat arrays in components **Datalog.vue** and **Launch.vue**.\n\nNow edit **Datalog.vue**. Find method, where we get the log:\n```JS\nasync read() {\n  this.log = (await this.api.query.datalog.datalog(this.account)).toArray();\n}\n```\n\nNow we have to format data in **Datalog.vue**, and pass ready log array for **DatalogSection.vue**. So let\'s map the log array:\n```JS\nasync read() {\n  this.log = (await this.api.query.datalog.datalog(this.account)).toArray().map((item) => {\n    return [new Date(Number(item[0])).toLocaleString(), u8aToString(item[1])]\n  });\n}\n```\n\nWe don\'t need this code anymore:\n```JS\nfilters: {\n  dateFormat: function(v) {\n    return new Date(Number(v)).toLocaleString();\n  },\n  dataFormat: function(v) {\n    return u8aToString(v);\n  }\n}\n```\n\n**Let\'s check the datalog section in Datalog tab:**\n\n![Dapp Interface changing step 13](../images/build-dapp-interface/dapp-13.gif "Dapp Interface changing step 13")\n\n## Launch\n\nFor this step, most of improvements have already been done, we just need to apply them to the template: import Button and Datalog components, remove the excessive title:\n\n![Dapp Interface changing step 14](../images/build-dapp-interface/dapp-14.gif "Dapp Interface changing step 14")\n\nLet\'s replace `select` control element with `checkbox`.\n\nInstead of this:\n```HTML\n<select v-model="parameter" :disabled="isWrite">\n  <option value="ON">ON</option>\n  <option value="OFF">OFF</option>\n</select>\n```\n\nWrite this:\n```HTML\n<div class="toggler inline-block">\n  <input v-model="parameter" :disabled="isWrite" type="checkbox" id="robot-switch" />\n  <label for="robot-switch"><span></span></label>\n</div>\n```\n\n<details>\n\n<summary>Styles in app.css:</summary>\n\n```CSS\n.toggler input { display: none; }\n.toggler label {\n  position: relative;\n  display: block;\n  width: 60px;\n  height: 40px;\n  border-radius: 4px;\n  font-weight: 500;\n  text-transform: uppercase;\n  letter-spacing: 1px;\n  cursor: pointer;\n  background-color: var(--color-gray);\n  color: var(--color-light);\n  text-align: center;\n}\n\n.toggler label:before {\n  content: \'Off\';\n  width: 100%;\n  text-align: center;\n  line-height: 40px;\n}\n\n.toggler label:after {\n  content: \'\';\n  display: block;\n  width: 6px;\n  height: 100%;\n  border-radius: 10px;\n  background-color: var(--color-gray-dark);\n\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: 10;\n\n  transition: 0.3s ease-out all;\n}\n\n.toggler input:checked + label {\n  background-color: var(--color-green);\n}\n\n.toggler input:checked + label:before {\n  content: \'On\';\n}\n\n.toggler input:checked + label:after {\n  transform: translateX(54px);\n  background-color: #007038;\n}\n```\n\n</details>\n\n![Dapp Interface changing step 15](../images/build-dapp-interface/dapp-15.gif "Dapp Interface changing step 15")\n\nI want to clarify something with the interface: with these elements we start some device. Let\'s visualize it. I\'ve chosen a drone, so I will toggle classes according to `item.parameter`.\n\nCreate a new property in `data`:\n```JS\ndata() {\n  status: false\n}\n```\n\nAssign value of `parameter` to `status` after button is clicked and tx is sent to the block:\n```JS\nmethods: {\n    async launch() {\n      try {\n        this.error = "";\n        this.isWrite = true;\n\n        const tx = await this.api.tx.launch\n          .launch(this.robot, this.parameter === "ON")\n          .signAsync(this.account);\n\n        await tx.send(result => {\n          if (result.status.isInBlock) {\n            this.isWrite = false;\n            this.status = this.parameter; // new line here\n          }\n        });\n      } catch (error) {\n        this.error = error.message;\n        this.isWrite = false;\n      }\n    }\n  }\n```\n\nWrite styles for the drone in **Launch.vue**. Don\'t forget `scoped` for `<style>` tag, to apply styles only for this component.\n\n<details>\n\n<summary>CSS for drone:</summary>\n\n```CSS\n<style scoped>\n.tools {\n  position: relative;\n  padding-left: 120px;\n  text-align: left;\n  display: inline-block;\n}\n\n.launch-drone {\n  position: absolute;\n  width: 100px;\n  left: 0;\n  filter: grayscale(1);\n  transition: 1s all ease-in;\n}\n\n.launch-drone.on {\n  filter: grayscale(0);\n  animation: DroneLaunch 10s linear infinite;\n}\n\n@keyframes DroneLaunch {\n  0%, 20%, 40%, 60%, 80%, 100% {\n    transform: translateY(0);\n  }\n  10%, 30%, 50%, 70%, 90% {\n    transform: translateY(-20%);\n  }\n}\n</style>\n```\n\n</details>\n\n![Dapp Interface changing step 16](../images/build-dapp-interface/dapp-16.gif "Dapp Interface changing step 16")\n\nNow let\'s add the **DatalogSection.vue** component.\n\n```JS\ncomponents: {\n  DatalogSection: () => import("./DatalogSection")\n}\n```\n\nReformat the log array from:\n\n```JS\nthis.log.push({\n  sender,\n  robot,\n  parameter\n});\n```\n\nto (for structure like `[["entry 1 date", "entry 1 content"], ["entry 2 date", "entry 2 content"]]`):\n\n```JS\nthis.log.push([new Date().toLocaleString(), {\n  sender,\n  robot,\n  parameter\n}]);\n```\n\nReplace the code from the template:\n\n```HTML\n<div v-if="log.length > 0" class="log">\n  <div v-for="(item, k) in log" :key="k" class="row">\n    sender: <b>{{ item.sender }}</b>\n    <br />\n    robot: <b>{{ item.robot }}</b>\n    <br />\n    parameter: <b>{{ item.parameter ? "ON" : "OFF" }}</b>\n  </div>\n</div>\n```\n\nwith this:\n\n```HTML\n<DatalogSection :log="log"/>\n```\n\n**Check:**\n![Dapp Interface changing step 17](../images/build-dapp-interface/dapp-17.gif "Dapp Interface changing step 17")\n\nSometimes you get some errors, it\'s almost inevitable. Something can go wrong with the connection or anything else can happen. So we have fallbacks with error messages through out the dapp, I haven\'t changed them from the start, in the code they look like:\n\n```HTML\n<div v-if="error" class="error">{{ error }}</div>\n```\n\nOn the interface errors look this way now:\n\n![Dapp Interface changing step 18](../images/build-dapp-interface/dapp-18.png "Dapp Interface changing step 18")\n\nAdd styles for the `.error` in **app.css**:\n\n```CSS\n.error {\n  font-weight: 400;\n  text-transform: uppercase;\n  letter-spacing: 1px;\n  color: var(--color-red);\n}\n```\n\nAnd I will fix a space between the `.tools` section and other content from the bottom as well in **app.css**:\n\n```CSS\n.tools {\n  margin-bottom: var(--space);\n}\n```\n\nWe get:\n\n![Dapp Interface changing step 19](../images/build-dapp-interface/dapp-19.png "Dapp Interface changing step 19")\n\nNow on this page we have to "primary" buttons. Technically it is okay, but this is not okay from the above user experience. It\'s better not to use more than one prevailing button on the screen. So let\'s fix it and add for the `Button` in **Launch.vue** with property `type="secondary"`:\n\n![Dapp Interface changing step 20](../images/build-dapp-interface/dapp-20.png "Dapp Interface changing step 20")\n\nGreat, now I\'ll fix some issues with my node and go to the Demo step.\n\n## Demo\n\nFor the start, I\'d like to swap tabs, to pay more attention to the most relevant one, but this is not the first step that we do to practice. Reverse tabs in **App.vue**.\n\nDon\'t forget to replace the default data:\n\n```JS\ndata() {\n    return {\n      ...\n      tab: "demo"\n    };\n},\n```\n\n![Dapp Interface changing step 21](../images/build-dapp-interface/dapp-21.png "Dapp Interface changing step 21")\n\nAs usual let\'s start with changing what we have already got.\n\n- Remove the title `<h2>Demo</h2>` as in the previous steps\n- Find UI elements that we have already learn – datalog, buttons, account address. But not so fast. Now we\'ll change the datalog only.\n\nAdd the component to **Demo.vue**:\n\n```JS\ncomponents: {\n  DatalogSection: () => import("./DatalogSection")\n}\n```\n\n```HTML\n<DatalogSection :log="log"/>\n```\n\nWe\'ve got raw data in the log, so we need to reformat the array with the log to pass in the component ready-view data as in the previous steps. Find the line `return [item[0], item[1]];` in `async created()` and replace it with:\n\n```JS\nreturn [new Date(Number(item[0])).toLocaleString(), JSON.parse(u8aToString(item[1]))];\n```\n\nRemove the unused code from the log:\n\n```HTML\n<div v-if="log" class="log">\n  <p v-if="log.length === 0" class="error">Not found</p>\n  <div v-for="(item, k) in log" :key="k" class="row">\n    <b>{{ item[0] | dateFormat }}</b>\n    <pre>{{ item[1] | dataFormat }}</pre>\n  </div>\n</div>\n```\n\nand:\n\n```JS\nfilters: {\n  dateFormat: function(v) {\n    return new Date(Number(v)).toLocaleString();\n  },\n  dataFormat: function(v) {\n    return JSON.parse(u8aToString(v));\n  }\n},\n```\n\n**Check:**\n![Dapp Interface changing step 22](../images/build-dapp-interface/dapp-22.png "Dapp Interface changing step 22")\n\nFor customization of this demo example with launching a robot, you are free to come up with any idea. Personally, I started with this town:\n\n![Dapp Interface changing step 23](../images/build-dapp-interface/dapp-23.gif "Dapp Interface changing step 23")\n\nI won\'t show the whole code for this not to confuse you at all, but schematically there will be something like this:\n\n```HTML\n<div class="demo" :class="[robot.state ? \'play\' : \'stop\']">\n  <div class="demo-back"></div>\n  <div class="demo-city"></div>\n  <div class="demo-car"></div>\n</div>\n```\n\nThan within the element `.demo.play` write styles for moving the city backward, and the car forward.\n\nWhile working on this, I came up with the idea of realization the CyberPunk city. As I have no any particullar task, so the car became a taxi, driver became a passenger, and now on the interface we have an AI robot hologram welcoming the passenger (these all are just CSS and graphics tweaks&&tricks).\n\n**The code for the Cyberpunk city demo:**\n\n<details>\n\n<summary>Template</summary>\n\n```HTML\n<div class="demo" :class="[robot.state ? \'play\' : \'stop\']">\n  <div class="demo-back-1"></div>\n  <div class="demo-back-2"></div>\n  <div class="demo-city-1"></div>\n  <div class="demo-car"></div>\n\n  <div class="demo-data">\n    <div class="demo-data-driver inline-block">\n      <img alt="Driver\'s avatar" src="../assets/images/cabman.png" v-if="robot.state"/>\n    </div>\n    <div class="demo-data-lines inline-block">\n      <div class="demo-data-line">\n          <div>Robot</div>\n          <div>[ {{ addressShort(robot.address) }} ]</div>\n      </div>\n\n      <div class="demo-data-line" v-if="robot.state">\n          <div>Passenger</div>\n          <div>[ {{ addressShort(robot.driver) }} ]</div>\n      </div>\n\n      <div class="demo-data-welcome" v-if="robot.state">\n          <span>Hello, passenger. </span>\n          <span>I\'ve linked to the vehicle. </span>\n          <span>Your ride begins, congrats! </span>\n      </div>\n    </div>\n\n  </div>\n\n  <Button :label="robot.state ? \'stop\' : \'run\'" :disabled="isWrite" size="large" @onClick="run" />\n</div>\n```\n\n</details>\n\nThere are more than one hash address that should be shortenned, so I added the method:\n\n```JS\nmethods: {\n  addressShort(address) {\n    return address.slice(0, 6) + "..." + address.slice(-4);\n  }\n}\n```\n\nDon\'t forget to register the Button component\n\n```JS\ncomponents: {\n  Button: () => import("./Button")\n}\n```\n\n<details>\n\n<summary>Styles</summary>\n\n```CSS\n<style scoped>\n.demo {\n    --h: 120px;\n    --color-yellow: #F2F209;\n\n    background-color: #AFCCD3;\n\n    background: linear-gradient(#010123, #4baac7);\n\n    position: relative;\n    height: 500px;\n    overflow: hidden;\n\n    border-width: 2px 2px 2px 15px;\n    border-style: solid;\n    border-color: var(--color-yellow);\n    \n}\n\n.demo:before {\n    content: \'[ Delamain cabs rental DEMO ]\';\n    background-color: var(--color-yellow);\n    color: #000;\n\n    position: absolute;\n    top: 0;\n    left: 0;\n    padding: .5rem 1rem;\n\n    text-transform: uppercase;\n    letter-spacing: 1px;\n    font-weight: 300;\n\n    border-width: 0 6px 2px 0;\n    border-style: solid;\n    border-color: #7B186E;\n}\n\ndiv[class^=demo-back-], div[class^=demo-city-] {\n    position: absolute;\n    left: 0;\n    width: 100%;\n    z-index: 2;\n}\n\ndiv[class^=demo-back-]{\n    border-top: 1px solid #364444;\n}\n\ndiv[class^=demo-city-] {\n    background-repeat: repeat-x;\n    background-size: cover;\n    background-position: 100% 0;\n\n    height: 300px;\n    bottom: var(--h);\n\n    animation: 50s MoveCity infinite linear 1.5s;\n}\n\ndiv.demo-back-1 {\n    background-color: #060236;\n    background: linear-gradient(#7B186E, #060236);\n    height: var(--h);\n    bottom: 0;\n}\n\ndiv.demo-back-2 {\n    background-color: #c515ae;\n    border-width: 2px 0;\n    border-style: solid;\n    border-color: #69045c;\n\n    height: 20px;\n    bottom: var(--h);\n    z-index: 10;\n}\n\ndiv.demo-city-1 {\n    background-image: url(../assets/images/city-1.png);\n}\n\n.demo-car {\n    background-image: url(../assets/images/car.png);\n    background-size: contain;\n    background-repeat: no-repeat;\n    background-position: 100% 0;\n\n    width: calc(508px * 0.5);\n    height: calc(257px * 0.5);\n    position: absolute;\n    bottom: calc(var(--h) + 4px);\n    z-index: 10;\n\n    transform: translateX(-100px);\n    animation: MoveCar 50s infinite 1.5s linear;\n}\n\n.demo.play div[class^=demo-city-], .demo.play .demo-car { animation-play-state: running; }\n.demo.stop div[class^=demo-city-], .demo.stop .demo-car { animation-play-state: paused; }\n\n.demo.play .demo-car {\n    background-image: url(../assets/images/car-ride.png);\n}\n\n\n.demo button {\n    background-color: var(--color-yellow);\n    border-color: var(--color-yellow);\n    color: #000;\n\n    position: absolute;\n    bottom: 30px;\n    right: 30px;\n    z-index: 1000;\n}\n\n.demo-data {\n    position: absolute;\n    bottom: 30px;\n    left: 30px;\n    z-index: 1000;\n\n    background-color: rgba(0, 0, 0, .5);\n    color: #fff;\n    padding: .5rem;\n    font-family: var(--font-family-code);\n\n    transition: 0.2s all ease;\n}\n\n.demo-data-lines {\n    max-width: 400px;\n}\n\n.demo-data-line {\n    display: grid;\n    grid-template-columns: 100px auto;\n    gap: .5rem;\n    text-align: left;\n}\n\n.demo-data-line div:first-child {\n    text-transform: uppercase;\n    letter-spacing: 1px;\n    font-weight: 700;\n}\n\n.demo-data-driver {\n    margin-right: 1rem;\n}\n\n.demo-data-driver img {\n    display: block;\n    max-width: 100px;\n\n    visibility: hidden;\n    opacity: 0;\n    animation: FadeInBlink .3s cubic-bezier(0.075, 0.82, 0.165, 1) 0.6s forwards;\n}\n\n.demo-data-welcome {\n    text-align: left;\n    padding-top: .5rem;\n}\n\n.demo-data-welcome span {\n    visibility: hidden;\n    opacity: 0;\n\n    animation-name: FadeIn;\n    animation-timing-function: cubic-bezier(0.075, 0.82, 0.165, 1);\n    animation-duration: 0.6s;\n    animation-fill-mode: forwards;\n}\n\n.demo-data-welcome span:nth-child(1) { animation-delay: 1.5s; }\n.demo-data-welcome span:nth-child(2) { animation-delay: 2.5s; }\n.demo-data-welcome span:nth-child(3) { animation-delay: 3.2s; }\n\n\n@keyframes MoveCity\n{\n  100% {\n    background-position: -1000px 0;\n  }\n}\n\n@keyframes MoveCar\n{\n    0% {\n        transform: translateX(-100px);\n    }\n    100% {\n        transform: translateX(960px);\n    }\n}\n</style>\n\n```\n\n</details>\n\n**Result:**\n\n![Dapp Interface changing step 25](../images/build-dapp-interface/dapp-25.gif "Dapp Interface changing step 25")\n\n## Conclusion\n\nCongratulations! Now you have redesigned the dapp and clues how to start building your application\'s interface.\n\n### Checkout links\n\n- [Full code of this tutorial](https://github.com/positivecrash/wscool21-ui-dapp)\n- [Discuss in Discord](https://discord.gg/5UWNGNaAUf)\n- [View the Robonomics Winter School 2021 schedule and summary](https://robonomics.network/blog/winter-robonomics-school/)\n- [Github of contributor](https://github.com/positivecrash)\n\n### Practice\n\nIf you have some extra time or want to practice your skills, there are some ideas for improvements that you could make to this demo:\n\n- Adapt UI for narrow screens, make the dapp mobile-friendly\n- Add the \'day/night\' mode, by editing the **_variables.scss** file and the template file of the dapp\n- Add \'Copy to clipboard\' buttons for addresses\n- Make delicate popus to inform users about changes (e.g. you can popup a message that units are received after clicking the \'Faucet\' button, or you can move in the popup an error that we had in the \'Launch\' section).\n\nPlease, fill free to ask questions and share your results in [Discord](https://discord.gg/5UWNGNaAUf), mark me in your message `@positivecrash`\n\n\n\n\n\n\n'}},{node:{id:"b30810c63d9d7e89c50523daf6d2024e",title:"Lesson 6.1, Build IoT Dapps For End Users",path:"/docs/ja/wschool2021-build-dapp-for-end-users/",content:'\n## Getting ready\n\n### Robonomics node launch\n\nFor dApp development and testing, we will use a local Robonomics node. To do this, you need to download the compiled binary file https://github.com/airalab/robonomics/releases. I will be using Ubuntu, so I download the appropriate version.\n\nUnpack the archive\n```sh\nwget https://github.com/airalab/robonomics/releases/download/v0.24.0/robonomics-ubuntu-0.24.0-x86_64.zip\nunzip robonomics-ubuntu-0.24.0-x86_64.zip\ncd robonomics-ubuntu-0.24.0-x86_64\nchmod +x robonomics\n```\n\nNow we can start the node in development mode. To do this, use the --dev flag\n```sh\n./robonomics --dev\n```\n\n> Troubleshooting\n```sh\n./robonomics purge-chain --dev\n```\n\n### Browser extension\n\nTo store keys in a browser, there is a `polkadot{.js} extension`. In dApp we will use it to sign transactions.\n\nThe extension is currently available for `Google chrome` and `Firefox` https://polkadot.js.org/extension/\n\nAfter installing the extension, create a new account.\n![screen1](../images/build-iot-dapps/screen1.png)\n\n> The first step is completed.\n\n## DApp development\n\n### Step 1\n\n> We will write the dApp using the vue.js framework, although you can use whatever you like/can.\n\nLet\'s start developing the dApp by creating a startup application with vue.js And here you can do it in two ways.\n\nWay 1:\n\nUsing the `Vue cli` console utility.\nTo do this, you need to install it https://cli.vuejs.org/guide/installation.html\n\nAfter installation, you can run the command in the terminal\n\n```sh\nvue create mydapp\n```\n\nAnswer a few questions of the setup wizard. We will be using version Vue 2, so we keep the default version `Default ([Vue 2] babel, eslint)`.\n\nWay 2:\n\nClone the prepared git repository with the example and switch to step 1\n\n```sh\ngit clone https://github.com/airalab/example-robonomics-dapp.git mydapp\ncd mydapp\ngit checkout step-1\n```\n\nAs a result, we will get a directory with the installed startup application, which can already be launched and opened in the browser.\n\n```sh\nyarn\nyarn serve\n```\n\n### Step 2. Getting started with polkadot.js\n\n#### Installing dependencies\n\nTo connect the dApp to the Robonomics chain, there is the `@polkadot/api` library. And for interaction of dApp with an extension with keys, we have the `@polkadot/extension-dapp` library. We need to install them into our application.\nMore details on using this library can be found in the documentation https://polkadot.js.org/docs/.\n\nWay 1:\n\n```sh\nyarn add @polkadot/api @polkadot/extension-dapp\n```\n\nYou also need to add the `vue.config.js` file to support `mjs` extension.\n\n`vue.config.js`\n```js\nmodule.exports = {\n  publicPath: "",\n  configureWebpack: {\n    resolve: {\n      extensions: ["*", ".mjs", ".js", ".vue", ".json", ".gql", ".graphql"]\n    },\n    module: {\n      rules: [\n        {\n          test: /\\.mjs$/,\n          include: /node_modules/,\n          type: "javascript/auto"\n        }\n      ]\n    }\n  }\n};\n```\n\n#### Connecting to Robonomics\n\nFirst, let\'s create a configuration file with the parameters for connecting to the Robonomics node. In the demo repository, there is an example of this file `config.template.json`.\n\n`src/config.json`\n```json\n{\n  "endpoint": "ws://localhost:9944",\n  "types": {\n    "Record": "Vec<u8>",\n    "Parameter": "Bool",\n    "Address": "AccountId",\n    "LookupSource": "AccountId"\n  }\n}\n```\n\nIn this file, we indicate the node, which we are going to connect to, and custom types. The types for Robonomics can be taken from github https://github.com/airalab/robonomics/blob/master/bin/node/cli/res/custom_types.json\n\nNow we need to write a script to connect to our running node.\n\n`src/utils/api.js`\n```js\nimport { ApiPromise, WsProvider } from "@polkadot/api";\nimport config from "../config.json";\n\nlet api;\nexport async function initApi() {\n  const provider = new WsProvider(config.endpoint);\n  api = await ApiPromise.create({\n    provider,\n    types: config.types\n  });\n  return api;\n}\n\nexport function getApi() {\n  return api;\n}\n```\n\nSo that we can sign transactions with the key from the extension, let’s add two functions for connecting to the extension and the function for initializing the account.\n\n`src/utils/api.js`\n```js\n...OTHER_CODE...\n\nimport {\n  web3Accounts,\n  web3Enable,\n  web3FromAddress\n} from "@polkadot/extension-dapp";\n\nasync function getExtension() {\n  const extensions = await web3Enable("demo");\n  if (extensions.length === 0) throw new Error("no extension");\n  return extensions[0];\n}\n\nexport async function initAccount(index = 0) {\n  const timeout = new Promise(resolve => {\n    setTimeout(resolve, 300);\n  });\n  await timeout;\n  await getExtension();\n  const accounts = await web3Accounts();\n  if (accounts.length > 0) {\n    const injector = await web3FromAddress(accounts[index].address);\n    api.setSigner(injector.signer);\n    return accounts[index].address;\n  }\n  throw new Error("no accounts");\n}\n\n...OTHER_CODE...\n```\n\nOur account will have a zero balance, while we need a little funds. So we need to create another faucet function. As we launched Robonomics with the `--dev` flag, we have `Alice` account with a large balance, so we will request funds from there.\n\n`src/utils/api.js`\n```js\n...OTHER_CODE...\n\nimport { Keyring } from "@polkadot/keyring";\n\nexport function getBalance(account, cb) {\n  api.query.system.account(account, ({ data: { free: currentFree } }) => {\n    cb(currentFree);\n  });\n}\n\nexport const keyring = new Keyring({ type: "sr25519" });\n\nexport async function faucet(address) {\n  keyring.setSS58Format(api.registry.chainSS58);\n  const account = keyring.addFromUri("//Alice");\n  const tx = api.tx.balances.transfer(address, 1000000000000000);\n  await tx.signAndSend(account);\n}\n\n...OTHER_CODE...\n```\n\nThe full version of script https://github.com/airalab/example-robonomics-dapp/blob/master/src/utils/api.js\n\nRun app\n\n```sh\nyarn serve\n```\n\nWay 2:\n\nIf you start the application with cloning the repository, then in order to complete these steps, it will be enough to switch to step 2 and install the rest of the dependencies.\n\n```sh\ngit checkout step-2\ncp src/config.template.json src/config.json\nyarn\nyarn serve\n```\n\n### Step 3. Vue connecting component\n\n#### Connecting\n\nWe have already written a script for connecting. Now we can use it on our interface. It is enough to call the written `initApi` function in  the root component `App.vue`. And while the user is waiting for a connection, we will show him a small loader, for now in the form of an ellipsis.\n\nWay 1:\n\nComponent template and base styles.\n\n`src/App.vue`\n```js\n<template>\n  <div id="app">\n    <h1>Robonomics dApp</h1>\n    <div v-if="load">...</div>\n    <template v-else>\n      <div v-if="error" class="error">{{ error }}</div>\n      <template v-else-if="api">\n        connected\n      </template>\n    </template>\n  </div>\n</template>\n\n...OTHER_CODE...\n\n<style>\n#app {\n  font-family: Avenir, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n  margin-top: 60px;\n}\nbutton {\n  font-size: 14px;\n  padding: 5px 12px;\n}\nbutton:hover {\n  cursor: pointer;\n}\ninput {\n  font-size: 14px;\n  padding: 5px;\n}\nselect {\n  font-size: 14px;\n  padding: 5px;\n}\nbutton:focus,\ninput:focus {\n  outline: none;\n}\n.error {\n  color: rgb(151, 31, 31);\n  font-weight: bold;\n  text-align: center;\n  margin: 10px 0;\n}\n</style>\n```\n\nThere is the component code where the  `initApi` function will be called\n\n`src/App.vue`\n```js\n<script>\nimport { initApi } from "./utils/api";\n\nexport default {\n  name: "App",\n  data() {\n    return {\n      load: false,\n      api: null,\n      error: null\n    };\n  },\n  created() {\n    this.init();\n  },\n  methods: {\n    async init() {\n      try {\n        this.load = true;\n        this.api = await initApi();\n        this.load = false;\n      } catch (error) {\n        this.error = error.message;\n        this.load = false;\n      }\n    }\n  }\n};\n<\/script>\n```\n\n#### Account with balance\n\nNow we can use our account, top up its balance and show it on the interface.\n\nLet’s add the appropriate markup to the template\n\n`src/App.vue`\n```js\n<template>\n\n  ...OTHER_CODE...\n\n    <template v-else>\n      <div v-if="error" class="error">{{ error }}</div>\n      <template v-else-if="api && account">\n        <p>\n          Account: <b>{{ account }}</b> {{ balance }} |\n          <button @click="faucet">\n            faucet\n          </button>\n        </p>\n      </template>\n    </template>\n\n  ...OTHER_CODE...\n\n</template>\n```\n\nLet’s add new fields for account address and balance\n\n`src/App.vue`\n```js\n\n...OTHER_CODE...\n\ndata() {\n  return {\n\n    ...OTHER_CODE...\n\n    account: null,\n    balance: 0,\n\n    ...OTHER_CODE...\n\n  };\n}\n\n...OTHER_CODE...\n```\n\nWe need to add the account initialization to the `init` function and get its balance\n\n`src/App.vue`\n```js\n<script>\nimport { initApi, initAccount, getBalance, faucet } from "./utils/api";\nimport { formatBalance } from "@polkadot/util";\n\n...OTHER_CODE...\n\nasync init() {\n\n  ...OTHER_CODE...\n\n  this.api = await initApi();\n  this.account = await initAccount();\n  getBalance(this.account, balance => {\n    this.balance = formatBalance(balance);\n  });\n\n  ...OTHER_CODE...\n\n}\n\n...OTHER_CODE...\n<\/script>\n```\n\nIt remains to add the function of replenishing the balance, when clicking on the button\n\n`src/App.vue`\n```js\n\n...OTHER_CODE...\n\n  methods: {\n    faucet() {\n      faucet(this.account);\n    },\n\n...OTHER_CODE...\n```\n\nhttps://github.com/airalab/example-robonomics-dapp/blob/step-3/src/App.vue\n\nRun app\n\n```sh\nyarn serve\n```\n\nWay 2:\n\nIf you start the application with cloning the repository, then to complete these steps, you will just need to switch to step 3.\n\n```sh\ngit checkout step-3\nyarn serve\n```\n\nAs a result we will get this picture in the browser\n\n![screen2](../images/build-iot-dapps/screen2.png)\n\n### Step 4. Datalog\n\nTo save and read any data in the chain, we use the `datalog` module.\n\nFor an example of how to use this module, let\'s make a `Datalog.vue` component.\n\nWay 1:\n\nIn the markup, we will have a button for reading data `read` with a block, where we will display a list in the form of a date and the data itself. And there will be a form with a text input, into which you can enter any data in the form of a string, and a `write` button.\n\n`src/components/Datalog.vue`\n```js\n<template>\n  <div>\n    <h2>Datalog</h2>\n    <button @click="read">read</button> |\n    <input v-model="data" :disabled="isWrite" />\n    <button @click="write" :disabled="isWrite">write</button>\n    <div v-if="error" class="error">{{ error }}</div>\n    <div v-if="log" class="log">\n      <p v-if="log.length === 0" class="error">Not found</p>\n      <div v-for="(item, k) in log" :key="k" class="row">\n        date: <b>{{ item[0] | dateFormat }}</b>\n        <br />\n        data: <b>{{ item[1] | dataFormat }}</b>\n      </div>\n    </div>\n  </div>\n</template>\n\n...OTHER_CODE...\n\n<style scoped>\n.log {\n  border: 1px solid #eee;\n  text-align: left;\n  width: 800px;\n  margin: 20px auto;\n}\n.log .row {\n  margin: 10px;\n}\n</style>\n```\n\nComponent code. Here the main point in sending a transaction is to call the function, into which we transfer data and which we sign with our account, via api `this.api.tx.datalog.record(stringToHex(this.data)).signAsync(this.account);`\n\n`src/components/Datalog.vue`\n```js\n<script>\nimport { stringToHex, u8aToString } from "@polkadot/util";\n\nexport default {\n  props: ["api", "account"],\n  data() {\n    return {\n      data: "data string",\n      log: null,\n      isWrite: false,\n      error: ""\n    };\n  },\n  filters: {\n    dateFormat: function(v) {\n      return new Date(Number(v)).toLocaleString();\n    },\n    dataFormat: function(v) {\n      return u8aToString(v);\n    }\n  },\n  methods: {\n    async read() {\n      this.log = (await this.api.query.datalog.datalog(this.account)).toArray();\n    },\n    async write() {\n      try {\n        this.error = "";\n        this.isWrite = true;\n        const tx = await this.api.tx.datalog\n          .record(stringToHex(this.data))\n          .signAsync(this.account);\n        await tx.send(result => {\n          if (result.status.isInBlock) {\n            this.read();\n            this.isWrite = false;\n          }\n        });\n      } catch (error) {\n        this.error = error.message;\n        this.isWrite = false;\n      }\n    }\n  }\n};\n<\/script>\n```\n\nhttps://github.com/airalab/example-robonomics-dapp/blob/master/src/components/Datalog.vue\n\nTo switch between components, added to `App.vue` the output of our component\n\n`src/App.vue`\n```js\n...OTHER_CODE...\n\n<template v-else-if="api && account">\n  <p>\n    Account: <b>{{ account }}</b> {{ balance }} |\n    <button @click="faucet">faucet</button>\n  </p>\n\n  <div>\n    <div class="tabs">\n      <button\n        @click="tab = \'datalog\'"\n        :class="{ active: tab === \'datalog\' }"\n      >\n        datalog\n      </button>\n    </div>\n    <Datalog v-if="tab === \'datalog\'" :api="api" :account="account" />\n  </div>\n</template>\n\n...OTHER_CODE...\n\n<script>\nimport Datalog from "./components/Datalog";\n\n...OTHER_CODE...\n\nexport default {\n  name: "App",\n  components: {\n    Datalog\n  },\n  data() {\n    return {\n      tab: "datalog"\n\n...OTHER_CODE...\n<\/script>\n\n<style>\n...OTHER_CODE...\n\n.tabs button {\n  font-size: 14px;\n  padding: 10px 20px;\n  font-weight: bold;\n  background: #ececec;\n  border: 1px solid #aaa;\n}\n.tabs button:hover {\n  background: #bfbfbf;\n}\n.tabs button:last-child {\n  border-left: none;\n}\n.tabs button.active {\n  background: #ced5e2;\n}\n</style>\n```\n\nRun app\n\n```sh\nyarn serve\n```\n\nWay 2:\n\nIf you start the application with cloning the repository, then to complete these steps, you will just need to switch to step 4.\n\n```sh\ngit checkout step-4\nyarn serve\n```\n\nAs a result we will get this picture in the browser\n\n![screen3](../images/build-iot-dapps/screen3.png)\n\n### Step 5. Launch\n\nThis function is used to start and stop the robot. To demonstrate how to use this module, let\'s write the `Launch.vue` component.\n\nWay 1:\n\nIn the component template, we will have a form where you can specify the address of the robot, the ON/OFF clicker and the button for sending.\n\n`src/components/Launch.vue`\n```js\n<template>\n  <div>\n    <h2>Launch</h2>\n    <input v-model="robot" :disabled="isWrite" placeholder="Robot address" />\n    <select v-model="parameter" :disabled="isWrite">\n      <option value="ON">ON</option>\n      <option value="OFF">OFF</option>\n    </select>\n    <button @click="launch" :disabled="isWrite">launch</button>\n    <div v-if="error" class="error">{{ error }}</div>\n    <div v-if="log.length > 0" class="log">\n      <div v-for="(item, k) in log" :key="k" class="row">\n        sender: <b>{{ item.sender }}</b>\n        <br />\n        robot: <b>{{ item.robot }}</b>\n        <br />\n        parameter: <b>{{ item.parameter ? "ON" : "OFF" }}</b>\n      </div>\n    </div>\n  </div>\n</template>\n\n...OTHER_CODE...\n\n<style scoped>\n.log {\n  border: 1px solid #eee;\n  text-align: left;\n  width: 800px;\n  margin: 20px auto;\n}\n.log .row {\n  margin: 10px;\n}\n</style>\n```\n\nThe code looks like the `Datalog.vue` component. The difference is just in reading. The robot will receive the command through events.\n\n`src/components/Launch.vue`\n```js\n<script>\nexport default {\n  props: ["api", "account"],\n  data() {\n    return {\n      robot: this.account,\n      parameter: "ON",\n      log: [],\n      isWrite: false,\n      error: "",\n      unsubscribe: null\n    };\n  },\n  async created() {\n    this.unsubscribe = await this.api.query.system.events(events => {\n      events.forEach(record => {\n        const { event } = record;\n        if (event.section === "launch" && event.method === "NewLaunch") {\n          const sender = event.data[0].toString();\n          const robot = event.data[1].toString();\n          const parameter = event.data[2].toHuman();\n          this.log.push({\n            sender,\n            robot,\n            parameter\n          });\n        }\n      });\n    });\n  },\n  destroyed() {\n    if (this.unsubscribe) {\n      this.unsubscribe();\n    }\n  },\n  methods: {\n    async launch() {\n      try {\n        this.error = "";\n        this.isWrite = true;\n        const tx = await this.api.tx.launch\n          .launch(this.robot, this.parameter === "ON")\n          .signAsync(this.account);\n        await tx.send(result => {\n          if (result.status.isInBlock) {\n            this.isWrite = false;\n          }\n        });\n      } catch (error) {\n        this.error = error.message;\n        this.isWrite = false;\n      }\n    }\n  }\n};\n<\/script>\n```\n\nhttps://github.com/airalab/example-robonomics-dapp/blob/master/src/components/Launch.vue\n\nFor display, add a new component to `App.vue`\n\n`src/App.vue`\n```js\n<template>\n...OTHER_CODE...\n\n  <div>\n    <div class="tabs">\n      <button\n        @click="tab = \'datalog\'"\n        :class="{ active: tab === \'datalog\' }"\n      >\n        datalog\n      </button>\n      <button\n        @click="tab = \'launch\'"\n        :class="{ active: tab === \'launch\' }"\n      >\n        launch\n      </button>\n    </div>\n    <Datalog v-if="tab === \'datalog\'" :api="api" :account="account" />\n    <Launch v-if="tab === \'launch\'" :api="api" :account="account" />\n  </div>\n\n...OTHER_CODE...\n</template>\n\n...OTHER_CODE...\n\n<script>\nimport Datalog from "./components/Datalog";\nimport Launch from "./components/Launch";\n\n...OTHER_CODE...\n\ncomponents: {\n  Datalog,\n  Launch\n},\n\n...OTHER_CODE...\n```\n\nRun app\n\n```sh\nyarn serve\n```\n\nWay 2:\n\nIf you start the application with cloning the repository, then to complete these steps, you will just need to switch to step 5.\n\n```sh\ngit checkout step-5\nyarn serve\n```\n\nAs a result we will get this picture in the browser\n\n![screen4](../images/build-iot-dapps/screen4.png)\n\n### Step 6. Demo\n\nIn this demo, we will have a car that can be started and stopped through the dApp. The car collects a log during the trip, and after stopping, saves it to the chain. Here we will use both modules, which we tried separately, in conjunction.\n\nTo emulate the behavior of a robot (car), we will write a Robot class. We will use the `Alice` key as an account for this robot. The `Robot` class will watch for `NewLaunch` events to turn itself on and off. After turning on, it starts collecting data into the log, in terms of data it will be just a timestamp. And after shutdown, it saves this log to the `datalog` module.\n\nWay 1:\n\nCreate file `src/utils/robot.js`. The full code of the file https://github.com/airalab/example-robonomics-dapp/blob/master/src/utils/robot.js\n\nFor visualization, we will create a `Demo.vue` component, where we will have a start button, car animation and log output.\n\n`src/components/Demo.vue`\n```js\n<template>\n  <div>\n    <h2>Demo</h2>\n    <template v-if="robot">\n      <h3>Robot: {{ robot.address }}</h3>\n      <p v-if="robot.state">Driver: {{ robot.driver }}</p>\n      <button @click="run" :disabled="isWrite">\n        <template v-if="!robot.state">run</template>\n        <template v-else>stop</template>\n      </button>\n      <div class="road">\n        <div\n          class="robot"\n          :class="[robot.state ? \'robot-play\' : \'robot-stop\']"\n        ></div>\n      </div>\n      <div v-if="error" class="error">{{ error }}</div>\n      <div v-if="log" class="log">\n        <p v-if="log.length === 0" class="error">Not found</p>\n        <div v-for="(item, k) in log" :key="k" class="row">\n          <b>{{ item[0] | dateFormat }}</b>\n          <pre>{{ item[1] | dataFormat }}</pre>\n        </div>\n      </div>\n    </template>\n  </div>\n</template>\n\n...OTHER_CODE...\n\n<style scoped>\n.log {\n  border: 1px solid #eee;\n  text-align: left;\n  width: 800px;\n  margin: 20px auto;\n  height: 500px;\n  overflow-y: auto;\n}\n.log .row {\n  margin: 10px;\n  border-bottom: 1px solid #eee;\n}\n.road {\n  width: 1000px;\n  margin: 20px auto;\n  background-color: #eee;\n  padding: 20px 0;\n  border: 5px solid #a5a5a5;\n  border-left: 0;\n  border-right: 0;\n  position: relative;\n}\n.road::before {\n  content: " ";\n  width: 1000px;\n  border-top: 5px dashed #a5a5a5;\n  position: absolute;\n  top: 50%;\n  left: 0;\n}\n@keyframes move {\n  from {\n    transform: translateX(0);\n  }\n  to {\n    transform: translateX(100%);\n  }\n}\n.robot {\n  height: 100px;\n  width: 100px;\n  color: #fff;\n  font-weight: bold;\n  font-style: 14px;\n  animation: move 30s linear infinite;\n  border-radius: 0 10px 10px 0;\n  background: url("../images/build-iot-dapps/car.png") no-repeat 0 0;\n  background-size: cover;\n}\n.robot-play {\n  animation-play-state: running;\n}\n.robot-stop {\n  animation-play-state: paused;\n}\n</style>\n```\n\nComponent code. Here we need to create an instance of the `Robot` class and a launch/stop function.\n\n`src/components/Demo.vue`\n```js\n...OTHER_CODE...\n\n<script>\nimport { u8aToString } from "@polkadot/util";\nimport Robot from "../utils/robot";\n\nexport default {\n  props: ["api", "account"],\n  data() {\n    return {\n      isWrite: false,\n      error: "",\n      robot: null,\n      log: []\n    };\n  },\n  filters: {\n    dateFormat: function(v) {\n      return new Date(Number(v)).toLocaleString();\n    },\n    dataFormat: function(v) {\n      return JSON.parse(u8aToString(v));\n    }\n  },\n  async created() {\n    this.robot = new Robot("//Alice", this.api);\n    await this.robot.subscribeLog(r => {\n      this.log = r.reverse().map(item => {\n        return [item[0], item[1]];\n      });\n    });\n  },\n  destroyed() {\n    this.robot.destroy();\n  },\n  methods: {\n    async run() {\n      try {\n        this.error = "";\n        this.isWrite = true;\n        const tx = await this.api.tx.launch\n          .launch(this.robot.account.address, !this.robot.state)\n          .signAsync(this.account);\n        await tx.send(result => {\n          if (result.status.isInBlock) {\n            this.isWrite = false;\n          }\n        });\n      } catch (error) {\n        this.error = error.message;\n        this.isWrite = false;\n      }\n    }\n  }\n};\n<\/script>\n\n...OTHER_CODE...\n```\n\nhttps://github.com/airalab/example-robonomics-dapp/blob/master/src/components/Demo.vue\n\nLet\'s add another picture of our car to `src/images/build-iot-dapps/car.png`. Example https://github.com/airalab/example-robonomics-dapp/blob/master/src/images/build-iot-dapps/car.png.\n\nFor display, add a new component to `App.vue`\n\n`src/App.vue`\n```js\n<template>\n\n...OTHER_CODE...\n\n  <div>\n    <div class="tabs">\n      <button\n        @click="tab = \'datalog\'"\n        :class="{ active: tab === \'datalog\' }"\n      >\n        datalog\n      </button>\n      <button\n        @click="tab = \'launch\'"\n        :class="{ active: tab === \'launch\' }"\n      >\n        launch\n      </button>\n      <button @click="tab = \'demo\'" :class="{ active: tab === \'demo\' }">\n        demo\n      </button>\n    </div>\n    <Datalog v-if="tab === \'datalog\'" :api="api" :account="account" />\n    <Launch v-if="tab === \'launch\'" :api="api" :account="account" />\n    <Demo v-if="tab === \'demo\'" :api="api" :account="account" />\n  </div>\n\n...OTHER_CODE...\n\n</template>\n\n...OTHER_CODE...\n\n<script>\nimport Datalog from "./components/Datalog";\nimport Launch from "./components/Launch";\nimport Demo from "./components/Demo";\n\n...OTHER_CODE...\n\ncomponents: {\n  Datalog,\n  Launch,\n  Demo\n},\n\n...OTHER_CODE...\n```\n\nRun app\n\n```sh\nyarn serve\n```\n\nWay 2:\n\nIf you start the application with cloning the repository, then to complete these steps, you will just need to switch to step 6.\n\n```sh\ngit checkout step-6\nyarn serve\n```\n\nAs a result we will get this picture in the browser\n\n![screen5](../images/build-iot-dapps/screen5.png)\n\nThis concludes our lesson.\n\nThanks!\n'}},{node:{id:"6543f54abeff24a7c604d04382ccd008",title:"How to participate in the Wiki translation",path:"/docs/ja/translate-wiki/",content:'\nEveryone can contribute to Robonomics. If you want to contribute to the translation of the documentation, you are on the right track: this article will tell you how to do it.\n\n## Editing an article\n\nIf support for your language has already been added to the site, follow these steps:\n\n1. Click the "Edit this page" button on the article you would like to translate. Each article is duplicated in a supported language, even if it has not yet been translated from English.\n2. Edit by sticking to the existing markup. You can read the article [How to edit WIKI](/docs/en/edit-wiki)\n3. Submit [PR](https://docs.github.com/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request) with the changes you have made.\n\n## Adding a new language\n\nIf the language you would like to translate the article into has not yet been added, request it from the Robonomics root team by, [creating Issue](https://docs.github.com/desktop/contributing-and-collaborating-using-github-desktop/creating-an-issue-or-pull-request) on GitHub.\n\nWhen we add support for the requested language to the site, we will close the Issue, commenting on it if necessary. You will be notified accordingly. This means you can translate pages (they will already be duplicated in English in a folder like `/docs/locale`)\n\n## Notes\n* If you see a way to improve an existing translation of an article, you can also use the PR or Issue on GitHub to request changes\n* If you make a significant contribution to the translation, you can participate in the rewards program\n'}},{node:{id:"7f292a15fb7420403a571bb7345f1419",title:"Sensors Connectivity",path:"/docs/ja/sensors-connectivity/",content:'\nThis Aira package allows you to read data from a SDS011 sensor and publish to different output channels. That said Aira is able to form a json formatted message with measurements and publish to a few channels. Also it includes Datalog feature which is still experimental. It could be used to publish data to Substrate based blockchain by Robonomics.\n\nThe last release is [Sensors Connectivity v0.2](https://github.com/airalab/sensors-connectivity/releases/tag/v0.2)\n\n## Sensor Connectivity Protocol :: v1\n\n### Sensor to Station\n\n**TCP Session diagram**\n\n| HEADER | DATA1 | DATA2 | DATA3 | ... | DATAN |\n|--------|-------|-------|-------|-----|-------|\n\nwhere `HEADER` is 34 bytes\n\n|      | Name      |\n|------|-----------|\n| 0x00 | public_id |\n| 0x20 | codec_id  |\n\n* `public_id` - Public identifier, generated on sensor setup.\n* `codec_id` - Type of used data codec.\n\n**Data frame**\n\n|      | Name      |\n|------|-----------|\n| 0x22 | payload   |\n| 0xNN | signature |\n\n\n* `payload` - Sensor measurements.\n* `signature` - Measurement Ed25519 signature, 64 bytes long. ([pynacl](https://github.com/pyca/pynacl))\n\nFor SDS011 sensor `payload` consists of 4 float numbers: PM2.5, PM10, GEO_LAT, GEO_LON\n\n### Station to Robonomics\n\nThe default output channel is Robonomics protocol over IPFS pubsub. For every measurement connectivity produces the following json formatted string:\n\n```\n{public_id: {"model": codec_id,"timestamp": unix_timestamp, "measurement": {"pm25": PM2.5, "pm10": PM10, "geo": "GEO_LAT,GEO_LON"}}}\n```\n\n## Stations and Feeders\n\nIn Sensors Connectivity there are two entities: station and feeder.\n\n### Station\n\nStation represents a source of data. The package can handle many inputs simultaneously:\n\n```\nstation1 \\                        / output1\nstation2 -  sensors-connectivity  - output2\nstation3 /                        \\ output3\n```\n\nThere are COM Station and TCP Station implemented. The first one reads data from a sensor that is connected to a serial port. TCP Station starts a tcp server and listens to incoming connections. \n\nTCP Station can accept data from every sensor or you can specify an access control list (ACL) for known sensors only.\n\n### Feeder\n\nFeeder is an output in terms of sensors connectivity:\n\n```\ninput1 \\                        / feeder1\ninput2 -  sensors-connectivity  - feeder2\ninput3 /                        \\ feeder3\n```\n\nAt current implementation the package can publish data to [Luftdaten](https://meine.luftdaten.info/), Robonomics or Robonomics on Substrate (using Datalog feature).\n\n## Connectivity Configuration\n\nThe package is highly configurable. The default configuration file looks like:\n\n```yaml\n# Please DO NOT edit this file\n# Make a copy instead, make changes and pass the absolute path to the copy in arguments\ngeneral:\n  publish_interval: 300 # time between two published messages\ncomstation:\n  port: "/dev/ttyUSB0"  # COM port of the device\n  work_period: 300      # time between two measurements in seconds\n  geo: ""               # Geo coordinates as latitude,longitude\n  public_key: ""        # If not provided, COMStation creates itself\ntcpstation:\n  address: ""           # IP and PORT to listen to, for example 0.0.0.0:31313\n  acl:                  # list of known addresses. If not specified accepts from everyone\n  # -\n  # -\nluftdaten:\n  enable: true          # whether or not publish to https://luftdaten.info/\nrobonomics:\n  enable: true          # enable use of Robonomics Network\n  ipfs_provider: ""     # ipfs endpoint\n  ipfs_topic: "airalab.lighthouse.5.robonomics.eth"\ndatalog:\n  enable: false         # enable use of Datalog Robonomics subcommand\n  path: ""              # path to Robonomics execution file\n  suri: ""              # private key of publisher account\n  remote: "wss://substrate.ipci.io"\n  dump_interval: 3600   # time between two transactions in seconds\n  temporal_username:    # set to pin files in Temporal.Cloud\n  temporal_password:\ndev:\n  sentry: ""\n```\n\nTo get familiar with all the options and launch scenarios check the [README.md](https://github.com/airalab/sensors-connectivity/tree/v0.2) out.\n\n'}},{node:{id:"eb5eba22af7f4cb3f0986b4649531572",title:"Install Sensors Connectivity on Your Own Aira",path:"/docs/ja/sensors-connectivity-on-aira/",content:'\n## Prerequirements\n\nYou must have an AIRA instance somewhere\n\n## Install the Package\n\n```\ngit clone https://github.com/airalab/sensors-connectivity\ncd sensors-connectivity\nnix build -f release.nix\n```\n\nFrom this point you can run the package with the default configuration file or create a systemd service to launch it automatically\n\n### Edit Configuration File\n\nAssuming you are in the package root directory edit the file:\n```\ncp config/default.json config/my.json\nvim config/my.json\n```\n\nExtended description of options is located [here](/docs/configuration-options-description)\n\n### Run Manually\n\nFrom the package directory:\n\n```\nsource result/setup.zsh\nroslaunch sensors_connectivity agent.launch config:=/root/sensors-connectivity/config/my.json\n```\n\n### Run via systemd\n\nAdd the following to `/etc/nixos/configuration.nix`:\n\n```\nsystemd.services.connectivity = {\n  requires = [ "roscore.service" ];\n  after = ["roscore.service" ];\n  wantedBy = [ "multi-user.target" ];\n  environment.ROS_MASTER_URI =  "http://localhost:11311";\n  script = \'\'\n    source /root/sensors-connectivity/result/setup.bash && roslaunch sensors_connectivity agent.launch config:=/root/sensors-connectivity/config/my.json\n  \'\';\n  serviceConfig = {\n    Restart = "on-failure";\n    StartLimitInterval = 0;\n    RestartSec = 60;\n    User = "root";\n  };\n};\n```\n\nThen\n\n```\nnixos-rebuild switch\n```\n\nRunning\n\n```\nsystemctl start connectivity.service\n```\n\n'}},{node:{id:"ed644dc535b9427eb7202b9a4a2dbff2",title:"Securely connect cloud AI to the factory floor",path:"/docs/ja/securely-connect-cloud-ai-to-the-factory-floor/",content:"\nRobonomics technologies can already solve the challenges that Industry 4.0 faces and they are already applied to real-world scenarios in the industrial environment.\n\nA large number of AI companies are building solutions to optimize the processes on the factory floor, allowing plants to produce more with less cost. However, most plants are hesitant to connect their infrastructure to the cloud directly since this results in potential cybersecurity risks, which could lead to million-dollar losses and even the loss of human life.\n\n[MerkleBot](https://merklebot.com) has used [Robonomics Network](https://robonomics.network) to build a solution for industrial clients to connect their factory to the cloud-based AI in a secure way.\n\nThis article is written in the wake of an experiment we conducted with [Veracity Protocol](https://www.veracityprotocol.org/) that uses algorithms to create non-invasive protection of any physical item based on the photographs from a mobile device.\n\nThis use case shows the process of scanning the industrial parts using a robotic arm.\n\n[Demo video](https://youtu.be/8AL70LFVX5w)\n\n## Step-by-step process\n\n### DApp as user interface\n\n![](../images/google-play-store.gif)\n\nDApp acts as a user interface for the operator. It is used to request the launch of the robot to collect the photographs and its purpose is to allow secure communication between the factory environment and cloud-based AI.\n\n### Launching the robot\n\n![](../images/Veracity_Protocol_Transaction.gif)\n\nThe operator launches the robotic scan by signing the transaction in the DApp. This step guarantees that the process on the factory floor can only start based on the transaction in the public blockchain.\n\nThe robot receives a command from the blockchain through the Robonomics Network and begins the scan. Robonomics Network technologies allow us to close the gap between the business objective and robotics operation.\n\n### Data collection and sending to cloud-based AI\n\nIn the DApp the operator sees the confirmation and the robot begins to scan the items placed on the table, such as in this use case, or on the factory line directly if the need arises.\n\n![](../images/Veracity_Protocol_Launch.gif)\n\nWhen the robot collects the data, it stores it locally and makes it available to cloud-based AI through IPFS protocol. By encrypting the data and organizing the data exchange through a blockchain transaction as well, we can authorize access to cloud-based AI while making sure that the data remains secure and in place.\n\nThe security mechanism built into Robonomics based on the shared security of public blockchains allows gaining the level of security that is prohibitively expensive for most factories to organize on their own.\n\n### Digital passport creation\n\nWhen the cloud-based AI analyses the data, the log file and recommendations are recorded as a [Digital Passport](https://wiki.robonomics.network/docs/create-digital-identity-run-by-ethereum/) automatically. Every operation and scan can be traced back since the blockchain record has the hash to all these files through IPFS protocol.\n\n## Comments about the use case\n\nIn this use case, Universal Robot UR3 industrial arm was used. But thanks to Robonomics support for ROS, most major industrial manipulators can be used and connected to cloud-based AI securely, including KUKA, Fanuc, and Yaskawa.\n\nIf you are interested to learn more about the deployment and integration of cloud-based AI instruments securely please [reach out](mailto:v@merklebot.com)\n"}},{node:{id:"e2eb77d4e210bce8d94fe7c0e8b6bad7",title:"Manual start of the Robonomics network, consisting of 3 nodes",path:"/docs/ja/robonomics-test-network-manual/",content:'\n**Need to start Robonomics network of N (N> = 2) nodes**\n\n## Requirements\n- Robonomics binary, download latest here: https://github.com/airalab/robonomics/releases/\n- Subkey tool, download latest here: https://github.com/airalab/robonomics/releases/\n- 3 servers with root shell. Their ip-addresses in the current instruction will be `165.227.171.127`, `159.89.25.75` and `159.89.30.50`\n\n## Introduction\nIn this tutorial, we will first create all key files locally, and then upload them to their corresponding nodes. \n\n## Prepare directories\nDownload 2 archives from the links above and open the folder with them in the terminal.\nThen create a directory for the project, unpack the archives into it and go to the created folder:\n```\n$ mkdir robonomics_test_network\n$ tar -xf ./robonomics-ubuntu-0.21.0-x86_64.tar.xz -C ./robonomics_test_network/\n$ tar -xf ./subkey-ubuntu-0.21.0-x86_64.tar.xz -C ./robonomics_test_network/\n$ cd ./robonomics_test_network/\n```\n\nNext, create a separate **uploads** directory and the necessary subdirectories for each server. All files intended for uploading to a specific server will be stored in these subdirectories:\n```\n$ mkdir -p uploads/165.227.171.127/keystore && mkdir -p uploads/165.227.171.127/network\n$ mkdir -p uploads/159.89.25.75/keystore && mkdir -p uploads/159.89.25.75/network\n$ mkdir -p uploads/159.89.30.50/keystore && mkdir -p uploads/159.89.30.50/network\n```\n\nAlso, create a **local** folder with **validators** and **sudo** folders, which will store the validators and sudo keys locally.\n```\n$ mkdir -p local/validators && mkdir -p local/sudo\n```\n\n## Prepare spec.json\nUsing the robonomics binary, generate a **spec.json** file, which will use as the basis:\n```\n$ ./robonomics build-spec --chain dev > uploads/spec.json\n```\n\nNext, edit this file. At first correct the first three fields, make them look like this:\n```\n"name": "Test Robonomics Network",\n"id": "dev",\n"chainType": "Live",\n```\n\n### bootNodes\nThe **bootNodes** field is a list of strings of special format. For each of the bootnodes must write the corresponding string here.\nTo do this, first create a key file for each bootnode using **subkey**:\n```\n$ ./subkey generate-node-key uploads/165.227.171.127/network/secret_ed25519  \n12D3KooWBPq1fDLQC2iqQ4FpM2mUpiXjBRcb8ptk7tbaqr2B6HZN\n$ ./subkey generate-node-key uploads/159.89.25.75/network/secret_ed25519\n12D3KooWRbGmdpbz6o1fe66wFs7nJsUYfBp2f3W7J1uDXj3gt4Bh\n$ ./subkey generate-node-key uploads/159.89.30.50/network/secret_ed25519\n12D3KooWMuTrL9CmJxj8LjH43s4hsJMsyuMdbuB86zCaAf9VCwFf\n```\n\nEach command creates a key file in the specified directory and outputs to stdout the string that will be needed to fill in the **bootNodes** field in the **spec.json** file. As a result, the **bootNodes** section should look like following example:\n```\n"bootNodes": [\n"/ip4/165.227.171.127/tcp/30333/p2p/12D3KooWBPq1fDLQC2iqQ4FpM2mUpiXjBRcb8ptk7tbaqr2B6HZN",\n"/ip4/159.89.25.75/tcp/30333/p2p/12D3KooWRbGmdpbz6o1fe66wFs7nJsUYfBp2f3W7J1uDXj3gt4Bh",\n"/ip4/159.89.30.50/tcp/30333/p2p/12D3KooWMuTrL9CmJxj8LjH43s4hsJMsyuMdbuB86zCaAf9VCwFf"\n],\n```\nThe next 3 fields (telemetryEndpoints, protocolId, properties) can be filled like this:\n```\n "telemetryEndpoints": [\n     [\n       "/dns4/telemetry.polkadot.io/tcp/443/x-parity-wss/%2Fsubmit%2F",\n       0\n     ]\n ],\n"protocolId": "txrt",\n"properties": {\n    "ss58Format": 32,\n    "tokenDecimals": 9,\n    "tokenSymbol": "TXRT"\n},\n```\nFurther up to the **palletBalances** field leave unchanged.\n\n\n### palletBalances\nTo fill the palletBalances field create **the number of nodes + 1** (the last key is for **sudo**) keys. This can be done using **subkey**, in the file name must specify **SS58 Address** from the generated key, in the file content must specify **seed** phrase in quotes. \n\nExample creating one key.\n - Generate key:\n    ```\n    $ ./subkey -n robonomics generate\n    Secret phrase `display cargo domain april joy still bundle notice bridge pencil fat approve` is account:\n      Network ID/version: substrate\n      Secret seed:        0x0275ab9bce53e4359184f02112943162c708f483009e0b7b3ba63549c5c2e514\n      Public key (hex):   0xd0996b85dd1b2876080b26123f9c27097d698f871c5978c3cb9c299253e7a530\n      Account ID:         0xd0996b85dd1b2876080b26123f9c27097d698f871c5978c3cb9c299253e7a530\n      SS58 Address:       4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx\n    ```\n - Create key file:\n    ```\n    $ touch ./local/validators/4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx && echo \'"display cargo domain april joy still bundle notice bridge pencil fat approve"\' | tee ./local/validators/4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx\n    ```\n  \nCommand template for creating a validator key file:  \n`touch ./local/validators/**SS58_Address** && echo \'"**seed**"\' | tee ./local/validators/**SS58_Address**`\n\nCommand template for creating a sudo key file:   \n`touch ./local/sudo/**SS58_Address** && echo \'"**seed**"\' | tee ./local/sudo/**SS58_Address**`\n\nThree keys are stored in the **local/validators** folder and one in the **local/sudo** folder. As a result, the following content should appear in the **local** directory:\n```\n./local/\n├── sudo\n│   └── 4Dy6bzrvoApwjLaAjfrtvtX3tthCw6fnCU1Ym5KNyRGt3kKb\n└── validators\n    ├── 4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx\n    ├── 4EeMi84pk5P5nQpyupQeCZ1C4NhUFtMF7Xh1MXJLANkZ3BTd\n    └── 4FPRYfSVqwaX39vXZ78tT3DPBT9FmFXvdQDD7y5UQKncJGu1\n```\n\nNow fill the palletBalances section in the spec.json file with these keys.\nAs a result, it should look like this:\n```\n"palletBalances": {\n  "balances": [\n    [\n      "4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx",    <-- Generated validator 1 key\n      1000000000000000000\n    ],\n    [\n      "4EeMi84pk5P5nQpyupQeCZ1C4NhUFtMF7Xh1MXJLANkZ3BTd",    <-- Generated validator 2 key\n      1000000000000000000\n    ],\n    [\n      "4FPRYfSVqwaX39vXZ78tT3DPBT9FmFXvdQDD7y5UQKncJGu1",    <-- Generated validator 3 key\n      1000000000000000000\n    ],\n    [\n      "4Dy6bzrvoApwjLaAjfrtvtX3tthCw6fnCU1Ym5KNyRGt3kKb",    <-- Generated sudo key\n      1000000000000000000\n    ],\n  ]\n},\n```\nThe values that were previously presented in the palletBalances section must be deleted.\n\n### palletSession\nNext step is the **palletSession** section in file **spec.json**. First let\'s describe its format. \nThis section contains the "keys" field, that contains a list of three lists (equals of nodes count). Each of these lists looks like follows:\n```\n[\n    "%validator_SS58_address%",\n    "%validator_SS58_address%",\n    {\n        "babe": "%sr25519_babe_SS58_address%",\n        "im_online": "%sr25519_im_online_SS58_address%"\n        "authority_discovery": "%sr25519_authority_discovery_SS58_address%",\n        "grandpa": "%ed25519_grandpa_SS58_address%",\n    }\n]\n```\n**%validator_SS58_address%** is the validator key that was generated for each node in the **palletBalances** section of this manual. Just copy it twice for each node.\n\nTo fill in the remaining 4 lines for each node, you need to create 4 key files for each node and store them in the **keystore** folders.\nAs key files are generated, you can fill **palletSession**.\n\nEach key file must contain a **seed** phrase in quotes.\nMaking of the name of each key file require separate consideration.\nThe name of each key file is formed as **prefix** + **account_id without leading hexadecimal zero**.\n\nPrefixes matching:  \n>      grandpa: \'6772616e\'  \n>      babe: \'62616265\'\n>      im_online: \'696d6f6e\'  \n>      authority_discovery: \'61756469\'  \n\nAn example of creating keys for one node:\n- Creating a **babe** (prefix *62616265*) key file.   \n  ```\n  $ ./subkey --sr25519 -n robonomics generate\n  ```\n  >  Secret phrase **cover once garment syrup income chair elder business diary frozen rack damage** is account:  \n  >\n  >  Network ID/version: `substrate`\n  >\n  >  Secret seed:        `0x90ddeee3a9a0c464572021d311c245eefc41f9a59c739faefda47efcf4755677`\n  >\n  >  Public key (hex):   `0xfa44d96e310cf68350dd855c745794f7c1afa63089ebdb2c96bff3797972bb43`\n  >\n  >  Account ID:         `0xfa44d96e310cf68350dd855c745794f7c1afa63089ebdb2c96bff3797972bb43`\n  > \n  >  SS58 Address:       `4HirHF5BVHxkRBtqptFxBSmnAiZir1qQLs6pL9Utmm4eF77C`\n  \n ```\n $ touch uploads/165.227.171.127/keystore/62616265fa44d96e310cf68350dd855c745794f7c1afa63089ebdb2c96bff3797972bb43 && echo \'"cover once garment syrup income chair elder business diary frozen rack damage"\' | tee ./uploads/165.227.171.127/keystore/62616265fa44d96e310cf68350dd855c745794f7c1afa63089ebdb2c96bff3797972bb43 \n ```\n This command creates a **babe** key file for the `165.227.171.127` node. To fill in **spec.json**, need to take from this output the value **SS58 Address**: `4HirHF5BVHxkRBtqptFxBSmnAiZir1qQLs6pL9Utmm4eF77C`. This address need to insert instead of `%sr25519_babe_SS58_address%` in the above **palletSession** template.\n   \n **babe** key file creation command template:  \n`touch ./uploads/[node_ip]/keystore/62616265+[Account_ID] && echo \'"[seed]"\' | tee ./uploads/[node_ip]/keystore/62616265+[Account_ID]`  \n\nAs you can see, the name of the babe key file is the sum of two substrings: `babe prefix (\'62616265\')`, and the `account_id` of the generated key, without the leading zero (`fa44d96e310cf68350dd855c745794f7c1afa63089ebdb2c96bff3797972bb43`). \n  Note that the keys `babe, im_online, authority_discovery` are generated with the indication `--sr25519`.  \n  **grandpa** key have to generate with the indication `--ed25519`.\n \n\n- Creating an **im_online** (prefix *696d6f6e*) key file.  \n  ```\n  $ ./subkey --sr25519 -n robonomics generate\n  ```\n  > Secret phrase **envelope truly balance turkey undo casual waste skill average ordinary gun split** is account:\n  >\n  >   Network ID/version: `substrate`\n  > \n  >   Secret seed:        `0x8a19df08feeff9f1fa3581902ca22a305252aea32e284d32f10e990d00bb8926`\n  > \n  >   Public key (hex):   `0x6c13ff8e37d91b80fe3b03f9b92a91a1ef7db741434cf12cc44d5ed29257ab09`\n  >  \n  >   Account ID:         `0x6c13ff8e37d91b80fe3b03f9b92a91a1ef7db741434cf12cc44d5ed29257ab09`\n  >  \n  >   SS58 Address:       `4EWQyBRoucH4Wjd4JtGoSEYYCw4bbkonjoFy9hNUX5fbmMEt`\n   \n  ```\n  $ touch uploads/165.227.171.127/keystore/696d6f6e6c13ff8e37d91b80fe3b03f9b92a91a1ef7db741434cf12cc44d5ed29257ab09 && echo \'"envelope truly balance turkey undo casual waste skill average ordinary gun split"\' | tee uploads/165.227.171.127/keystore/696d6f6e6c13ff8e37d91b80fe3b03f9b92a91a1ef7db741434cf12cc44d5ed29257ab09\n  ```\n  **im_online** key file creation command template:  \n  `touch ./uploads/[node_ip]/keystore/696d6f6e+[Account_ID] && echo \'"[seed]"\' | tee ./uploads/[node_ip]/keystore/696d6f6e+[Account_ID]`\n  \n  **spec.json**: `4EWQyBRoucH4Wjd4JtGoSEYYCw4bbkonjoFy9hNUX5fbmMEt` need to insert instead of `%sr25519_im_online_SS58_address%` in the above **palletSession** template.\n\n\n- Creating an **authority_discovery** (prefix *61756469*) key file.\n   ```\n   $ ./subkey --sr25519 -n robonomics generate\n   ```\n   > Secret phrase **boy harsh because omit equip atom apart spring undo explain walnut crystal** is account:\n   >\n   > Network ID/version: `substrate`\n   >\n   >   Secret seed:        `0x27838c9ea0524353da3717862ef0ecef123f40e81b73bb5ef377d12b47d1c543`\n   > \n   >   Public key (hex):   `0x4e33ccfd4105d30dfd93c5ef4658e2585a749508ea7c7abe754efc36dd634c07`\n   > \n   >   Account ID:         `0x4e33ccfd4105d30dfd93c5ef4658e2585a749508ea7c7abe754efc36dd634c07`\n   >  \n   >   SS58 Address:       `4DqEyoefRSz746sjaonxJ7KZQz8MUq4cKFA87DfoLzQgWk8t`\n   \n   ```\n   $ touch uploads/165.227.171.127/keystore/617564694e33ccfd4105d30dfd93c5ef4658e2585a749508ea7c7abe754efc36dd634c07 && echo \'"boy harsh because omit equip atom apart spring undo explain walnut crystal"\' | tee uploads/165.227.171.127/keystore/617564694e33ccfd4105d30dfd93c5ef4658e2585a749508ea7c7abe754efc36dd634c07\n   ```\n  **authority_discovery** key file creation command template:  \n  `touch ./uploads/[node_ip]/keystore/61756469+[Account_ID] && echo \'"[seed]"\' | tee ./uploads/[node_ip]/keystore/61756469+[Account_ID]` \n  \n   **spec.json**: `4DqEyoefRSz746sjaonxJ7KZQz8MUq4cKFA87DfoLzQgWk8t` need to insert instead of `%sr25519_authority_discovery_SS58_address%` in the above **palletSession** template.\n\n\n- Creating a **grandpa** (prefix *6772616e*) key file.\n   ```\n   $ ./subkey --ed25519 -n robonomics generate\n   ```\n   > Secret phrase **squeeze nature off vendor comic pause tattoo seek omit spatial regular cattle** is account:\n   > \n   >   Network ID/version: `substrate`\n   >\n   >   Secret seed:        `0xef0a9f51a4da7b789c0a25d39b44428d4da7262cc3fe013d4383b45216e8b83e`\n   >  \n   >   Public key (hex):   `0x7ea1beed13fb66a333b50b1ae417ebfd152bab99b223be2d4d886adb5fa7f009`\n   >  \n   >   Account ID:         `0x7ea1beed13fb66a333b50b1ae417ebfd152bab99b223be2d4d886adb5fa7f009`\n   > \n   >   SS58 Address:       `4EvjwRdgUg6YtdUDjq6Z3PoTKtzH5cgFgwnzArMSbw3RzYTa`\n    \n   ```\n   $ touch uploads/165.227.171.127/keystore/6772616e7ea1beed13fb66a333b50b1ae417ebfd152bab99b223be2d4d886adb5fa7f009 && echo \'"squeeze nature off vendor comic pause tattoo seek omit spatial regular cattle"\' | tee uploads/165.227.171.127/keystore/6772616e7ea1beed13fb66a333b50b1ae417ebfd152bab99b223be2d4d886adb5fa7f009\n   ```\n   **grandpa** key file creation command template:  \n  `touch ./uploads/[node_ip]/keystore/6772616e+[Account_ID] && echo \'"[seed]"\' | tee ./uploads/[node_ip]/keystore/6772616e+[Account_ID]`\n   \n   **spec.json**: `4EvjwRdgUg6YtdUDjq6Z3PoTKtzH5cgFgwnzArMSbw3RzYTa` need to insert instead of `%sr25519_grandpa_SS58_address%` in the above **palletSession** template.\n   \n   \n**Now 4 key files have been created for one node. Need to repeat this actions for the remaining two nodes.**\n\nYou should get the following **uploads** directory structure after creating all the keys:\n```\n./uploads/\n├── 165.227.171.127\n│   ├── keystore\n│   │   ├── 617564694e33ccfd4105d30dfd93c5ef4658e2585a749508ea7c7abe754efc36dd634c07\n│   │   ├── 62616265fa44d96e310cf68350dd855c745794f7c1afa63089ebdb2c96bff3797972bb43\n│   │   ├── 6772616e7ea1beed13fb66a333b50b1ae417ebfd152bab99b223be2d4d886adb5fa7f009\n│   │   └── 696d6f6e6c13ff8e37d91b80fe3b03f9b92a91a1ef7db741434cf12cc44d5ed29257ab09\n│   └── network\n│       └── secret_ed25519\n├── 159.89.25.75\n│   ├── keystore\n│   │   ├── 617564692ac9bd30c0168fa623cfd66abb4327992d900a652bcbb238b740bdde497a565f\n│   │   ├── 626162657cd666bb540c41cb33896a34d7413ffb86fcef1eddddfcd4edb325166df6335d\n│   │   ├── 6772616e084402349bc08ef90c2837e8e3f12ebe8bd4ab86809e9ee5f4f8ca26e73a0518\n│   │   └── 696d6f6e6ed2d507c0283ae869ba6514975bd8765eb8e06abd22afc09e8f36ef3950a116\n│   └── network\n│       └── secret_ed25519\n└── 159.89.30.50\n|   ├── keystore\n|   │   ├── 61756469f20a4e16a0ee79431d6f9a70c38892c7532ad1347c2226d43ef6ffe8966e9b30\n|   │   ├── 62616265e695aa459dbfd42bea7ed3b87970f164f34b6fee4d5a831ffbecd89eb9769b26\n|   │   ├── 6772616eadef59f896ea6b94bcd4519be8cc4b70263fc318cec1a3be14850bbc22117c34\n|   │   └── 696d6f6e2cb4dc8f8a67f477da15045ca40ef3861a2a6b2034ae0c64a179b4431341ea2c\n|   └── network\n|       └── secret_ed25519\n└── spec.json\n```\n\nThe palletSession section should look like this:\n```\n"palletSession": {\n    "keys": [\n        [\n            "4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx",    <-- Validator 1 SS58 Address\n            "4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx",    <-- Validator 1 SS58 Address\n            {\n                "authority_discovery": "4DqEyoefRSz746sjaonxJ7KZQz8MUq4cKFA87DfoLzQgWk8t",\n                "babe": "4HirHF5BVHxkRBtqptFxBSmnAiZir1qQLs6pL9Utmm4eF77C",\n                "grandpa": "4EvjwRdgUg6YtdUDjq6Z3PoTKtzH5cgFgwnzArMSbw3RzYTa",\n                "im_online": "4EWQyBRoucH4Wjd4JtGoSEYYCw4bbkonjoFy9hNUX5fbmMEt"\n            }\n        ],\n        [\n            "4EeMi84pk5P5nQpyupQeCZ1C4NhUFtMF7Xh1MXJLANkZ3BTd",    <-- Validator 2 SS58 Address\n            "4EeMi84pk5P5nQpyupQeCZ1C4NhUFtMF7Xh1MXJLANkZ3BTd",    <-- Validator 2 SS58 Address\n            {\n                "authority_discovery": "4F6daoG2gBXRLvbT4mVRajExZdZBHH7APmX3wDuLYJyzxHSS",\n                "babe": "4C7vBVHUYKqApCywqGsuap6XhjZ3gdYnW4YYP2mMyvYctLqT",\n                "grandpa": "4G3Ai6BGUjqtCoM2aTvWyR19gQ8WZiNnh1KFM47RyiYTwkE6",\n                "im_online": "4FHA7gzKfSLvd8jP85JUCWV6RyeRLm331KHcjnynGx7TWm7D"\n            }\n        ],\n        [\n            "4FPRYfSVqwaX39vXZ78tT3DPBT9FmFXvdQDD7y5UQKncJGu1",    <-- Validator 3 SS58 Address                        \n            "4FPRYfSVqwaX39vXZ78tT3DPBT9FmFXvdQDD7y5UQKncJGu1",    <-- Validator 3 SS58 Address\n            {\n                "authority_discovery": "4CqzJFkdSZg52PfV6Fd4gJ3vPLmRu1HGuPvNivjJ8dDWaz1a",\n                "babe": "4EComk8TsrT399xT6MPhGnhbZEif6U6cny8DiyZ3zezo9b5f",\n                "grandpa": "4Cqi4rG3CzWRZairhZX4isT8qG2jyz9fGDXJMrP6uBYkrft5",\n                "im_online": "4C7V6R59cZVbabExqgWvHVE1vj1E1cV42SZr8d8zZD3gmsqk"\n            }\n        ]\n    ]\n},\n```\n\n### palletStaking\n**palletStaking** must be filled in as follows:\n```\n"palletStaking": {\n    "historyDepth": 84,\n    "validatorCount": 10,\n    "minimumValidatorCount": 2,\n    "invulnerables": [\n        "4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx",     <-- Validator 1 SS58 Address\n        "4EeMi84pk5P5nQpyupQeCZ1C4NhUFtMF7Xh1MXJLANkZ3BTd",     <-- Validator 2 SS58 Address\n        "4FPRYfSVqwaX39vXZ78tT3DPBT9FmFXvdQDD7y5UQKncJGu1"      <-- Validator 3 SS58 Address\n    ],\n    "forceEra": "NotForcing",\n    "slashRewardFraction": 100000000,\n    "canceledPayout": 0,\n    "stakers": [\n        [\n            "4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx",  <-- Validator 1 SS58 Address\n            "4HirHF5BVHxkRBtqptFxBSmnAiZir1qQLs6pL9Utmm4eF77C",  <-- Validator 1 babe address\n            1000000,\n            "Validator"\n        ],\n        [\n            "4EeMi84pk5P5nQpyupQeCZ1C4NhUFtMF7Xh1MXJLANkZ3BTd",  <-- Validator 2 SS58 Address\n            "4C7vBVHUYKqApCywqGsuap6XhjZ3gdYnW4YYP2mMyvYctLqT",  <-- Validator 2 babe address\n            1000000,\n            "Validator"\n        ],\n        [\n            "4FPRYfSVqwaX39vXZ78tT3DPBT9FmFXvdQDD7y5UQKncJGu1",   <-- Validator 3 SS58 Address\n            "4EComk8TsrT399xT6MPhGnhbZEif6U6cny8DiyZ3zezo9b5f",   <-- Validator 3 babe address\n            1000000,\n            "Validator"\n        ]\n    ]\n},\n```\nThe example specified in which fields what values should be substituted.\n\n### palletSudo\nIn the rest of the **spec.json** file, you need to change only the contents of **palletSudo**, substituting the previously generated **sudo** address there:\n```\n            "palletBabe": {\n                "authorities": []\n            },\n            "palletGrandpa": {\n                "authorities": []  \n            },\n            "palletImOnline": {\n                "keys": []\n            },\n            "palletAuthorityDiscovery": {\n                "keys": []\n            },\n            "palletTreasury": {},\n            "palletElectionsPhragmen": {\n                "members": []\n            },\n            "palletCollectiveInstance1": {\n                "phantom": null,\n                "members": []\n            },\n            "palletSudo": {\n                "key": "4Dy6bzrvoApwjLaAjfrtvtX3tthCw6fnCU1Ym5KNyRGt3kKb"   <-- sudo address\n            }\n        }\n    }\n}\n```\n\n## systemd unit file\nNow create systemd unit file:\n```\n$ touch ./uploads/robonomics.service\n```\n\nAnd fill it like this:\n```\n[Unit]\nDescription=robonomics\nAfter=network.target\n\n[Service]\nUser=root\nGroup=root\nType=users\nWorkingDirectory=/root\nRestart=on-failure\nExecStart=/usr/bin/robonomics  --chain /etc/substrate/spec.json --name ${HOSTNAME} --validator\n\n[Install]\nWantedBy=multi-user.target\n```\nAs you can see from the "ExecStart" line, the **robonomics** binary is stored in the **/usr/bin/** directory, and the **spec.json** file is stored in the **/etc/substrate/** directory.\n\n## Uploading files\nThe following one-line command uploads all files to the required directories on the servers. It is important that there are no other folders in the **uploads** directory, except for the folders with the ip-addresses of the nodes:\n```\n$ \\\nfor IP in `ls -l ./uploads/ | grep \'^d\' | awk \'{print $9}\'`; do \\\n    ssh root@"$IP" "mkdir -p /root/.local/share/robonomics/chains/dev" && \\\n    scp -r ./uploads/$IP/* root@$IP:/root/.local/share/robonomics/chains/dev/ && \\\n    scp ./uploads/robonomics.service root@$IP:/etc/systemd/system/ && \\\n    scp ./robonomics root@$IP:/usr/bin/ && \\\n    ssh root@$IP "mkdir -p /etc/substrate" && \\\n    scp ./uploads/spec.json root@$IP:/etc/substrate/ \\\n; done\n```\n\n## Network launch\nNow connect to all nodes, enable and start the **robonomics.service** unit:\n```\n$  \\\nfor IP in `ls -l ./uploads/ | grep \'^d\' | awk \'{print $9}\'`; do \\\n   ssh root@$IP "systemctl enable robonomics.service && systemctl start robonomics.service" \\\n; done\n```\nAfter starting the service on all three nodes, you can view the node logs using **journalctl**. \nTo do this, you can connect to any existing server via ssh and run the following command:\n```\n$ journalctl -u robonomics.service -f\n```\n![Robonomics Chart](../images/robonomics-test-network-manual/result-journalctl.jpg "Robonomics Network journalctl stdout")\n'}},{node:{id:"c0a27d2c25eadaae092e6ca0bb821e80",title:"Robonomics + Prometheus + Grafana",path:"/docs/ja/robonomics-prometheus-grafana/",content:"\n**The following instruction is provided by [Hubo Bubo](https://github.com/hubobubo)**\n\n**The original article is located [here](https://github.com/hubobubo/robonomics/wiki/Robonomics-(XRT)-metrics-using-Prometheus-and-Grafana)**\n\n## Introduction\nTo better monitor and maintain Robonomics node(s) it's good to setup a monitoring based on Prometheus Server and Grafana. This doc will show how to configure each one of it to fully monitor your node.\n\n##  Prerequisites\n* [Server Setup with Ubuntu 18.04](https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-18-04) \n* [Robonomics parachain collator installed](https://blog.aira.life/installing-and-running-the-robonomics-validator-in-the-polkadot-network-487ad4c1a567)\n* Make sure you have robonomics.service working on your machine and port 9615 is reachable \n\n## Step 1 — Creating Service Users\n\nFor security purposes, we’ll begin by creating two new user accounts, prometheus and node_exporter. Create these two users, and use the _--no-create-home_ and _--shell /bin/false_ options so that these users can’t log into the server.\n```\nsudo useradd --no-create-home --shell /bin/false prometheus\nsudo useradd --no-create-home --shell /bin/false node_exporter\n```\n\nBefore we download the Prometheus binaries, create the necessary directories for storing Prometheus’ files and data. Following standard Linux conventions, we’ll create a directory in _/etc_ for Prometheus’ configuration files and a directory in _/var/lib_ for its data.\n```\nsudo mkdir /etc/prometheus\nsudo mkdir /var/lib/prometheus\n```\nNow, set the user and group ownership on the new directories to the prometheus user.\n```\nsudo chown prometheus:prometheus /etc/prometheus\nsudo chown prometheus:prometheus /var/lib/prometheus\n```\n## Step 2 — Downloading Prometheus\n\nFirst, download and unpack the current stable version of Prometheus into your home directory. You can find the latest binaries on the [Prometheus download page.](https://prometheus.io/download/)\n\n```\nwget https://github.com/prometheus/prometheus/releases/download/v2.21.0/prometheus-2.21.0.linux-amd64.tar.gz\n\n```\nNow, unpack the downloaded archive.\n\n```\ntar xvf prometheus-2.21.0.linux-amd64.tar.gz\n\n```\nThis will create a directory called prometheus-2.21.0.linux-amd64 containing two binary files (prometheus and promtool), _consoles_ and _console_libraries_ directories containing the web interface files, a license, a notice, and several example files.\n\nCopy the two binaries to the _/usr/local/bin_ directory.\n\n```\nsudo cp prometheus-2.21.0.linux-amd64/prometheus /usr/local/bin/\nsudo cp prometheus-2.21.0.linux-amd64/promtool /usr/local/bin/\n\n```\nSet the user and group ownership on the binaries to the prometheus user created in Step 1.\n\n```\nsudo chown prometheus:prometheus /usr/local/bin/prometheus\nsudo chown prometheus:prometheus /usr/local/bin/promtool\n\n```\nCopy the consoles and _console_libraries_ directories to _/etc/prometheus_.\n\n```\nsudo cp -r prometheus-2.21.0.linux-amd64/consoles /etc/prometheus\nsudo cp -r prometheus-2.21.0.linux-amd64/console_libraries /etc/prometheus\n\n```\nSet the user and group ownership on the directories to the prometheus user. Using the -R flag will ensure that ownership is set on the files inside the directory as well.\n\n```\nsudo chown -R prometheus:prometheus /etc/prometheus/consoles\nsudo chown -R prometheus:prometheus /etc/prometheus/console_libraries\n\n```\nNow that Prometheus is installed, we’ll create its configuration and service files in preparation of its first run.\n\n## Step 3 — Configuring Prometheus\n\nIn the _/etc/prometheus_ directory, use nano or your favorite text editor to create a configuration file named _prometheus.yml_.\n\n```\nsudo nano /etc/prometheus/prometheus.yml\n\n```\nIn the global settings, define the default interval for scraping metrics. Note that Prometheus will apply these settings to every exporter unless an individual exporter’s own settings override the globals.\n\n```\nglobal:\n  scrape_interval: 15s\n\n```\nThis scrape_interval value tells Prometheus to collect metrics from its exporters every 15 seconds, which is long enough for most exporters.\nNow, add Prometheus itself to the list of exporters to scrape from with the following scrape_configs directive:\n\n```\n...\nscrape_configs:\n  - job_name: 'prometheus'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9090']\n```\nPrometheus uses the _job_name_ to label exporters in queries and on graphs, so be sure to pick something descriptive here.\n\nAnd, as Prometheus exports important data about itself that you can use for monitoring performance and debugging, we’ve overridden the global scrape_interval directive from 15 seconds to 5 seconds for more frequent updates.\n\nLastly, Prometheus uses the _static_configs_ and _targets_ directives to determine where exporters are running. Since this particular exporter is running on the same server as Prometheus itself, we can use localhost instead of an IP address along with the default port, 9090.\n\nYour configuration file should now look like this:\n\n```\nglobal:\n  scrape_interval: 15s\n\nscrape_configs:\n  - job_name: 'prometheus'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9090']\n```\nSave the file and exit your text editor.\n\nNow, set the user and group ownership on the configuration file to the prometheus user created in Step 1.\n\n```\nsudo chown prometheus:prometheus /etc/prometheus/prometheus.yml\n\n```\nWith the configuration complete, we’re ready to test Prometheus by running it for the first time.\n\n## Step 4 — Running Prometheus\n\nStart up Prometheus as the _prometheus_ user, providing the path to both the configuration file and the data directory.\n\n```\nsudo -u prometheus /usr/local/bin/prometheus \\\n    --config.file /etc/prometheus/prometheus.yml \\\n    --storage.tsdb.path /var/lib/prometheus/ \\\n    --web.console.templates=/etc/prometheus/consoles \\\n    --web.console.libraries=/etc/prometheus/console_libraries\n```\n\nThe output contains information about Prometheus’ loading progress, configuration file, and related services. It also confirms that Prometheus is listening on port _9090_.\n\n```\n_log output_\nSep 14 17:55:53 robonomics systemd[1]: Started Prometheus.\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.347Z caller=main.go:310 msg=\"No time or size retention was set so using the default time retention\" duration=15d\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.350Z caller=main.go:346 msg=\"Starting Prometheus\" version=\"(version=2.21.0, branch=HEAD, revision=e83ef207b6c2398919b69cd87d2693cfc2fb4127)\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:347 build_context=\"(go=go1.15.2, user=root@a4d9bea8479e, date=20200911-11:35:02)\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:348 host_details=\"(Linux 4.15.0-112-generic #113-Ubuntu SMP Thu Jul 9 23:41:39 UTC 2020 x86_64 robonomics (none))\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:349 fd_limits=\"(soft=1024, hard=4096)\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:350 vm_limits=\"(soft=unlimited, hard=unlimited)\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.357Z caller=main.go:701 msg=\"Starting TSDB ...\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.368Z caller=web.go:523 component=web msg=\"Start listening for connections\" address=0.0.0.0:9090\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.372Z caller=head.go:644 component=tsdb msg=\"Replaying on-disk memory mappable chunks if any\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:658 component=tsdb msg=\"On-disk memory mappable chunks replay completed\" duration=12.659µs\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:664 component=tsdb msg=\"Replaying WAL, this may take a while\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.380Z caller=head.go:716 component=tsdb msg=\"WAL segment loaded\" segment=0 maxSegment=1\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:716 component=tsdb msg=\"WAL segment loaded\" segment=1 maxSegment=1\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:719 component=tsdb msg=\"WAL replay completed\" checkpoint_replay_duration=48.125µs wal_replay_duration=8.253748ms total_replay_duration=8.343335ms\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.383Z caller=main.go:721 fs_type=EXT4_SUPER_MAGIC\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:724 msg=\"TSDB started\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:850 msg=\"Loading configuration file\" filename=/etc/prometheus/prometheus.yml\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:881 msg=\"Completed loading of configuration file\" filename=/etc/prometheus/prometheus.yml totalDuration=908.135µs remote_storage=6.693µs web_handler=819ns query_engine=1.383µs scrape=400.232µs scrape_sd=41.679µs notify=1.1µs notify_sd=1.847µs rules=1.522µs\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:673 msg=\"Server is ready to receive web requests.\"\n```\nIf you get an error message, double-check that you’ve used YAML syntax in your configuration file and then follow the on-screen instructions to resolve the problem.\n\nNow, halt Prometheus by pressing _CTRL+C_, and then open a new _systemd_ service file.\n\n```\nsudo nano /etc/systemd/system/prometheus.service\n\n```\nThe service file tells _systemd_ to run Prometheus as the prometheus user, with the configuration file located in the _/etc/prometheus/prometheus.yml_ directory and to store its data in the _/var/lib/prometheus_ directory.Copy the following content into the file:\n\n```\n[Unit]\nDescription=Prometheus\nWants=network-online.target\nAfter=network-online.target\n\n[Service]\nUser=prometheus\nGroup=prometheus\nType=simple\nExecStart=/usr/local/bin/prometheus \\\n    --config.file /etc/prometheus/prometheus.yml \\\n    --storage.tsdb.path /var/lib/prometheus/ \\\n    --web.console.templates=/etc/prometheus/consoles \\\n    --web.console.libraries=/etc/prometheus/console_libraries\n\n[Install]\nWantedBy=multi-user.target\n```\n\nFinally, save the file and close your text editor. To use the newly created service, reload systemd.\n\n```\nsudo systemctl daemon-reload\n\n```\nYou can now start Prometheus using the following command:\n\n```\nsudo systemctl start prometheus\n\n```\nTo make sure Prometheus is running, check the service’s status.\n\n```\nsudo systemctl status prometheus\n\n```\nThe output tells you Prometheus’ status, main process identifier (PID), memory use, and more.\n\nIf the service’s status isn’t active, follow the on-screen instructions and re-trace the preceding steps to resolve the problem before continuing the tutorial.\n\n```\n* prometheus.service - Prometheus\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\n   Active: active (running) since Mon 2020-09-14 17:59:48 CEST; 24h ago\n Main PID: 29650 (prometheus)\n    Tasks: 9 (limit: 4915)\n   CGroup: /system.slice/prometheus.service\n           `-29650 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\n```\n\nWhen you’re ready to move on, press _Q_ to quit the status command. Lastly, enable the service to start on boot.\n\n```\nsudo systemctl enable prometheus\n\n```\n\nNow that Prometheus is up and running, we can install an additional exporter to generate metrics about our server’s resources.\n\n## Step 5 — Downloading Node Exporter\n\nTo expand Prometheus beyond metrics about itself only, we’ll install an additional exporter called Node Exporter. Node Exporter provides detailed information about the system, including CPU, disk, and memory usage. Download the current stable version of Node Exporter into your home directory. You can find the latest binaries on [Prometheus download page.](https://prometheus.io/download/)\n\n```\nwget https://github.com/prometheus/node_exporter/releases/download/v1.0.1/node_exporter-1.0.1.linux-amd64.tar.gz\n\n```\nNow, unpack the downloaded archive.\n\n```\ntar xvf node_exporter-1.0.1.linux-amd64.tar.gz\n\n```\nThis will create a directory called _node_exporter-1.0.1.linux-amd64_ containing a binary file named _node_exporter_, a license, and a notice.\n\nCopy the binary to the _/usr/local/bin_ directory and set the user and group ownership to the node_exporter user that you created in Step 1.\n\n```\nsudo cp node_exporter-1.0.1.linux-amd64/node_exporter /usr/local/bin\nsudo chown node_exporter:node_exporter /usr/local/bin/node_exporter\n\n```\nNow that you’ve installed Node Exporter, let’s test it out by running it before creating a service file for it so that it starts on boot.\n\n## Step 6 — Running Node Exporter\n\nThe steps for running Node Exporter are similar to those for running Prometheus itself. Start by creating the Systemd service file for Node Exporter.\n\n```\nsudo nano /etc/systemd/system/node_exporter.service\n\n```\nCopy the following content into the service file:\n\n```\n[Unit]\nDescription=Node Exporter\nWants=network-online.target\nAfter=network-online.target\n\n[Service]\nUser=node_exporter\nGroup=node_exporter\nType=simple\nExecStart=/usr/local/bin/node_exporter --collector.systemd\n\n[Install]\nWantedBy=multi-user.target\n```\n\nSave the file and close your text editor. Finally, reload systemd to use the newly created service.\n\n```\nsudo systemctl daemon-reload\n\n```\nYou can now run Node Exporter using the following command:\n\n```\nsudo systemctl start node_exporter\n\n```\nVerify that Node Exporter’s running correctly with the status command.\n\n```\nsudo systemctl status node_exporter\n\n```\nLike before, this output tells you Node Exporter’s status, main process identifier (PID), memory usage, and more. If the service’s status isn’t active, follow the on-screen messages and re-trace the preceding steps to resolve the problem before continuing.\n\n```\n_Output_\n* node_exporter.service - Node Exporter\n   Loaded: loaded (/etc/systemd/system/node_exporter.service; enabled; vendor preset: enabled)\n   Active: active (running) since Mon 2020-09-14 17:58:25 CEST; 1 day 1h ago\n Main PID: 29612 (node_exporter)\n    Tasks: 7 (limit: 4915)\n   CGroup: /system.slice/node_exporter.service\n           `-29612 /usr/local/bin/node_exporter --collector.systemd\n```\nLastly, enable Node Exporter to start on boot.\n\n```\nsudo systemctl enable node_exporter\n\n```\nWith Node Exporter fully configured and running as expected, we’ll tell Prometheus to start scraping the new metrics.\n\n## Step 7 — Configuring Prometheus to Scrape Node Exporter\n\nBecause Prometheus only scrapes exporters which are defined in the scrape_configs portion of its configuration file, we’ll need to add an entry for Node Exporter, just like we did for Prometheus itself. Open the configuration file.\n\n```\nsudo nano /etc/prometheus/prometheus.yml\n\n```\nAt the end of the scrape_configs block, add a new entry called node_exporter.\n\n```\n...\n  - job_name: 'node_exporter'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9100']\n```\nBecause this exporter is also running on the same server as Prometheus itself, we can use localhost instead of an IP address again along with Node Exporter’s default port, 9100. Your whole configuration file should look like this:\n\n```\nglobal:\n  scrape_interval: 15s\n\nscrape_configs:\n  - job_name: 'prometheus'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9090']\n  - job_name: 'node_exporter'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9100']\n```\nSave the file and exit your text editor when you’re ready to continue. Finally, restart Prometheus to put the changes into effect.\n\n```\nsudo systemctl restart prometheus\n\n```\nOnce again, verify that everything is running correctly with the status command.\n\n```\nsudo systemctl status prometheus\n\n```\nIf the service’s status isn’t set to active, follow the on screen instructions and re-trace your previous steps before moving on.\n\n```\nOutput\n* prometheus.service - Prometheus\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\n   Active: active (running) since Tue 2020-09-15 19:06:56 CEST; 2s ago\n Main PID: 19725 (prometheus)\n    Tasks: 8 (limit: 4915)\n   CGroup: /system.slice/prometheus.service\n           `-19725 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\n```\n\nWe now have Prometheus and Node Exporter installed, configured, and running.\n\n## Step 8 - Adding Robonomic build in node_exporter\n\nAfter successfully installed Prometheus and node_exporter we will have to use build in prometheus exporter in every substrate project. To make this happen we have to add additional entry to _/etc/prometheus/prometheus.yml_. \nOpen the configuration file.\n\n```\nsudo nano /etc/prometheus/prometheus.yml\n\n```\nAt the end of the scrape_configs block, add a new entry called robonomic_exporter.\n\n``` \n  - job_name: 'robonomics_exporter'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9615']\n```\nSave the file and exit your text editor. Your whole configuration file should look like this:\n\n```\nglobal:\n  scrape_interval: 15s\n\nscrape_configs:\n  - job_name: 'prometheus'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9090']\n  - job_name: 'node_exporter'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9100']\n  - job_name: 'robonomics_exporter'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9615']\n```\n\nFinally, restart Prometheus to put the changes into effect.\n\n```\nsudo systemctl restart prometheus\n\n```\nOnce again, verify that everything is running correctly with the status command.\n\n```\nsudo systemctl status prometheus\n\n```\nWe now have _Prometheus_ and _Node Exporter_ as well as _Robonomic Exporter_ installed, configured, and running. Now move on to Grafana\n\n## Step 9 - Setting up Grafana\n\nThe last step is to connect Prometheus as a Data Source in Grafana. For purpose of this tutorial we will use free cloud-based grafana which allow to have up to 5 dashboards as well as dedicated [Robonomics dashboard](https://grafana.com/grafana/dashboards/13015). Simply go to [grafana.com](https://grafana.com/) create new account and login to your newly created grafana instance.\n\nAt the beginning we must add to Grafana new _**Data Source**_ which in our case will be Prometheus server.\nGo to Data Source:\n\n>![DataSource](../images/prometheus-grafana/grafana-6-2020-09-15-19-18-50-Window.png)\n\nThen click **_Add data source_**\n\n>![DataSource](../images/prometheus-grafana/grafana-7-2020-09-15-19-18-50-Window.png)\n\nNext select _**Prometheus**_\n\n>![DataSource](../images/prometheus-grafana/grafana-8-2020-09-15-19-18-50-Window.png)\n\nIn new screen put your **_Prometheus server IP adress with 9090 port_**\n\n> ![DataSource](../images/prometheus-grafana/grafana-9-2020-09-15-19-18-50-Window.png)\n\nAfter that _**Save & Test**_ if you did all steps you should be green and ready to go for importing dashboard. On the main site click to **+** and then **Import** as shown on the pic below:\n\n> ![Import dashboard](../images/prometheus-grafana/grafana-1-2020-09-15-19-18-50-Window.png)\n\nThen you should see Import page:\n\n> ![Import page](../images/prometheus-grafana/grafana-2-2020-09-15-19-18-50-Window.png)\n\nIn the _Grafana.com dashboard url or id_ write _**13015**_ (as this is ID of the Robonomic dashboard)\n\n> ![Import Robonomic dashboard](../images/prometheus-grafana/grafana-3-2020-09-15-19-18-50-Window.png)\n\nAfter loading external dashboard you will get this screen:\n\n> ![XRT 13015 dashboard import](../images/prometheus-grafana/grafana-4-2020-09-15-19-18-50-Window.png)\n\nThe last step is to choose previously created **_Data Source_** and click _**Import**_\n\n> ![Prometheus as a DataSource](../images/prometheus-grafana/grafana-5-2020-09-15-19-18-50-Window.png)\n\nTHAT'S IT ! At this point you should see imported dashboard. \n\n\n## References\n\n* [How To Install Prometheus on Ubuntu 16.04](https://www.digitalocean.com/community/tutorials/how-to-install-prometheus-on-ubuntu-16-04)\n* [Build A Monitoring Dashboard by Prometheus + Grafana](https://medium.com/htc-research-engineering-blog/build-a-monitoring-dashboard-by-prometheus-grafana-741a7d949ec2)\n* [Grafana support for Prometheus](https://prometheus.io/docs/visualization/grafana/)\n* [Monitoring Linux host metrics with the node exporter](https://prometheus.io/docs/guides/node-exporter/)\n* [Querying Prometheus](https://prometheus.io/docs/prometheus/latest/querying/basics/)\n* [Visualizing Node Metrics](https://substrate.dev/docs/en/tutorials/visualize-node-metrics/)\n* [Substrate Prometheus Exporter](https://github.com/paritytech/substrate/tree/master/utils/prometheus)\n* [polkadot-dashboard](https://github.com/w3f/polkadot-dashboard)\n* [Polkadot node metric](https://grafana.com/grafana/dashboards/12425)\n* [Node Exporter for Prometheus Dashboard](https://grafana.com/grafana/dashboards/11074)\n* [Grafana ROBONOMICS (XRT) Metrics](https://grafana.com/grafana/dashboards/13015)\n\n"}},{node:{id:"610d93aaeaac4f15f0357394449e889e",title:"Robonomics Liability",path:"/docs/ja/robonomics-liability/",content:'\nThe package is responsible for receiving `New Liability` events (`listener` node) and playing topics from `objective` field (`executor` node).\nThe launch file also include `ipfs_channel` node and `signer` node.\n\n## ROS Parameters\n\n### ~web3_http_provider\n\nWeb3 HTTP provider address. The type is `string`, defaults to `http://127.0.0.1:8545`\n\n### ~web3_ws_provider\n\nWeb3 WebSocket provider address. The type is `string`, defaults to `ws://127.0.0.1:8546`\n\n### ~ipfs_http_provider\n\nIPFS HTTP provider address. The type is `string`, defaults to `http://127.0.0.1:5001`\n\n### ~ipfs_swarm_connect_addresses\n\nIPFS nodes to connect to. The type is `string`, defaults to `""`\n\n### ~ipfs_public_providers\n\nA public IPFS node to pin result files. The type is `string`, defaults to `""`\n\n### ~factory_contract\n\nThe name of the liability factory. The type is `string`, defaults to `factory.5.robonomics.eth`\n\n### ~lighthouse_contract\n\nThe name of a lighthouse you are working on. The type is `string`, defaults to `airalab.lighthouse.5.robonomics.eth`\n\n### ~enable_executor\n\nEnable or disable executor node. If it\'s `false`, no topics from objective would be published. The type is `boolean`, defaults to `true`\n\n### ~master_check_interval\n\nPeriod (in seconds) to check master for new topic publications. It\'s necessary for the Recorder, which records all the topics a CPS publishes. The type is `double`, defaults to `0.1`\n\n### ~recording_topics\n\nList of topics name separated by comma. It allows you to specify which topics would be recorded. The type is `string`, defaults to `""`\n\n### ~ens_contract\n\nThe checksumed address of ENS registry. The type is `string`, defaults to `""`\n\n### ~keyfile\n\nPath to keyfile. The type is `string`, defaults to `""`. **Required parameter**\n\n### ~keyfile_password_file\n\nPath to a file with password for the keyfile. The type is `string`, defaults to `""`. **Required parameter**\n\n## Subscribed topics\n\n### /liability/infochan/eth/signing/demand (robonomics_msgs/Demand)\n\n[robonomics_msgs/Demand](/docs/market-messages#demand) message to sign and send further to IPFS channel\n\n### /liability/infochan/eth/signing/offer (robonomics_msgs/Offer)\n\n[robonomics_msgs/Offer](/docs/market-messages#offer) message to sign and send further to IPFS channel\n\n### /liability/infochan/eth/signing/result (robonomics_msgs/Result)\n\n[robonomics_msgs/Result](/docs/market-messages#result) message to sign and send further to IPFS channel\n\n\n## Published topics\n\n### /liability/infochan/incoming/demand (robonomics_msgs/Demand)\n\nContains a [robonomics_msgs/Demand](/docs/market-messages#demand) message which was read from IPFS channel\n\n### /liability/infochan/incoming/offer (robonomics_msgs/Offer)\n\nContains a [robonomics_msgs/Offer](/docs/market-messages#offer) message which was read from IPFS channel\n\n### /liability/infochan/incoming/result (robonomics_msgs/Result)\n\nContains a [robonomics_msgs/Result](/docs/market-messages#result) message which was read from IPFS channel\n\n### /liability/incoming (robonomics_liability/Liability)\n\nContains all the information about the last created [robonomics_liability/Liability](/docs/robonomics-liability-messages#robonomics_liabilityliabilitymsg)\n\n### /liability/ready (robonomics_liability/Liability)\n\nSignals when a [robonomics_liability/Liability](/docs/robonomics-liability-messages#robonomics_liabilityliabilitymsg)is ready for execution\n\n### /liability/complete (robonomics_liability/Liability)\n\nSignals when a [robonomics_liability/Liability](/docs/robonomics-liability-messages#robonomics_liabilityliabilitymsg) has done its job\n\n### /liability/finalized (std_msgs/String)\n\nSignals when a liability has been finalized\n\n## Services\n\n### /liability/start (robonomics_liability/StartLiability)\n\nThe service tells executor to play topics from the objective. It\'s required to pass a liability address ([robonomics_liability/StartLiability](/docs/robonomics-liability-messages#robonomics_liabilitystartliabilitysrv)), which you can get from `/liability/ready` topic\n\n### /liability/finish (robonomics_liability/FinishLiability)\n\nCPS should call the service after performing the task. The input is [robonomics_liability/FinishLiability](/docs/robonomics-liability-messages#robonomics_liabilityfinishiabilitysrv)\n\n### /liability/restart (robonomics_liability/StartLiability)\n\nThe service allows to restart a liability after the system shutdown. The input is [robonomics_liability/StartLiability](/docs/robonomics-liability-messages#robonomics_liabilitystartliabilitysrv)\n\n### /liability/resume (robonomics_liability/StartLiability)\n\nThe service allows to resume a liability from the last timestamp available in the persistence store. The input is [robonomics_liability/StartLiability](/docs/robonomics-liability-messages#robonomics_liabilitystartliabilitysrv)\n\n### /liability/read (robonomics_liability/ReadLiability)\n\nThe service returns all the data about a liability by its address. The input is [robonomics_liability/ReadLiability](/docs/robonomics-liability-messages#robonomics_liabilityreadliabilitysrv)\n'}},{node:{id:"296d752b7425930e966f7470233fca85",title:"Robonomics Liability Messages",path:"/docs/ja/robonomics-liability-messages/",content:"\n## robonomics_liability/Liability.msg\n\n| Field        \t| Type                                                                         \t| Description                                    \t|\n|--------------\t|------------------------------------------------------------------------------\t|------------------------------------------------\t|\n| address      \t| [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) \t| The Liability’s address                        \t|\n| model        \t| [ipfs_commom/Multihash](/docs/ipfs-common-messages#ipfs_commonmultihashmsg)         \t| CPS behavioral model Identifier                \t|\n| objective    \t| [ipfs_commom/Multihash](/docs/ipfs-common-messages#ipfs_commonmultihashmsg)         \t| CPS behavioral model parameters in rosbag file \t|\n| result       \t| [ipfs_commom/Multihash](/docs/ipfs-common-messages#ipfs_commonmultihashmsg)         \t| Liability result hash                          \t|\n| promisee     \t| [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) \t| The promisee address                           \t|\n| promisor     \t| [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) \t| The promisor address (usually CPS)             \t|\n| lighthouse   \t| [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) \t| The address of lighthouse your CPS works on    \t|\n| token        \t| [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) \t| Operational token address                      \t|\n| cost         \t| [ethereum_commom/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg) \t| CPS behavioral model implementation cost       \t|\n| validator    \t| [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) \t| Observing network address                      \t|\n| validatorFee \t| [ethereum_commom/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg) \t| Observing network commission                   \t|\n\n## robonomics_liability/StartLiability.srv\n\n**Request**\n\n| Field     | Type              | Description                                           |\n|---------  |-----------------  |-----------------------------------------------------  |\n| address   | std_msgs/String   | The address of Liability you are willing to execute   |\n\n**Response**\n\n| Field     | Type              | Description                               |\n|---------  |-----------------  |------------------------------------------ |\n| success   | std_msgs/Bool     | Weather or not the Liability was started  |\n| msg       | std_msgs/String   | Status of launch                          |\n\n## robonomics_liability/FinishLiability.srv\n\n**Request**\n\n| Field     | Type              | Description                           |\n|---------  |-----------------  |------------------------------------   |\n| address   | std_msgs/String   | The address of Liability to finish    |\n| success   | std_msgs/Bool     | The status of execution               |\n\n**Response**\n\nThe response is empty\n\n## robonomics_liability/ReadLiability.srv\n\n**Request**\n\n| Field     | Type                                                                          | Description                   |\n|---------  |------------------------------------------------------------------------------ |----------------------------   |\n| address   | [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg)  | The address of a liability    |\n\n**Response**\n\n| Field         | Type                                                                  | Description           |\n|-----------    |---------------------------------------------------------------------  |---------------------  |\n| read          | std_msgs/Bool                                                         | Status of execution   |\n| liability     | [robonomics_liability/Liability](#robonomics_liabilityliabilitymsg)   | Liability             |\n"}},{node:{id:"35929027353b3f1db519b7558822d36e",title:"Robonomics-js",path:"/docs/ja/robonomics-js/",content:"\n[Robonomics-js](https://github.com/airalab/robonomics-js) is a simple Javascript library for working with Robonomics Network.\n\n## Installation\n\n```\nnpm install robonomics-js --save\n```\n\nor\n\n```\nyarn add robonomics-js\n```\n\n### Dependencies \n\n* [Web3](https://github.com/ethereum/web3.js/) version 1.2.4\n* [Ipfs](https://github.com/ipfs/js-ipfs) version 0.34.0\n\n\n## Usage \n\nCreates a Robonomics instance\n\n```JavaScript\nconst options = {...};\nconst robonomics = new Robonomics(options);\n```\n\n### options\n\nThe object of properties:\n\n```\noptions.web3\n```\n\nAn instance of [web3.js](https://github.com/ethereum/web3.js/):\n\n```JavaScript\n// metamask\nconst options = {\n  web3: new Web3(window.ethereum),\n  ...\n};\n\n// infura\nconst options = {\n  web3: new Web3(\n    new Web3.providers.WebsocketProvider(\n      \"wss://mainnet.infura.io/ws/v3/0b2f2a5026264b57b6d698b480332e89\"\n    )\n  ),\n  ...\n};\n```\n\n```\noptions.messageProvider\n```\n\nThis is an instance of MessageProviderIpfs which uses a [js-ipfs](https://github.com/ipfs/js-ipfs) node with pubsub support\n\n```JavaScript\nconst ipfs = new Ipfs({\n  repo: 'robonomics-example',\n  relay: {\n    enabled: true,\n    hop: {\n      enabled: true\n    }\n  },\n  EXPERIMENTAL: {\n    pubsub: true\n  },\n  config: {\n    Addresses: {\n      Swarm: [\n        '/dns4/ws-star.discovery.libp2p.io/tcp/443/wss/p2p-websocket-star',\n        '/dns4/1.wsstar.aira.life/tcp/443/wss/p2p-websocket-star/',\n        '/dns4/2.wsstar.aira.life/tcp/443/wss/p2p-websocket-star/',\n        '/dns4/3.wsstar.aira.life/tcp/443/wss/p2p-websocket-star/'\n      ]\n    },\n    Bootstrap: [\n      '/dns4/ams-1.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLer265NRgSp2LA3dPaeykiS1J6DifTC88f5uVQKNAd',\n      '/dns4/lon-1.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLMeWqB7YGVLJN3pNLQpmmEk35v6wYtsMGLzSr5QBU3',\n      '/dns4/nyc-1.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLueR4xBeUbY9WZ9xGUUxunbKWcrNFTDAadQJmocnWm',\n      '/dns4/nyc-2.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLV4Bbm51jM9C4gDYZQ9Cy3U6aXMJDAbzgu2fzaDs64',\n      '/dns4/node0.preload.ipfs.io/tcp/443/wss/ipfs/QmZMxNdpMkewiVZLMRxaNxUeZpDUb34pWjZ1kZvsd16Zic',\n      '/dns4/node1.preload.ipfs.io/tcp/443/wss/ipfs/Qmbut9Ywz9YEDrz8ySBSgWyJk41Uvm2QJPhwDJzJyGFsD6',\n      '/dns4/1.pubsub.aira.life/tcp/443/wss/ipfs/QmdfQmbmXt6sqjZyowxPUsmvBsgSGQjm4VXrV7WGy62dv8',\n      '/dns4/2.pubsub.aira.life/tcp/443/wss/ipfs/QmPTFt7GJ2MfDuVYwJJTULr6EnsQtGVp8ahYn9NSyoxmd9',\n      '/dns4/3.pubsub.aira.life/tcp/443/wss/ipfs/QmWZSKTEQQ985mnNzMqhGCrwQ1aTA6sxVsorsycQz9cQrw'\n    ]\n  }\n})\n\nconst options = {\n  messageProvider: new MessageProviderIpfs(ipfs),\n  ...\n};\n```\n\n```\noptions.account\n```\n\nThis is an account object which will be used to sign messages. It's necessary to specify either account address (that one must be unlocked) or a private key (the address will be recovered from the given private key).\n\nOption `isSignPrefix` tells whether or not a prefix must be appended. Default is `true`.\n\n```JavaScript\nconst options = {\n  account: {\n    address: '0x0000000000000000000000000000000000000000',\n    privateKey: '0x0000000000000000000000000000000000000000000000000000',\n    isSignPrefix: true\n  },\n  ...\n};\n```\n\n```\noptions.ens\n```\n\nThis is a `ens` contract object. This one is not required. If it's necessary you may specify `address` of the contract if the network is not set to mainnet. `suffix` may be `sid` for sidechain or `eth` for mainnet. `eth` is default. `version` is the version of Robonomics Network. Default is the latest deployed version.\n\n```JavaScript\nconst options = {\n  ens: {\n    address: '0x314159265dD8dbb310642f98f50C066173C1259b',\n    suffix: 'eth',\n    version: 5\n  },\n  ...\n};\n```\n\n```\noptions.lighthouse\n```\n\nENS name of a lighthouse, not required. Default is `airalab.lighthouse.5.robonomics.eth`. It's possible to specify only the first part of the name, like `airalab`.\n\n```JavaScript\nconst options = {\n  lighthouse: 'airalab.lighthouse.5.robonomics.eth',\n  ...\n};\n```\n\nIt's necessary to wait until full initialization\n\n```JavaScript\nconst options = {...};\nconst robonomics = new Robonomics(options);\nrobonomics.ready().then(() => {\n  console.log('Robonomics instance ready')\n})\n```\n\n## API\n\n### Messages\n\n#### Demand \n\nThe message specification\n\n```JavaScript\nconst demand = {\n  // REQUIRED\n  model: \"QmSt69qQqGka1qwRRHbdmAWk4nCbsV1mqJwd8cWbEyhf1M\",      // ipfs hash of the model \n  objective: \"QmSt69qQqGka1qwRRHbdmAWk4nCbsV1mqJwd8cWbEyhf2M\",  // ipfs hash of the objective\n  token: robonomics.xrt.address,                                // payment token address\n  cost: 1,                                                      // cost\n  deadline: 9999999,                                            // until which block demand is valid\n\n  // NOT REQUIRED \n  lighthouse: \"0x0000000000000000000000000000000000000000\",     // lighthouse address, by default the initialization address\n  validator: \"0x0000000000000000000000000000000000000000\",      // validator address if necessary\n  validatorFee: 0,                                              // validator fee \n  nonce: 1                                                      // index number \n};\n```\n\n`robonomics.sendDemand`\n\nSigning and broadcasting the demand message. A liability is returned as promise\n\n```JavaScript\nrobonomics.sendDemand(demand).then(liability => {\n  console.log(liability.address);\n});\n```\n\n`robonomics.onDemand`\n\nListens to demand messages with a defined model. If model is `null` returns any demand message.\n\n```JavaScript\nrobonomics.onDemand(model, message => {\n  console.log(message);\n});\n```\n\n#### Offer \n\nThe message specification\n\n```JavaScript\nconst offer = {\n  // REQUIRED \n  model: \"QmSt69qQqGka1qwRRHbdmAWk4nCbsV1mqJwd8cWbEyhf1M\",      // ipfs hash of the model \n  objective: \"QmSt69qQqGka1qwRRHbdmAWk4nCbsV1mqJwd8cWbEyhf2M\",  // ipfs hash of the objective\n  token: robonomics.xrt.address,                                // payment token address\n  cost: 1,                                                      // cost \n  deadline: 9999999,                                            // until which block demand is valid\n\n  // NOT REQUIRED\n  lighthouse: \"0x0000000000000000000000000000000000000000\",     // lighthouse address, by default the initialization address\n  lighthouseFee: 0,                                             // lighthouse fee\n  validator: \"0x0000000000000000000000000000000000000000\",      // validator address if necessary\n  nonce: 1                                                      // index number \n};\n```\n\n`robonomics.sendOffer`\n\nSigns and broadcasts an offer message. A liability is returned as promise\n\n```JavaScript\nrobonomics.sendOffer(offer).then(liability => {\n  console.log(liability.address);\n});\n```\n\n`robonomics.onOffer`\n\nListens to offer messages with a defined model. If model is `null` returns any offer message\n\n```JavaScript\nrobonomics.onOffer(model, message => {\n  console.log(message);\n});\n```\n\n#### Result \n\nThe message specification\n\n```JavaScript\nconst result = {\n  // REQUIRED \n  liability: \"0x0000000000000000000000000000000000000000\",  // liability contract address\n  success: true,                                            // status of the task\n  result: \"QmWXk8D1Fh5XFJvBodcWbwgyw9htjc6FJg8qi1YYEoPnrg\"  // ipfs hash of the rosbag log file\n};\n```\n\n`robonomics.sendResult`\n\nSigns and broadcasts a result message\n\n```JavaScript\nrobonomics.sendResult(result).then(() => {\n  console.log(\"ok\");\n});\n```\n\n`robonomics.onResult`\n\nListens to result messages. These results may be not valid. Valid results are stored in a liability contract\n\n```JavaScript\nrobonomics.onResult(result => {\n  console.log(result);\n});\n```\n\n### Smart Contracts \n\n#### Liability \n\n`liability.getInfo`\n\nReturn a property object of the contract\n\n```JavaScript\nliability.getInfo().then(data => {\n  console.log(data);\n  /*\n  {\n    model,\n    objective,\n    result,\n    token,\n    cost,\n    lighthouseFee,\n    validatorFee,\n    demandHash,\n    offerHash,\n    promisor,\n    promisee,\n    lighthouse,\n    validator,\n    isSuccess,\n    isFinalized\n  }\n  */\n});\n```\n\n`liability.onResult`\n\nWaits until a liability is finished. Returns a result\n\n```JavaScript\nliability.onResult().then(result => {\n  console.log(result);\n});\n```\n\n#### Lighthouse \n\n`robonomics.lighthouse.getInfo`\n\nReturns a property object of the contract\n\n```JavaScript\nrobonomics.lighthouse.getInfo().then(data => {\n  console.log(data);\n  /*\n  {\n    minimalStake,\n    timeoutInBlocks,\n    keepAliveBlock,\n    marker,\n    quota\n  }\n  */\n});\n```\n\n`robonomics.lighthouse.getProviders`\n\nReturns a list of providers on the lighthouse\n\n```JavaScript\nrobonomics.lighthouse.getProviders().then(list => {\n  console.log(list);\n});\n```\n\n##### Creation of a new lighthouse\n\n```JavaScript\nconst minimalFreeze = 1000      // Wn\nconst timeout = 25              // blocks\nconst name = 'mylighthouse'     // lighthouse name\nrobonomics.factory.methods.createLighthouse(minimalFreeze, timeout, name).send({ from: robonomics.account.address })\n    .then((tx) => console.log(tx))\n\nrobonomics.factory.onLighthouse((lighthouse) => {\n    console.log(lighthouse.name)\n})\n```\n\n##### Become a provider \n\nPreliminarily you must call `approve` for the tokens `XRT`\n\n```JavaScript\nconst name = \"mylighthouse\";    // lighthouse name\nconst stake = 1000;             // Wn\nrobonomics.lighthouse.methods\n  .refill(stake)\n  .send({ from: robonomics.account.address })\n  .then(tx => console.log(tx));\n```\n\n#### Token \n\n`robonomics.xrt.getInfo`\n\nReturns property object of the token\n\n```JavaScript\nrobonomics.xrt.getInfo().then(data => {\n  console.log(data);\n  /*\n  {\n    name,\n    totalSupply,\n    decimals,\n    symbol\n  }\n  */\n});\n```\n\n##### Check balance \n\n```JavaScript\nrobonomics.xrt.methods\n  .balanceOf(robonomics.account.address)\n  .call()\n  .then(balance => console.log(balance));\n```\n\n##### Check allowance \n\n```JavaScript\nrobonomics.xrt.methods\n  .allowance(robonomics.account.address, robonomics.factory.address)\n  .call()\n  .then(allowance => console.log(allowance));\n```\n\n##### Approve \n\n```JavaScript\nrobonomics.xrt.methods\n  .approve(robonomics.lighthouse.address, 100)\n  .send({\n    from: robonomics.account.address\n  })\n  .then(tx => console.log(tx));\n```\n\n## Links \n\n- [Website](https://robonomics.network/)\n- [Minimal template of dApp](https://github.com/airalab/vue-dapp-robonomics-template)\n- [dApp example](https://codesandbox.io/s/robonomics-vue-template-ewuiw)\n"}},{node:{id:"e7acbac6ee9e5031c53eb4e90b2db5a1",title:"How Robonomics Network Works",path:"/docs/ja/robonomics-how-it-works/",content:'\nIn this section we will discuss the Robonomics Network scenario.\n\nThere are few main parts in the Robonomics network:\n\n- IPFS for the messages exchanging\n- the Ethereum blockchain for storing new liability contracts\n- a provider that is responsible for matching messages\n- an agent\n\nLet\'s have a look at the following diagram that describes the scenario without any additional details:\n\n![The main scenario of Robonomics Network](../images/robonomics_network_scenario.jpg "The main scenario of Robonomics Network")\n\nThere are three types of [messages](/docs/market-messages) in IPFS: Demand, Offer, Result.\n\n**Below there is the specification for a Demand message:**\n\n| Field         | Type                      | Description                                       | Example                                           |\n|-------------- |-------------------------  |------------------------------------------------   |------------------------------------------------   |\n| model         | [ipfs_common/Multihash](/docs/robonomics-liability-messages#ipfs_commonmultihashmsg)     | CPS behavioral model Identifier                   | QmfXHZ2YkNC5vRjp1oAaRoDHD8H3zZznfhBPasTu348eWC    |\n| objective     | [ipfs_common/Multihash](/docs/robonomics-liability-messages#ipfs_commonmultihashmsg)     | CPS behavioral model parameters in rosbag file    | QmUo3vvSXZPQaQWjb3cH3qQo1hc8vAUqNnqbdVABbSLb6r    |\n| token         | ethereum_common/Address   | Operational token address                         | 0xbD949595eE52346c225a19724084cE517B2cB735        |\n| cost          | ethereum_common/UInt256   | CPS behavioral model implementation cost          | 1                                                 |\n| lighthouse    | ethereum_common/Address   | Lighthouse address                                | 0xa1b60ED40E5A68184b3ce4f7bEf31521A57eD2dB1       |\n| validator     | ethereum_common/Address   | Observing network address                         | 0x0000000000000000000000000000000000000000        |\n| validatorFee  | ethereum_common/UInt256   | Observing network commission                      | 0                                                 |\n| deadline      | ethereum_common/UInt256   | Deadline block number                             | 6393332                                           |\n| sender        | ethereum_common/Address   | Message sender address                            | 0x0000000000000000000000000000000000000000        |\n| signature     | std_msgs/UInt8[]          | Sender’s digital signature                        | 0x23bc…c617                                       |\n\n\x3c!--\n=============== ============================================================== ================================================ ================================================\n     Field                                   Type                                                Description                                        Example\n=============== ============================================================== ================================================ ================================================\n  model          :ref:`ipfs_common/Multihash <IPFS-Common-Multihash.msg>`       CPS behavioral model Identifier                  QmfXHZ2YkNC5vRjp1oAaRoDHD8H3zZznfhBPasTu348eWC\n  objective      :ref:`ipfs_common/Multihash <IPFS-Common-Multihash.msg>`       CPS behavioral model parameters in rosbag file   QmUo3vvSXZPQaQWjb3cH3qQo1hc8vAUqNnqbdVABbSLb6r\n  token          :ref:`ethereum_common/Address <Ethereum-common-Address.msg>`   Operational token address                        0xbD949595eE52346c225a19724084cE517B2cB735\n  cost           :ref:`ethereum_common/UInt256 <Ethereum-common-UInt256.msg>`   CPS behavioral model implementation cost         1\n  lighthouse     :ref:`ethereum_common/Address <Ethereum-common-Address.msg>`   Lighthouse address                               0xa1b60ED40E5A68184b3ce4f7bEf31521A57eD2dB1\n  validator      :ref:`ethereum_common/Address <Ethereum-common-Address.msg>`   Observing network address                        0x0000000000000000000000000000000000000000\n  validatorFee   :ref:`ethereum_common/UInt256 <Ethereum-common-UInt256.msg>`   Observing network commission                     0\n  deadline       :ref:`ethereum_common/UInt256 <Ethereum-common-UInt256.msg>`   Deadline block number                            6393332\n  sender         :ref:`ethereum_common/Address <Ethereum-common-Address.msg>`   Message sender address                           0x0000000000000000000000000000000000000000\n  signature      std_msgs/UInt8[]                                               Sender\'s digital signature                       0x23bc...c617\n=============== ============================================================== ================================================ ================================================\n--\x3e\n\nAn Offer message has the same fields but instead of `validatorFee` there is a `lighthouseFee` field. This field determines the amount of fee for a lighthouse.\n\nNow let\'s have a look at the following diagram and walk step by step from the moment of publishing messages to a liability finalization.\n\n![Robonomics Network detailed scenario](../images/robonomics_network_detailed_scenario.jpg "Robonomics Network detailed scenario")\n\nA liability contract is created only if the following fields match: `model`, `objective`, `token`, `cost`. A provider of Robonomics Network watches every message and finds those ones that have a match.\nAfter the match is found the provider calls `createLiability(demand, offer)` method from the contract factory where `demand` and `offer` are serialized.\n\nBelow is the package diagram for the Robonomics communication stack:\n\n![Robonomics communication stack](../images/robonomics_network_communication_stack.jpg "Robonomics communication stack")\n\nThe factory deserializes arguments and recovers *promisee* and *promisor* addresses from signatures.\n\nNext step is token transfer. The factory transfers **cost** tokens from the *promisee* address and **validatorFee** and **lighthouseFee** from the *promisor* address to the new liability address.\n\n> - **You should approve sufficient amount of tokens for the factory.**\n> - **It\'s not required to approve tokens from the *promisor* address if fees are null.**\n\nNow the factory emits a NewLiability event with the liability address. An agent gets the address, reads fields, perform a task and at the same time writes a log file in rosbag format.\n\nWhen the work is done the agent sends a Result message with the following fields: hash of the rosbag file, a success flag, a signature. If the **validator** field is not null it means that only validator is able to finalize the liability.\n\nAfter the successful liability finalization the agent gets **cost** tokens. Otherwise, the *promisee* gets tokens back.'}},{node:{id:"2c054004663fb1883fe3404a76683811",title:"Robonomics DApp Overview",path:"/docs/ja/robonomics-dapp-overview/",content:"\nYou can operate with Robonomics Network using the interface of [Robonomics Network Dapp (decentralized application)](https://dapp.robonomics.network/#/). It is available in browsers with [Metamask extension](https://metamask.io). On the first page you will see the statistics of the network:\n\n![Robonomics DApp's first page](../images/robonomics_dapp_first_page.jpg \"Robonomics DApp's first page\")\n\nLet's have a look at the bottom table \"Robonomics Telemetry\".\n\nEvery time an instance of AIRA is launched it broadcasts a piece of information about itself. Usually it takes some time for the Dapp to receive data from an instance of AIRA.\n\nHave a brief look at the page [\"AIRA installation\"](/docs/aira-installation) to understand where `IPNS` and `Address Eth` came from.\n\n## IPNS\n\nYou can treat it as a unique identifier of your instance in IPFS network. Under that name AIRA publishes metadata about itself.\n\n## Address Eth\n\nBy default AIRA generates new Ethereum address for you (it's [possible](/docs/aira-faq#how-to-change-ethereum-address-of-aira) to generate new one).\n\nIt's mainly used to sign all the outcoming messages.\n\n## Lighthouse\n\nIn Robonomics Network an agent must choose a lighthouse to work on. By default it's `airalab.lighthouse.5.robonomics.eth`.\n\nYou can choose existing one or create your own on [Lighthouses](https://dapp.robonomics.network/#/lighthouse) page.\n\n## Peers\n\nThe amount of IPFS pubsub [peers](/docs/aira-faq#how-to-check-the-quantity-of-ipfs-peers).\n\n## Date\n\nThe date and time of last update\n\n## Network\n\nRobonomics Network officially works in Ethereum Mainnet.\nThere is also [Sidechain](https://github.com/airalab/airalab-sidechain) which is mostly for testing purpose.\n\n\n"}},{node:{id:"e4f7e773b1a4ce70a9efa64c1cf881e0",title:"Contracts deployment",path:"/docs/ja/robonomics-contracts-deployment/",content:"\nRobonomics network works on top of the existing Ethereum network. The protocol is implemented by smart contracts. A source code is on [Github](https://github.com/airalab/robonomics_contracts). Airalab team deploys new version of contracts and supports a current one. \n\nIn this lesson we are going to learn more about these contracts. To do this we will deploy our test copy. Also we are going to use these contracts in the future lessons. \n\nYou need a client running Ethereum node. You can use either one of existing network (e.g. Mainnet, Ropsten, Kovan) or your local one. For testing purpose we suggest to use this [docker container](https://github.com/f-o-a-m/cliquebait) \n\n    $ docker run --rm -d -p 9545:8545 -p 9546:8546 foamspace/cliquebait:latest\n\nNext step is obtain a copy of robonomics contracts source code:\n\n    $ git clone --recursive https://github.com/airalab/robonomics_contracts\n\nA file truffle.js contains available networks for migration. We will work with development network. When you are in `robonomics_contracts` directory install dependencies and run a migration:\n\n    npm install // to install dependencies\n    truffle migrate --network development\n\nIt's time to learn how to create a new lighthouse. For more information about Robonomics network and Lighthouse in particular read [white paper](http://static.robonomics.network/docs/book-the-economy-of-robots-1-2017/robonomics.network-book-the-economy-of-robots-1-2017-en.pdf). Briefly lighthouse o distributes the running time of providers. Every lighthouse serves its own broadcast channel. Ask and Bid messages come into this channel. XRT tokens are used as a payment. \n\nWhen XRT contracts was deployed some tokens were issued on our account. Let's check the balance:\n\n    $ truffle --network development console\n    > xrt = XRT.at(XRT.address)\n    > xrt.balanceOf(web3.eth.accounts[0])\n\nAnd that's how we create a lighthouse:\n\n    > factory = LiabilityFactory.at(LiabilityFactory.address)\n    > tx = factory.createLighthouse(1000, 10, \"test\")\n    > tx.then(x => {laddress = x.logs[0].args.lighthouse})\n    > l = LighthouseLib.at(laddress)\n\nInstead of deploying a lighthouse contract every time we need a new one, we ask a factory to do this job. A `l` variable contains lighthouse instance. The lighthouse should be able to spend our tokens. Let's make an approve and check everything went well:\n\n    > xrt.approve(l.address,1000)\n    > xrt.allowance(web3.eth.accounts[0],l.address)\n\nAnd a very important step is become a worker:\n\n    > l.refill(1000)\n\nEach worker has to put a stake. In this case it's 1000 Wn.\n\nBelow is a table of our addresses:\n\n| Contract          | Address                                       | ENS name                          |\n|------------------ |--------------------------------------------   |---------------------------------- |\n| ENSRegistry       | 0x80c77a7de64a15450bb8cf45ece4fbb7bae6fb49    |                                   |\n| XRT               | 0x673583a369eb3a830a5571208cf6eb7ce83987f8    | xrt.3.robonomics.eth              |\n| LiabilityFactory  | 0x1b3190e00c1903266862af1f31714d4b81ef59b2    | factory.3.robonomics.eth          |\n| Lighthouse        | 0xd2b78c032b6c8851a8b6cbf950caa02a77618d8e    | test.lighthouse.3.robonomics.eth  |\n"}},{node:{id:"51d632384678015c9a079e2499038e70",title:"Become a Provider",path:"/docs/ja/robonomics-become-a-provider/",content:'\nThis page describes how to create a lighthouse and become a provider in the Robonomics network.\n\n## Prepare an address\n\nFirst of all, an Ethereum address is required. You must have access to a private key of the address. In case you don\'t have one, below are steps to create an address via [Parity](https://www.parity.io/ethereum/).\n\n```\n$ sudo snap install parity\n$ parity.ethkey generate random\nsecret:  15abe71557c07b69537bbe4352ed10a057be89037c69d4b35556112519911539\npublic: 38b800bfd90d486c78c646da79bb94b9d038aca8aad221062ce1b148df7764bfef02f6b3cf931786b6997540b798ea226ae60bd201c222d8f702e408a1a5cbff\naddress: c531fa8f141493df3da264a864bdcbec19695b4c\n```\n\nThe `secret` field is a private key, you\'ll need it to run the provider client. Save it to a file:\n\n```\n$ echo \'0x15abe71557c07b69537bbe4352ed10a057be89037c69d4b35556112519911539\' > private.key\n```\n\nThe next step is to deposit some ethers and XRT tokens to the address which is held in the `address` field.\n\n## Create a lighthouse\n\nGo to the lighthouse [dapp](https://dapp.robonomics.network/#/lighthouse) and fill in a name in the right side:\n\n![The Right Side](../images/become_a_provider_1.jpg "The Right Side")\n\nClick on the `Create lighthouse and connect to the network` button and sign a transaction. After a while you should see:\n\n![Success of Creating a Lighthouse](../images/become_a_provider_2.jpg "Success of Creating a Lighthouse")\n\nNow it\'s time to put a stake. Select the new lighthouse and click `Connect to the network`:\n\n![Selecting the Lighthouse](../images/become_a_provider_3.jpg "Selecting the Lighthouse")\n\nOn this page in the `Provider` section click the `Approve` button, sign a transaction. When it\'s mined click the `Refill` button and do the same.\n\n## Install the client\n\nNow you need to install [robonomics-tools](https://github.com/airalab/robonomics-tools) at least 0.4.2 version. You can build from the source or do the following steps:\n\n**Make sure you have Nix and Stack installed:**\n    \n```\n$ curl -sSL https://get.haskellstack.org/ | sh\n$ curl https://nixos.org/nix/install | sh\n```\n\n* Setup Airalab binary cache at [https://aira.cachix.org](https://aira.cachix.org/)\n* Import Airalab channel:\n\n```\n$ nix-channel --add http://aira.life/channels/aira-unstable/ aira\n$ nix-channel --update\n```\n* Install from the binary cache:\n\n```\n$ nix-env -iA aira.robonomics-tools\n```\n* Run the client:\n\n```\n$ xrtd --lighthouse mobilerobotics.lighthouse.5.robonomics.eth --private $(cat private.key)\n```\n\n**Get familiar with the `xrtd` options via `xrtd --help`.**\n\n## Test the provider\n\nTo test your provider go again to the lighthouse [dapp](https://dapp.robonomics.network/#/lighthouse/) and connect to the just created lighthouse.\n\nAt the bottom you should see the `TEST LIGHTHOUSE` section.\n\nClick on the `Demand` button and then on the `Offer` one. You should see something similar to:\n\n![Demand and Offer messages](../images/provider_mobilerobotics_demand_offer.jpg "Demand and Offer messages")\n\nDon\'t forget to sign every message with the MetaMask extension.\n\nFinally you should see a new liability contract created:\n\n![Liability is created](../images/provider_mobilerobotics_liability.jpg "Liability is created")\n'}},{node:{id:"13d6b0afc508706f9aea25da687c6f0f",title:"Robonomics IO Overview",path:"/docs/ja/rio-overview/",content:"\nThe [crate](https://crates.robonomics.network/robonomics_io/index.html) provides a convenient way to interact with blockchain and includes a set of tools. The latest release can be found [here](https://github.com/airalab/robonomics/releases)\n\n```\n% ./robonomics io\nrobonomics-io 0.21.0\nRobonomics Framework I/O operations\n\nUSAGE:\n    robonomics io [FLAGS] [OPTIONS] <SUBCOMMAND>\n\nFLAGS:\n        --dev        Specify the development chain\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nOPTIONS:\n    -d, --base-path <PATH>        Specify custom base path\n        --chain <CHAIN_SPEC>      Specify the chain specification (one of dev, local, or staging)\n    -l, --log <LOG_PATTERN>...    Sets a custom logging filter. Syntax is <target>=<level>, e.g. -lsync=debug\n\nSUBCOMMANDS:\n    help     Prints this message or the help of the given subcommand(s)\n    read     Read information from device\n    write    Write information into device\n```\n\n## The Pipeline Philosophy \n\nThe tool is designed in order to be included in a pipeline chain of processes. From Unix user experience everyone is familiar with commands like:\n\n```\nps aux | grep robonomics\n```\n\nIt means standard output produced by the `ps` program becomes standard input for the `grep` program. \n\nThe `robonomics io` consists of several subcommands with reading, writing abilities or both. It treats everything as a virtual or physical device ([everything is a file](https://en.wikipedia.org/wiki/Everything_is_a_file))\n\n## Read Overview\n\nIn general `read` means it reads data from a device or a network and prints it in `stdout`.\n\nHow to use it for:\n\n* [ipfs](/docs/rio-ipfs)\n* [launch](/docs/rio-launch)\n\n```\n% ./robonomics io read\nrobonomics-io-read 0.4.0\nRead information from device\n\nUSAGE:\n    robonomics io read <SUBCOMMAND>\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nSUBCOMMANDS:\n    help      Prints this message or the help of the given subcommand(s)\n    ipfs      Download data from IPFS storage\n    launch    Robot launch request events\n    pubsub    Subscribe for broadcasing data\n    sds011    Nova SDS011 particle sensor\n```\n\n## Write Overview\n\nUsually it writes data to blockchain or publishes to pubsub channel. \n\nHow to use it for:\n\n* [datalog](/docs/rio-datalog)\n* [ipfs](/docs/rio-ipfs)\n* [launch](/docs/rio-launch)\n\n```\n% ./robonomics io write\nrobonomics-io-write 0.4.0\nWrite information into device\n\nUSAGE:\n    robonomics io write <SUBCOMMAND>\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nSUBCOMMANDS:\n    datalog    Data blockchainization subsystem command\n    help       Prints this message or the help of the given subcommand(s)\n    ipfs       Upload data into IPFS storage\n    launch     CPS launch subsystem command\n    pubsub     Broadcast data into PubSub topic\n```\n\n## Local Testnet\n\nFor testing purpose it's possible to run the development environment:\n\n```\n% ./robonomics --dev --rpc-cors all\n```\n\n`--rpc-cors all` allows the [Dapp](https://parachain.robonomics.network/) to be connected to local node. After launching the node, go to the dapp, click on Robonomics icon in the upper left corner, choose Development and put node's local address\n\n![Robonomics Dapp Connect to Local Node](../images/robonomics-dapp-connect-local.jpg \"Robonomics Dapp Connect to Local Node\")\n\nFinally click Switch and you should be connected to the local node. Check out Accounts tab. There you can create new accounts and transfer tokens.\n\n"}},{node:{id:"6a710f8046cf246621eeb62d6e0d4056",title:"Robonomics IO Launch",path:"/docs/ja/rio-launch/",content:'\nA simple way to turn on and off an IoT device or a robot. Basically sending "ON" will result in `true` state for a device, anything else will result in `false`.\n\nFor the examples the development network is used. Check [this](/docs/robonomics-test-network-manual/) out to set it up for yourself.\n\n## Requirements\n\n* `robonomics` [executable](https://github.com/airalab/robonomics/releases)\n* Accounts on parachain\n\nYou can find instructions on how to create an account [here](/docs/create-account-in-dapp)\n\n## Usage\n\nTo see the result of transaction first of all run `read` part:\n\n```\n% ./robonomics io read launch\n```\n\nNow let\'s turn a robot on:\n\n```\n% echo "ON" | ./robonomics io write launch -r 5CiPPseXPECbkjWCa6MnjNokrgYjMqmKndv2rSnekmSK2DjL -s 0xb046fc3c322e91e14a61ad4f08a3809ee0de7092e73aa9b3c2b642a0f476d4d6\n```\n\nThen you should see in the first terminal window:\n\n```\n% ./robonomics io read launch\n5H3iRnX16DH2sb2RLxMM8UhDZTvJjP84EhhKXv3sCiEDq6bH >> 5CiPPseXPECbkjWCa6MnjNokrgYjMqmKndv2rSnekmSK2DjL : true\n```\n\nLet\'s describe all the accounts and options above.\n\n* `-r 5CiPPseXPECbkjWCa6MnjNokrgYjMqmKndv2rSnekmSK2DjL` means robot\'s address\n* `-s 0xb046fc3c322e91e14a61ad4f08a3809ee0de7092e73aa9b3c2b642a0f476d4d6` private key of the account to launch from (must have tokens for a transaction)\n* `5H3iRnX16DH2sb2RLxMM8UhDZTvJjP84EhhKXv3sCiEDq6bH` address that launches a robot\n* `true` turn it on\n\nIf we pass anything else but "ON" the state becomes `false`\n\n## Remote\nIf your local node is configured differently from defaults or you have a remote node, it\'s possible to specify it with `--remote` option\n\n```\n% echo "ON" | ./robonomics io write launch -r 5CiPPseXPECbkjWCa6MnjNokrgYjMqmKndv2rSnekmSK2DjL -s 0xb046fc3c322e91e14a61ad4f08a3809ee0de7092e73aa9b3c2b642a0f476d4d6 --remote https://ipfs.infura.io:5001/\n```\n\nand\n\n```\n% ./robonomics io read launch --remote https://ipfs.infura.io:5001/\n```\n'}},{node:{id:"80dfb9552daca0abf7da618de716cc9f",title:"Robonomics IO IPFS",path:"/docs/ja/rio-ipfs/",content:'\nIt serves downloading and uploading files from/to IPFS network\n\n## Requirements\n\n* `robonomics` [executable](https://github.com/airalab/robonomics/releases)\n* Running [IPFS](https://ipfs.io/#install) daemon \n\n## Write\n\n```\n% echo "Hello Robonomics" | ./robonomics io write ipfs\nQmQAcvgXmcZEjXGibXGFcqdsvvrnWp3BguuubWhzSBZMXy\n```\n\n## Read\n\n```\n% echo QmQAcvgXmcZEjXGibXGFcqdsvvrnWp3BguuubWhzSBZMXy | ./robonomics io read ipfs\nHello Robonomics\n```\n\n## Remote IPFS node\n\nIf your local node is configured differently from defaults or you have a remote node, it\'s possible to specify it with `--remote` option\n\n```\n% echo "Hello Robonomics" | ./robonomics io write ipfs --remote https://ipfs.infura.io:5001/\nQmQAcvgXmcZEjXGibXGFcqdsvvrnWp3BguuubWhzSBZMXy\n```\n\nThe same applies for `read`\n\n'}},{node:{id:"e9f07ff7ed181e69c4daac95677a99d5",title:"Robonomics IO Datalog",path:"/docs/ja/rio-datalog/",content:'\nDatalog module allows you to store any string on blockchain\n\nhttps://www.youtube.com/watch?v=rs67AMyd-gE\n\nFor the examples the development network is used. Check [this](/docs/robonomics-test-network-manual/) out to set it up for yourself.\n\n## Requirements\n\n* `robonomics` [executable](https://github.com/airalab/robonomics/releases)\n* Account on parachain\n\nYou can find instructions on how to create an account [here](/docs/create-account-in-dapp)\n\n## Write\n\nAssuming local node is running:\n\n```\n% echo "Hello Robonomics" | ./robonomics io write datalog -s 0xb046fc3c322e91e14a61ad4f08a3809ee0de7092e73aa9b3c2b642a0f476d4d6\n```\n\nwhere `0xb046fc3c322e91e14a61ad4f08a3809ee0de7092e73aa9b3c2b642a0f476d4d6` is a private key for the account with tokens.\nIn this example the public key is 5H3iRnX16DH2sb2RLxMM8UhDZTvJjP84EhhKXv3sCiEDq6bH. Let\'s go to the [Dapp](https://parachain.robonomics.network/)\nand see what happened.\n\nIn the Dapp go to Developer -> Chain state. In the "selected state query" list choose datalog and below choose your account. Click plus button on the right and you should see the following:\n\n![Robonomics Chain State Datalog](../images/robonomics-dapp-chain-state-datalog.jpg "Robonomics Chain State Datalog")\n\n## Remote\nIf your local node is configured differently from defaults or you have a remote node, it\'s possible to specify it with `--remote` option\n\n```\n% echo "Hello Robonomics" | ./robonomics io write datalog -s 0xb046fc3c322e91e14a61ad4f08a3809ee0de7092e73aa9b3c2b642a0f476d4d6 --remote https://ipfs.infura.io:5001/\n```\n'}},{node:{id:"b75101e944b78d01ca074c89c8c659ee",title:"R&D Based on Robonomics Network",path:"/docs/ja/r-and-d-based-on-robonomics-network/",content:'\nFor over 4 years, the Robonomics project participants completed 13 R&D projects in the process of writing the current version of the Robonomics platform, including:\n\n### Launching a drone under the control of a decentralized computer.\n2016 - Successful field test of 3DR X8 drone compatibility with Drone Employee software.\nBelow you can observe a workflow in which a person sends a Drone transaction through the Ethereum Blockchain.\n\nhttps://www.youtube.com/watch?v=V_3rcP2Duv0&t=1s\n\n### Management of a fleet of drones in a decentralized network.\n[Distributed Sky](https://airmarket.io/wp-content/uploads/2018/09/Distributed-Sky-Whitepaper-v3.0.pdf) is the backbone of the Unmanned aircraft system traffic management (UTM). It uses a global network of computers to process and store identities, traffic and other sensitive information, and uses cryptography to make the UTM process secure and scalable.\nBelow is the video of Drone Passport agent in action.\n\nhttps://www.youtube.com/watch?v=yxGTOkGkBJ8\n\n### Tokenization of data from IoT devices.\n\nThe 4th industrial revolution is flying the flag of CPSs’ total integration into mass production and rendering services. Machines do not engage in empty talk, they are honest in their work and can be an independent party supplying information, based on algorithmic analysis of which the network itself can emit new units of any value.\nValues based on the labor of machines will be much more interesting for the new generation than other values, the emission of which is built on any other principle. More information available [here](https://blog.aira.life/tokenization-and-the-4th-industrial-revolution-3208022be747)\n\n### Digital markets for robots.\n\n### Industrial zone management with capital.\n[The article](https://ieeexplore.ieee.org/abstract/document/8525391) presents the architecture of communication protocol for modern industrial processes and business based on cyber-physical systems - Industry 4.0. The main attention is paid to one of the key trends of this concept - to economical autonomous agents i.e. to robots or smart things, which are able to make decisions independently about their economic actions. Agents begin to fully participate in business processes, so it is important to automate the processes and ensure formal and secure communication between multiple heterogeneous agents, taking into account the economic component of the industry. The article shows how to organize economic interaction between agents using a peer-to-peer network based on decentralized Blockchain technology and smart contracts. More information about Industry 4.0 may be found in a video below.\n\nhttps://www.youtube.com/watch?v=yuxOF_z70us\n\n### Drones, sensors, and blockchain for monitoring the quality of water on the Volga.\nAs part of [this river project](https://github.com/airalab/drone_on_volga), the drone offers its services through a web application allowing any user to request the service. Typically, the mission generates parameters such as drone position, travel speed, measured water quality parameters, and other minor requirements.\nThe Robonomics network is used to communicate with the robot. With its help, the robot can offer its services, and citizens or government officials can order them by making a cryptocurrency payment through the website. The Robonomics network is built on the Ethereum blockchain platform and the IPFS protocol, which record the hash of sensor measurements in the public blockchain and thus protect historical data from possible falsification.\nFascinating video about experiments with water drone is below.\n\nhttps://www.youtube.com/watch?v=Mtqm5y6Bolo\n\n### Civilian observatory networks.\nIn August 2018 Airalab with support of Smart Distribution (Libelium distributor in Russia) [set up a measuring network in a living district in Tolyatti, Russia](https://www.libelium.com/libeliumworld/success-stories/preventing-asthsma-sensor-network-air-quality-pm10-dust-in-play-area/).\nThe aim was to create the basis for the implementation of an air quality monitoring network in areas of special vulnerability (schools, playgrounds, nursing homes, hospitals, etc.) that can provide local authorities with information to take measures to protect their citizens.\nAn example of using a sensor is shown in a video below. Also, source code may be found [here](https://github.com/airalab/sensors-connectivity).\n\nhttps://www.youtube.com/watch?v=shqey3tmNUk\n\n### Robot artist Gaka-chu.\nModern technologies make human life more comfortable and more fun, freeing up time for reflection and experimentation.\nIt was a series of reflections on the static nature of the industry that led the development team to the idea of ​​conducting an experiment showing the autonomous transformation of production for a specific type of product.\nSuch an experiment became a [robot artist](https://github.com/airalab/robot_painter/) - a small, clumsy KUKA manipulator living in a large world of serious industrial robots. And his name is Gaka-chu. Why? Because of the love of drawing: "gaka" in Japanese is "artist". And "chu" was added for an inexplicable love for Pokemons.\n\nhttps://youtu.be/xSD_lsrAA0I\n\n### Issuance of green certificates based on the data from renewable energy sources.\nThe conceptual goal of [DAO IPCI](https://ipci.io/ru/) is to provide a common space, common environment, tools and ecosystem that is universal, reliable, easy to use, allowing a variety of stakeholders, including businesses and people, to record quantitative impacts and quantitative commitments, invest in negative impact mitigation projects, offset the carbon footprint, acquire and trade mitigation results, join existing programs or launch new ones. Source code is provided [here](https://github.com/DAO-IPCI/DAO-IPCI).\n\nhttps://www.youtube.com/watch?v=q9plB0TjUnw&list=PLLepqB9oh7WvUVzbeaiwQojrip2tLPA6P\n\n### Roadspace negotiation for autonomous cars.\nOur goal was to develop a [decentralized system](https://github.com/khssnv/mobi_grand_challenge) for road space negotiation where autonomous vehicles can pay for routes and right of way. We believe a market-based approach can be used to alleviate a traffic congestion problem.\n\nhttps://youtu.be/JFQTknMZOYg\n\n### Blockchain in the tasks of the chemical industry.\nOriginally the following task was set: developing a [quality control system](https://github.com/Vourhey/chemistry-quality-control) for the production of a certain chemical product. Why is monitoring the quality so important here? The main active substance of this chemical product is chlorine dioxide. It is hazardous to health in high concentrations. And if the concentration is below normal, then this chemical product is useless.\nAnd what does Blockchain have to do with it? Blockchain helps building trust to the manufacturing company. The consumer knows that no one can change the information in the Blockchain. That means that the manufacturing company can not forge the results of the audit.\n\n### Control of equipment maintenance process by supply chain participants based on IoT data.\n\n### Robot as a service in service robotics.\nRobonomics is the ready-to-work and open-source platform which you can use to connect your robot as a service for end-users, they call it [‘Robot-as-a-Service’](https://blog.aira.life/how-can-you-hire-a-robot-176ba29da565). Robonomics support Web3 technologies that implement the exchange of technical and economic information between humans and machines. Robonomics is a purely technical and open source project.\n\nhttps://www.youtube.com/watch?v=IEgvXcj3nSo'}},{node:{id:"f3cf38e1254e040be7421ebb43f8c765",title:"Playground Overview",path:"/docs/ja/playground-overview/",content:"\nRobonomics allows to use robots as autonomous agents that receive commands from a human or another robot and do some useful work, storing a report of their actions in Blockchain. The interaction between the robot and the Robonomics platform is quite simple with a [Robonomics IO](/docs/rio-overview).\n## What Robots You Can Control\nThe playground section contains examples of connecting different robots to Robonomics which everyone can try to repeat step by step. In this section you can try to control:\n* [an Unmanned Aerial Vehicle](/docs/iris-drone/)\n* [a Mars Rover](/docs/connect-mars-curiosity-rover-under-robonomics-parachain-control/)\n* [a Manipulator](/docs/kuka/)\n* [an industrial Baxter Robot](/docs/baxter2/)\n\nSince all robots are available as simulation models, you don't need any special hardware. So you can try to connect the robot to Robonomics Network right now.\n## How Do You Control the Robot\nAll of our Demos are launched in a local network, however you can connect a robot to the live networks in the same way.\n\nAll Demos in this section follow a similar scenario. You [create an account](/docs/create-account-in-dapp/) for the robot and send him some units for paying transactions. Then the user sends an `ON/OFF` transaction to the robot's address, the robot receives it and starts working. After the job is done the telemetry is saved in IPFS and the file hash is sent to datalog. So at any time you can see how the robot performed its work.\n## Connect Your Own Robot\nIn addition you can create your own control package for any ROS-compatitable device with [this](/docs/connect-any-ros-compatitable-robot-under-robonomics-parachain-control-1/) instruction.\n\n"}},{node:{id:"d87fad7fc0438db5796bb909f6c368b5",title:"Market messages",path:"/docs/ja/market-messages/",content:"\nMarket messages is used for exchange **Demand** and **Offer** information. It also used for delivery **Result** messages with liability execution reports.\n\n> This is spec for Robonomics `Generation 5`.\n\n- Currently for message delivery is used [IPFS PubSub](https://ipfs.io/blog/25-pubsub/) broadcaster.\n- IPFS PubSub **topic** is set according to *Lighthouse [ENS](https://ens.domains/) name*.\n\n## Messages content\n\nRobonomics market message use [JSON](https://www.json.org/) data format.\n\n\n### Demand\n\n| Field | ROS Type | Description |\n|-------------- |-------------------------  |------------------------------------------------ |\n| model | [ipfs_common/Multihash](/docs/ipfs-common-messages#ipfs_commonmultihashmsg) | CPS behavioral model identifier |\n| objective | [ipfs_common/Multihash](/docs/ipfs-common-messages#ipfs_commonmultihashmsg) | CPS behavioral model parameters in rosbag file |\n| token | [ethereum_common/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) | Operational token address |\n| cost | [ethereum_common/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg) | CPS behavioral model execution cost |\n| lighthouse | [ethereum_common/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) | Lighthouse contract address |\n| validator | [ethereum_common/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) | Observing network address |\n| validatorFee  | [ethereum_common/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg) | Observing network fee |\n| deadline | [ethereum_common/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg) | Deadline block number |\n| nonce | [ethereum_common/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg) | Robonomics message counter |\n| sender | [ethereum_common/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) | Message sender address |\n| signature | std_msgs/UInt8[] | Sender’s Ethereum signature |\n\n### Offer\n\n| Field             | ROS Type                  | Description                                       |\n|---------------    |-------------------------  |------------------------------------------------   |\n| model             | [ipfs_commom/Multihash](/docs/ipfs-common-messages#ipfs_commonmultihashmsg)     | CPS behavioral model identifier                   |\n| objective         | [ipfs_commom/Multihash](/docs/ipfs-common-messages#ipfs_commonmultihashmsg)     | CPS behavioral model parameters in rosbag file    |\n| token             | [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg)   | Operational token address                         |\n| cost              | [ethereum_commom/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg)   | CPS behavioral model execution cost               |\n| validator         | [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg)   | Observing network address                         |\n| lighthouse        | [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg)   | Lighthouse contract address                       |\n| lighthouseFee     | [ethereum_commom/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg)   | Liability creation fee                            |\n| deadline          | [ethereum_commom/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg)   | Deadline block number                             |\n| nonce             | [ethereum_commom/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg)   | Robonomics message counter                        |\n| sender            | [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg)   | Message sender address                            |\n| signature         | std_msgs/UInt8[]          | Sender’s Ethereum signature                       |\n\n### Result\n\n| Field         | ROS Type                  | Description                       |\n|-----------    |-------------------------  |---------------------------------- |\n| liability     | [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg)   | Liability contract address        |\n| result        | [ipfs_commom/Multihash](/docs/ipfs-common-messages#ipfs_commonmultihashmsg)     | Liability result multihash        |\n| success       | std_msgs/Bool             | Is liability executed successful  |\n| signature     | std_msgs/UInt8[]          | Sender’s Ethereum signature       |\n\n## Messages signing\n\nBefore signing the messages is packed using [abi.encodePacked](https://solidity.readthedocs.io/en/latest/abi-spec.html#non-standard-packed-mode\n) solidity finction and hashed by Keccak_256.\n\n```\n   demandHash = keccak256(abi.encodePacked(\n        _model\n      , _objective\n      , _token\n      , _cost\n      , _lighthouse\n      , _validator\n      , _validator_fee\n      , _deadline\n      , IFactory(factory).nonceOf(_sender)\n      , _sender\n      ));\n```\n\n**`nonce` parameter is counted by factory smart contract and incremented for each created liability smart contract.**\n\nMessage hash are signed using Ethereum ``secp256k1`` [signature](https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign).\n"}},{node:{id:"82663754528cff8b1c970d83669613b4",title:"Control Kuka manipulator with robonomics",path:"/docs/ja/kuka/",content:"\nVideo with an example of work can be found here:\n\n[https://youtu.be/Fhf9LIt6zXQ](https://youtu.be/Fhf9LIt6zXQ)\n***\n## Requirements\n* ROS melodic, Gazebo (installation instraction [here](http://wiki.ros.org/melodic/Installation/Ubuntu))\n* Some extra packages\n```bash\nsudo apt-get install ros-melodic-gazebo-ros-control ros-melodic-effort-controllers ros-melodic-joint-state-controller\n```\n* IPFS 0.4.22 (download from [here](https://www.npackd.org/p/ipfs/0.4.22) and install)\n```bash\ntar -xvzf go-ipfs_v0.4.22_linux-386.tar.gz\ncd go-ipfs/\nsudo bash install.sh\nipfs init\n```\n* pip\n```bash\nsudo apt install python-pip\n```\n* ipfshttpclient\n```bash\npip install ipfshttpclient\n```\n* Robonomics node (binary file) (download latest release [here](https://github.com/airalab/robonomics/releases))\n* IPFS browser extension (not necessary)\n***\n## Installation\nInstall Kuka manipulator and control packages\n```bash\ncd catkin_ws/src/\ngit clone https://github.com/orsalmon/kuka_manipulator_gazebo\ngit clone https://github.com/LoSk-p/kuka_controller\ncd ..\ncatkin_make\necho \"source /home/$USER/catkin_ws/devel/setup.bash\" >> ~/.bashrc\n```\n***\n## Running gazebo model\n```bash\nroslaunch manipulator_gazebo manipulator_empty_world.launch\n```\nIn a new window\n```bash\nrosrun manipulator_gazebo move_arm_server\n```\n![model](../images/kuka-demo/gazebo.jpg)\n***\n## Running robonomics\nGo to the folder with robonomics file ad create a local robonomics network:\n```bash\n./robonomics --dev --rpc-cors all\n```\n\n![robonomics](../images/kuka-demo/robonomics.jpg)\n\n**Important!** Before next launches it is necessary to remove a directory `db` with\n\n```\nrm -rf /home/$USER/.local/share/robonomics/chains/dev/db\n```\n\nGo to https://parachain.robonomics.network and switch to local node\n\n![local](../images/kuka-demo/local.jpg)\n\nThen go to Accounts and create KUKA and WORK accounts. Save account's addresses and keys, you will need them later\n\n![acc](../images/kuka-demo/create_account.jpg)\n\n![accs](../images/kuka-demo/accounts.jpg)\n***\n## Running ipfs\nRun ipfs daemon:\n```bash\nipfs daemon\n```\n***\n## Running control package\nIn kuka_control package path you need to edit move_arm_client.py. \n```bash\ncd src/\nnano move_arm_client.py\n```\nChange kuka_address, kuka_key and work_address to you addresses and key, then change robonomics_path to your path to file robonomics.\n\n![code](../images/kuka-demo/code.jpg)\n\nNow you can run control script:\n```bash\npython move_arm_client.py\n```\n![control](../images/kuka-demo/control.jpg)\n\nThen in a new window send a transaction to make Kuka move:\n```bash\necho \"ON\" | ./robonomics io write launch -r <KUKA_ADDRESS> -s <WORK_KEY>\n```\nWhere <KUKA_ADDRESS> and <WORK_KEY> are address and key from your accounts:\n\n![transaction](../images/kuka-demo/transaction.jpg)\n\nIn the window with kuka_control package you will see:\n\n![done](../images/kuka-demo/done.jpg)\n\nThen go Developer/Chain state on the Robonomics portal, select datalog in query and add KUKA datalog with button '+':\n\n![datalog](../images/kuka-demo/datalog.jpg)\n\nNow you can find Kuka's telemetry using this hash in IPFS Companion:\n\n![ipfs](../images/kuka-demo/ipfs.jpg)\n\n![telemetry](../images/kuka-demo/telemetry.jpg)\n\n## Troubleshooting\n\nIf `catkin_make` doesn't work with the message that it can't find MoveArm.h, try to remove last four lines in CMakeLists.txt in kuka_manipulator_gazebo package:\n```\ninclude_directories(include ${catkin_INCLUDE_DIRS})\n\nadd_executable(move_arm_server src/move_arm_server.cpp)\ntarget_link_libraries(move_arm_server ${catkin_LIBRARIES})\nadd_dependencies(move_arm_server beginner_tutorials_gencpp)\n```\nDo `catkin_make` without these lines, then returm them and do `catkin_make` again.\n\n\n\n\n"}},{node:{id:"7e176f3ca88116710bed8c64d0487200",title:"Drone control with robonomics",path:"/docs/ja/iris-drone/",content:'\n**Drone starts moving after transcation and store file with the coordinates in IPFS. The control script is based on the [GAAS demo script](https://github.com/generalized-intelligence/GAAS)**  \n\nhttps://youtu.be/4CwtGAX1OwM\n\n## Requirements\n* dependencies for control:\n``` sh\nsudo apt install -y \\\n\tpython3-pip \\\n\tninja-build \\\n\texiftool \\\n\tpython-argparse \\\n\tpython-empy \\\n\tpython-toml \\\n\tpython-numpy \\\n\tpython-yaml \\\n\tpython-dev \\\n\tpython-pip \\\n\tninja-build \\\n\tprotobuf-compiler \\\n\tlibeigen3-dev \\\n\tgenromfs\n```\n```sh \npip3 install \\\n\tpandas \\\n\tjinja2 \\\n\tpyserial \\\n\tcerberus \\\n\tpyulog \\\n\tnumpy \\\n\ttoml \\\n\tpyquaternion\n```\n* ROS Melodic + Gazebo [installation tutorial](http://wiki.ros.org/melodic/Installation)\n* extra packages: \n``` bash \nsudo apt-get install ros-melodic-gazebo-ros-control ros-melodic-effort-controllers ros-melodic-joint-state-controller\nsudo apt-get install python-jinja2\nsudo apt-get install python-catkin-pkg\nsudo apt-get install python3-catkin-pkg-modules\n```\n* IPFS verson 0.4.22\n```bash\nwget https://dist.ipfs.io/go-ipfs/v0.4.22/go-ipfs_v0.4.22_linux-amd64.tar.gz\ntar -xvzf go-ipfs_v0.4.22_linux-amd64.tar.gz\ncd go-ipfs\nsudo bash install.sh\nipfs init\n```\n* ipfshttpclient\n```sh\npip3 install ipfshttpclient\n```\n* Robonomics node (binary file) (download latest release [here](https://github.com/airalab/robonomics/releases))\n## Environment Setup\n```bash \nsudo apt-get install ros-melodic-mavros ros-melodic-mavros-extras\nwget https://raw.githubusercontent.com/mavlink/mavros/master/mavros/scripts/install_geographiclib_datasets.sh\nsudo ./install_geographiclib_datasets.sh\ncd ~/catkin_ws/src\ngit clone https://github.com/PX4/Firmware.git\ncd Firmware\ngit checkout v1.9.0\nbash ./Tools/setup/ubuntu.sh\n```\n```bash\ncd ~/catkin_ws/src\ngit clone https://github.com/generalized-intelligence/GAAS.git\ncp -r ~/catkin_ws/src/GAAS/simulator/models/* ~/catkin_ws/src/Firmware/Tools/sitl_gazebo/models/\ncp -r ~/catkin_ws/src/GAAS/simulator/worlds/* ~/catkin_ws/src/Firmware/Tools/sitl_gazebo/worlds/\ncp -r ~/catkin_ws/src/GAAS/simulator/posix-config/* ~/catkin_ws/src/Firmware/posix-configs/SITL/init/ekf2/\n```\n\nModifying your `.bashrc` file, adding the following lines to the bottom:  \n\n`source ~/catkin_ws/devel/setup.bash `  \n`source ~/catkin_ws/src/Firmware/Tools/setup_gazebo.bash ~/catkin_ws/src/Firmware/ ~/catkin_ws/src/Firmware/build posix_sitl_default `   \n`export GAZEBO_MODEL_PATH=:~/catkin_ws/src/simulator/models`  \n`export ROS_PACKAGE_PATH=$ROS_PACKAGE_PATH:~/catkin_ws/src/Firmware`  \n`export ROS_PACKAGE_PATH=$ROS_PACKAGE_PATH:~/catkin_ws/src/Firmware/Tools/sitl_gazebo`  \n`export GAZEBO_MODEL_PATH=:~/catkin_ws/src/simulator/models:~/catkin_ws/src/GAAS/simulator/models`  \n\n  \n## Control Package Installation\nIn a new Terminal:\n```bash\ncd catkin_ws/src\ngit clone https://github.com/tubleronchik/robonomics_drone_sim.git\ncd ..\ncatkin build\n```\n## Robonomics Network\nTo create a local robonomics network go to the folder with the robonomic binary file and run:  \n`./robonomics --dev --rpc-cors all`  \n\nAdd robonomic\'s path to `config.py`\n\n![IPFS](../images/iris-drone-demo/IPFS.jpg)\n\nGo to the [Robonomics Portal](https://parachain.robonomics.network) and switch to local node.\n![localNode](../images/iris-drone-demo/localNode.jpg)\n\nGo to **Accounts** and create **DRONE** and **EMPLOYER** accounts. Save the account names and keys and path to **robonomics** to `~/catkin_ws/src/drone_sim/src/config.py`. Transfer some money into the accounts.\n\n![accounts](../images/iris-drone-demo/addingAcc.jpg)\n\n## Running Simulation\nRun IPFS daemon\n```bash\ncd go-ipfs\nipfs daemon\n```\nIn another terminal launch the simulation:\n```bash\nroslaunch px4 mavros_posix_sitl.launch\ncd ~/catkin_ws/src/robonomics_drone_sim/src\npython3 takeoff.py\n```\nWaiting till "Waiting for payment" \n\n![launch](../images/iris-drone-demo/launch.jpg)\n\nTo send a transaction run in another window:\n`echo "ON" | ./robonomics io write launch -r <drone_addres> -s <employer_key>` - where **<drone_address>** and **<employer_key>** should be replaced with the strings from `config.py` accordingly.\n\nAfter data was pushed to IPFS, go to the **Chain State** in [Robonomics Portal](https://parachain.robonomics.network). Select **datalog** in query and add DRONE datalog using `+` button.\n\n![datalog](../images/iris-drone-demo/datalog.jpg)\n\nYou can find drone\'s telemetry running `https://gateway.ipfs.io/ipfs/<hash>` inserting the hash from above.\n\n![output](../images/iris-drone-demo/output.jpg)\n\nIt\'s important to remove `db` derictory before next launches using  \n` rm -rf ~/.local/share/robonomics/chains/dev/db`\n'}},{node:{id:"3cfb18982d5b2cd6a007c39fa091a717",title:"IPFS Common",path:"/docs/ja/ipfs-common/",content:'\nThe package handle IPFS connections, provides useful services for working with IPFS Network. \nIt\'s included in `robonomics_liability` launch file\n\n## ROS Parameters\n\n### ~lighthouse_contract\n\nThe name of a lighthouse you are working on. The type is `string`, defaults to `airalab.lighthouse.5.robonomics.eth`\n\n### ~ipfs_http_provider\n\nIPFS HTTP provider address. The type is `string`, defaults to `http://127.0.0.1:5001`\n\n### ~ipfs_public_providers\n\nA public IPFS node to pin result files. The type is `string`, defaults to `""`\n\n### ~ipfs_file_providers\n\nA list of public nodes to pin result files. The type is `list of strings`, defaults to `[ipfs_public_providers]`\n\n### ~ipfs_swarm_connect_addresses\n\nIPFS nodes to connect to. The type is `string`, defaults to `""`\n\n### ~ipfs_swarm_connect_to\n\nA list of IPFS nodes to connect to. The type is `list of strings`, defaults to `[ipfs_swarm_connect_addresses]`\n\n## Subscribed topics'}},{node:{id:"3549e53e4798589986c48bf6b53839e8",title:"IPFS Common Messages",path:"/docs/ja/ipfs-common-messages/",content:"\n## ipfs_common/Filepath.msg\n\n| Field         | Type                  | Description           |\n|------------   |-------------------    |--------------------   |\n| filepath      | std_msgs/String       | A path to a file      |\n\n## ipfs_common/Multihash.msg\n\n| Field         | Type              | Description                               |\n|-----------    |-----------------  |------------------------------------------ |\n| multihash     | std_msgs/String   | A wrapper for model and objective fields  |\n\n## ipfs_common/IpfsDownloadFile.srv\n\n**Request**\n\n| Field         | Type                                                  | Description               |\n|-------------- |---------------------------------------------------    |------------------------   |\n| ipfs_address  | [ipfs_common/Multihash](#ipfs_commonmultihashmsg)     | IPFS hash of a file       |\n| file          | [ipfs_common/Filepath](#ipfs_commonfilepathmsg)       | Where to save the file    |\n\n**Response**\n\n| Field         | Type              | Description           |\n|-----------    |-----------------  |---------------------  |\n| success       | std_msgs/Bool     | Status of execution   |\n| error_msg     | std_msgs/String   | Error message         |\n\n## ipfs_common/IpfsUploadFile.srv\n\n**Request**\n\n| Field     | Type                                              | Description                               |\n|-------    |-------------------------------------------------  |---------------------------------------    |\n| file      | [ipfs_common/Filepath](#ipfs_commonfilepathmsg)   | Path to a file to be uploaded to IPFS     |\n\n**Response**\n\n| Field         | Type                                                  | Description                   |\n|-------------- |---------------------------------------------------    |----------------------------   |\n| success       | std_msgs/Bool                                         | Status of execution           |\n| error_msg     | std_msgs/String                                       | Error message                 |\n| ipfs_address  | [ipfs_common/Multihash](#ipfs_commonmultihashmsg)     | IPFS hash of uploaded file    |\n"}},{node:{id:"f5d482cdcbc241a51996676255e125c2",title:"IoT Sensors Connectivity",path:"/docs/ja/iot-sensors-connectivity/",content:"\nRobonomics Network allows you to communicate with any sensor you wish and get data from the sensor all around the world. This data can be transferred to different destinations.\n\nOn this page you'll find step-by-step instructions to connect an ESP board to the connectivity server provided by AiraLab.\n\n## Requirements\n\n* ESP8266/ESP32 like board with WiFi\n\n## 1. Get the software\n\n### On Windows\n\nInstall [WSL](https://docs.microsoft.com/en-us/windows/wsl/install-win10).\n\nInstall Ubuntu via Windows Store:\n\n![Windows Store](../images/windows_store.jpg \"Windows Store\")\n\nand clone the [package](https://github.com/airalab/sensors-connectivity)\n\n```\ngit clone https://github.com/airalab/sensors-connectivity\n```\n\nThe next step is to install python and dependencies:\n\n```\nsudo apt update && sudo apt install python3-pip\ncd sensors-connectivity\npip3 install -r requirements.txt\n```\n\n### On Ubuntu\n\n```\nsudo apt update && sudo apt install python3-pip git\ngit clone https://github.com/airalab/sensors-connectivity\ncd sensors-connectivity\npip3 install -r requirements.txt\n```\n\n> You can ignore such warnings:\n>\n> ```\n> The script ... is installed in '...' which is not on PATH.\n> Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.\n> ```\n\n### On NixOS\n\n```\ngit clone https://github.com/airalab/sensors-connectivity\ncd sensors-connectivity\nnix build -f release.nix\nsource result/setup.bash\n```\n"}},{node:{id:"09ec48d30b4ec3cb3475f2a4424b2c1f",title:"IoT Firmware Upload",path:"/docs/ja/iot-firmware-upload/",content:"\nThere are few firmwares for ESP like boards:\n\n* [Ping](https://github.com/airalab/sensors-connectivity/tree/master/boards/esp/ping)\n* [TCP](https://github.com/airalab/sensors-connectivity/tree/master/boards/esp/tcp)\n* [Mobile GPS](https://github.com/airalab/sensors-connectivity/tree/master/boards/esp/mobile_gps)\n\nThere is a script to upload a firmware for each one, called `flash_firmware.py`. It's located in the root of the repository\n\n> **Requirements**\n> In order to install all dependencies run in the root of the repository folder:\n>\n> ```\n> pip install -r requirements.txt\n> ```\n>\n> Python3 is required!\n\nUsually in order to upload a firmware to your board follow these steps:\n\n1. Assemble the board and connect it to PC\n2. Edit a `config.yaml` in a corresponding folder (e.g. `boards/esp/tcp/config.yaml`)\n3. Run `python flash_firmware.py -s PATH_TO_FOLDER -c PATH_TO_CONFIG` where `PATH_TO_FOLDER` is a path to the desired firmware (e.g. `boards/esp/ping`) and `PATH_TO_CONFIG` is a path to the configuration file (e.g. `boards/esp/ping/config.yaml`)\n\n"}},{node:{id:"9ab7b17934d634e9ce44ea460affd984",title:"Interact with AIRA",path:"/docs/ja/interact-with-aira/",content:'\nAt this point you should be familiar with a [DApp](/docs/get-weather-on-fuji-mountain/) and how to launch [AIRA image](/docs/aira-installation-on-vb/).\nNow you are ready to do more complicated stuff like installing a package and interacting with it via DApp.\n\n> **Important:**\n> Make sure you have covered previous lessons before you continue.\n\n\n> **Tip:**\n> During the lesson you will type a few commands in terminal. AIRA image doesn\'t support clipboard, so to make life easier have a look at [Connect via SSH](/docs/aira-connecting-via-ssh/) and log in via SSH to the VM.\n\nWalkthrough video:\n\nhttps://www.youtube.com/embed/QM06l07_wuA\n\n## Package installation\n\nAfter you launched AIRA and logged in using your terminal do the following:\n\n```\nsu liability && cd\ngit clone https://github.com/vourhey/hello_aira\ncd hello_aira\nnix build -f release.nix\nsource result/setup.bash\nrosrun hello_aira hello_aira\n```\n\nRun one by one commands above. After the last one you should see a link to DApp generated specifically for your instance.\n\n![Terminal with AIRA](../images/aira_hello_terminal.jpg "Terminal with AIRA")\n\nClick on the link, the DApp should be shown.\n\n## DApp \n\nConnect [MetaMask](http://metamask.io/) if prompted and click on the button\n\n![Request connection in Robonomics Dapp](../images/aira_hello_dapp.jpg "Request connection in Robonomics Dapp")\n\nSign the message as usual and wait for the result\n\n![Wait for Result of request](../images/aira_hello_dapp_2.jpg "Wait for Result of request")\n\nMeanwhile have a look at the terminal. You should see the greeting\n\n![AIRA greeting in terminal](../images/aira_hello_terminal_2.jpg "AIRA greeting in terminal")\n\nIn the end the greeting will appear in the DApp\n\n![Robonomics DApp Greeting for AIRA](../images/aira_hello_dapp_3.jpg "Robonomics DApp Greeting for AIRA")\n\n## Troubleshooting\n\n### You click "Request current values" but see no greeting\n\nProbably you have just launched AIRA and IPFS hasn\'t finished initialization. Wait a minute or so and try again.\n\n### I see response hash but the data doesn\'t appear\n\nAgain most probably the issue comes from IPFS connection. Click and the hash and you\'ll see the result. It\'s not necessary to download the file.\n\n## Home Task (optional)\n\nIf you are familiar with [Python](https://www.python.org/) change the shown text to something different and complete the lesson with your version of `hello_aira`\n\n- Make a fork of the [repository](https://github.com/vourhey/hello_aira)\n- The output text is located [here](https://github.com/Vourhey/hello_aira/blob/master/scripts/hello_aira#L45)\n'}},{node:{id:"e32ae24eb0b2fffd551ccccb2d03c640",title:"Passing dynamic parameters",path:"/docs/ja/hardware-passing-dynamic-parameters/",content:'\nIn [previous](/docs/connect-simple-cps/) example we discussed how to create a simple CPS with Arduino. Our first CPS is able to do only one task: to blink a led. We suggest you to get through the first lesson. Now let\'s expand the example and teach our board to blink blue or red led depending on objective parameter.\n\n> The source code of this lesson is [here](https://github.com/airalab/robonomics_tutorials/tree/master/arduino_with_args).\n\n\n## Arduino\n\nThe only difference in Arduino source code is instead of subscribing to one topic now we subscribe to `/blink_red` and `/blink_blue` topics\n\n```c\n  #include <ros.h>\n  #include <std_msgs/Empty.h>\n\n  ros::NodeHandle nh;\n\n  void blink(int led, int mil) {\n\n    digitalWrite(led, HIGH);\n    delay(mil);\n    digitalWrite(led, LOW);\n    delay(mil);\n\n  }\n\n  void blinkRedCb(const std_msgs::Empty& msg) {\n    blink(13, 500);\n    blink(13, 500);\n    blink(13, 500);\n  }\n\n  void blinkBlueCb(const std_msgs::Empty& msg) {\n    blink(12, 500);\n    blink(12, 500);\n    blink(12, 500);\n  }\n\n  ros::Subscriber<std_msgs::Empty> subRed("blink_red", &blinkRedCb);\n  ros::Subscriber<std_msgs::Empty> subBlue("blink_blue", &blinkBlueCb);\n\n  void setup()\n  {\n    pinMode(13, OUTPUT);\n    pinMode(12, OUTPUT);\n\n    nh.initNode();\n    nh.subscribe(subRed);\n    nh.subscribe(subBlue);\n  }\n\n  void loop()\n  {\n    nh.spinOnce();\n    delay(1);\n  }\n```\n\n\x3c!-- Here is the diagram of all connections:\n\n.. image:: ../img/6.png\n  :alt: Arduino schema\n  :align: center --\x3e\n\n\n## ROS\n\nWe can pass arguments via objective which points to rosbag file. Have a look at `blink.py` script. The main difference is `blink()` method:\n\n```python\ndef blink(self, data):\n  if data.data == "blue":\n      rospy.loginfo("Blinking blue...")\n      self.blink_blue.publish(Empty())\n\n  if data.data == "red":\n      rospy.loginfo("Blinking red...")\n      self.blink_red.publish(Empty())\n\n  rospy.wait_for_service(\'/liability/finish\')\n  fin = rospy.ServiceProxy(\'/liability/finish\', FinishLiability)\n  fin(FinishLiabilityRequest(address=self.liability, success=True))\n  rospy.loginfo("Finished")\n```\n\nNow `/blink` topic has a `String` type. You can find prepared rosbags in `rosbag` folder.\n\n## AIRA\n\nConnect to AIRA client via SSH as described [here](/docs/aira-connecting-via-ssh/). Do not forget to add `COM1` port in settings. Run the following command:\n\n```\n$ rosrun arduino_with_args blink.py\n```\n\nAlso we need to add rosbag files to IPFS:\n\n```\n$ ipfs add rosbag/blink_blue.bag\n$ ipfs add rosbag/blink_red.bag\n```\n\n**Before the next step you should approve XRT tokens on the Factory.**\n\nThe last step is to build Dapp and launch. Take a look at the previous [lesson](/docs/connect-simple-cps/). To make Arduino blink the blue led send blue demand and blue offer messages. For the red one send corresponding messages.\n\nThat\'s it! Now you are able to pass dynamic parameters to your cyber-physical system agent!'}},{node:{id:"9f28c46934d908f9f908c9a8ebf514ae",title:"Connect an Air Pollution Sensor",path:"/docs/ja/hardware-connect-sensor/",content:"\nIn this lesson you are going to learn how to connect your sensor to the network and make it publish data. You will see how it is easy to become a member of a global sensor network!\n\nSource code is located [here](https://github.com/airalab/robonomics_tutorials/tree/master/sensor_city).\n\nIn this section we are not going to create a liability contract. Instead we will teach Arduino with sensors to publish the data by a request. All measurements will be published as a Result message.\n\n## Arduino\n\nLet's begin with an Arduino circuit. You need the following components:\n\n* Arduino Uno\n* Optical Dust Sensor Sharp GP2Y1010AU0F\n* Gas Sensor MQ-2\n* Gas Sensor MQ-7\n* Resistor 150 Ohm\n* Capacitor 220 uF\n* Wires\n\nConnect all parts as described below:\n\n\x3c!-- .. image:: ../img/7.png\n  :alt: Arduino schema\n  :align: center --\x3e\n\nA firmware for Arduino Uno is in `sensor_city/scetches` folder. In order to upload it to the board use [Arduino IDE](https://www.arduino.cc/en/Main/Software).\n\n\x3c!-- .. image:: ../img/8.png\n   :alt: Arduino IDE\n   :align: center\n --\x3e\n\n## Aira\n\nThe following steps are performed in Aira client. You can download the latest image from [this page](https://github.com/airalab/aira/releases). It's convenient to [connect via SSH](/docs/aira-connecting-via-ssh/).\n\nAfter you have imported the image to VirtualBox, connect Arduino via USB to your PC and enable serial port forwarding. You should check `Enable Serial Port` and assign `/dev/ttyACM0` in `Path/Address`. Inside the virtual machine `/dev/ttyS0` refers to your external Arduino.\n\n\x3c!-- .. image:: ../img/9.png\n   :alt: Set a port\n   :align: center --\x3e\n\nFinally launch the image and run these command:\n\n```\n$ roslaunch sensor_city publish_data.launch\n```\n\n**Check out the source code to learn how it works under the hood!**\n\nNow Aira patiently waits for a signal to publish the measurements. Go to [Dapp](https://dev.aira.life/smart-city/#/) and click on `Broadcast signal`. You should see the data!"}},{node:{id:"404ef1fb2f377cba6e130f5166857ac9",title:"Glossary",path:"/docs/ja/glossary/",content:'\n## Agent\n\nIn terms of Robonomics Network agent is a program module that uses IPFS or blockchain or both interfaces of the network and does some actual work.\nUsually it\'s represented as a ROS package and it may connect (but not necessarily) a real cyber-physical system to the Robonomics Network.\n\n## Cyber-physical system\n\nIt is a combination of a physical mechanism that is usually called a robot and a program algorithm that controls the behavior of the mechanism.\n\n## Dapp\n\nIt is a short form for Decentralized application. Usually it is a single page web based application that helps to interact with an agent.\n\n## IPFS\n\nAccording to the official [documentation](https://docs.ipfs.io/introduction/) "IPFS is a distributed system for storing and accessing files, websites, applications, and data".\nFor more detail how it works go to the official website.\n\n## Lighthouse\n\nA lighthouse is an autonomous workflow that allows us to distribute the running time of providers that serve a single broadcast channel.\n\nFor more information read [Robonomics Whitepaper](https://static.robonomics.network/docs/whitepaper/Robonomics-whitepaper-en.pdf) section 5.2.\n\n## Sidechain\n\nEthereum based blockchain network with Proof-of-Authority consensus owned by Airalab.\n\n'}},{node:{id:"f1d7cb71b6c1ee74303497aaf643b7a1",title:"Getting Started",path:"/docs/ja/",content:'\n## What is Robonomics\n\nRobonomics platform provides tools for working with the robot economy network. Robonomics allow designers of smart cities and industry 4.0 zones to build trust among the [autonomous robots services](/docs/glossary#cyber-physical-system), provide [direct user access via dapp](/docs/glossary#dapp) for ordering products from autonomous factories and services of urban sensor networks. This in turn will allow us to put in place a decentralized system that globally monitors the activities of cyber physical systems.\n\nFind more in [Robonomics whitepaper](https://github.com/airalab/robonomics_specs/blob/master/pdf/whitepaper_en.pdf)\n\nThe following chart describes what place Robonomics takes in the scenario:\n\n![Robonomics Chart](../images/robonomics_network_basic_scheme.jpg "Robonomics Network scenario")\n\n## What the documentation contains\n\n### Robonomics Network quick start\nStart with quick example of what Robonomics is able to do within 5 minutes: [DEMO "Get Weather on Fuji Mountain"](/docs/get-weather-on-fuji-mountain).\n\n### I\'m interested in using Robonomics services\n\nTake a look at the [Robonomics Dapp](https://dapp.robonomics.network/#/). Get familiar with the statistic, average miner reward etc.\nTry out existing [services](https://dapp.robonomics.network/#/services)\n\n### I\'m a Dapp developer\n\n- [Robonomics-js on GitHub](https://github.com/airalab/robonomics-js) - simple Javascript SDK for Robonomics Network dApp developers.\n- [dApp template](https://github.com/airalab/vue-dapp-robonomics-template) - uses Vue.js\n- [Wiki documentation](/docs/robonomics-js/)\n\n### I\'m a robotics engineer\n\nCheck out [cases](/docs/iot-sensors-connectivity/) section and start developing by [examples](/docs/agent-development-examples).\n\n'}},{node:{id:"4e4cd65ee6e34ac528b427f7a4d26748",title:'DEMO "Get Weather on Fuji Mountain"',path:"/docs/ja/get-weather-on-fuji-mountain/",content:'\n**Let\'s start from a quick example of what Robonomics is able to do within 5 minutes. Requirements: [Metamask extension](https://metamask.io/)**\n\nTo get the weather from sensor on Fuji Mountain, please, open the page of [Fuji Weather sensor](https://dapp.robonomics.network/#/sensors/airalab/QmbQT8cj9TJKfYVaidfShnrEX1g14yTC9bdG1XbcRX73wY/0x4D8a26e1f055c0b28D71cf1deA05f0f595a6975d/) in Robonomics dApp and follow instructions below.\n\nHere\'s a walkthrough video:\n\nhttps://www.youtube.com/embed/t098NlMELk4\n\n## 1. Open the Dapp\n\nIn case you don\'t have MetaMask extension you\'ll see the picture below. Go to the link provided above and install one.\n\n!["Robonomics dApp if no MetaMask installed"](../images/sensor-demo/sensor-demo-1.png "Robonomics dApp if no MetaMask installed")\n\n## 2. Allow connection to the extension\n!["Connection to Robonomics dApp via Metamask"](../images/sensor-demo/sensor-demo-2.png "Connection to Robonomics dApp via Metamask")\n\n## 3. Press "Request current values"\n!["Request sensor\'s data in Robonomics network via dApp"](../images/sensor-demo/sensor-demo-3.png "Request sensor\'s data in Robonomics network via dApp")\n\n## 4. Sign a message. No token or ether are needed\n!["Sign a message in Robonomics network via dApp"](../images/sensor-demo/sensor-demo-4.png "Sign a message in Robonomics network via dApp")\n\n## 5. Wait until the agent collects the data and sends it back\n!["Wait for response of the agent in Robonomics network via dApp"](../images/sensor-demo/sensor-demo-5.png "Wait for response of the agent in Robonomics network via dApp")\n\n## 6. Wait until the Dapp downloads the result file from IPFS\n!["Wait for IPFS file with results in Robonomics network via dApp"](../images/sensor-demo/sensor-demo-6.png "Wait for IPFS file with results in Robonomics network via dApp")\n\n## 7. Look at the weather data on Fuji Mountain\n!["The results of sensor network in Robonomics via dApp"](../images/sensor-demo/sensor-demo-7.png "The results of sensor network in Robonomics via dApp")\n\nJust now you have broadcasted a demand message and got a result from an autonomous agent! The result file is stored in IPFS, the result message is signed with the agent\'s private key.\n'}},{node:{id:"2126bcb8c846b9c692ce7479f7bd445e",title:"Gaka-Chu setup and software Installation",path:"/docs/ja/gaka-chu/",content:"\nhttps://www.youtube.com/watch?v=GxlYxaykqTU\n\n**In this article we will go through some installation and launching steps to set up a robot-painter. Requirements:**\n- KUKA KR6 R900 sixx with KRC4 and a SmartPad;\n- Intel NUC with [ROS melodic](http://wiki.ros.org/melodic/Installation/Ubuntu) installed;\n- Table, paint, brush, water.\n\n## Software installation on KRC4\nEKI interface is required on both, KRC4 and NUC. Detailed information on how to set it up on KRC4 is presented [here](https://github.com/AlexeiOvcharov/kuka_experimental/tree/a915bf4e932990379c84164713e7ae11a24a2a13/kuka_eki_hw_interface/krl). Launch it on robot's controller.\n\n## Software installation on NUC\nCreate a catkin workspace:\n```\nmkdir -p ~/catkin_ws/src\ncd ~/catkin_ws/\ncatkin build\n```\nDownload ROS packages. All the scripts are stored [here](https://github.com/airalab/robot_painter/tree/test_branch). Clone the repository:\n```\ncd src\ngit clone --branch test_branch https://github.com/airalab/robot_painter\ncd robot_painter\nrm -rf scenes\nmv * ../\ncd ..\nrmdir robot_painter\n```\nYou may need some header files and libraries to make it all work correctly. Download them:\n```\ncd ~\ngit clone https://github.com/PaTara43/kuka_moveit_webots\ncd kuka_moveit_webots\nsudo mv -r headers/* usr/include/c++/7/\nsudo mv libs/* usr/local/lib/\ncd ~\nsvn checkout https://github.com/PX4/Matrix/trunk/matrix\nmv matrix -r /usr/include/c++/7/\nsudo apt-get install ros-melodic-brics-actuator\ncd ~/catkin_ws\ncatkin build\n```\nAdd source command to `.bashrc` file:\n```\necho “source ~/catkin_ws/devel/setup.bash” >> ~/.bashrc\nsource ~/.bashrc\n```\nUp to now. you should be able to launch the scripts. If something goes wrong, try some [troubleshooting](https://github.com/airalab/robot_painter/issues)\n\n## Filling in constants\nFirst of all, the robot needs to know canvas location and orientation as well as the paint tin position. All of this is specified in `fake_painter_enviroment_tf/src/tf_broadcaster.cpp`. Let's take a look into it.\n```\n// Plane constants\nconst double A = -0.0641;\nconst double B = 0.0214;\nconst double C = 0.9977;\nconst double D = -0.2198;\n\n// Canvas transform\nconst double px = 0.52;\nconst double py = -0.24;\nconst double qx = -0.011;\nconst double qy = -0.032;\nconst double qz = 0.0;\nconst double qw = 0.999;\n```\nThese are the plane equation constants which specify canvas position in 3-D space. They are to be obtained during a calibration process described below. Next goes the paint.\n```\ncolorTransform.transform.translation.x = 0.5;\ncolorTransform.transform.translation.y = 0.2;\ncolorTransform.transform.translation.z = 0.258;\n```\nThese are paint tin coordinates. They also may be specified while calibrating. Canvas size is specified in\n```\ncanvas.width = 0.5;\ncanvas.height = 0.4;\n```\nSeveral more important constants are stored in `local_task_planner/src/Drawing.cpp`:\n```\nconst double COLOR_BOTLE_HEIGHT = 0.06;\nconst double COLOR_HEIGHT = 0.045;\nconst double HEIGHT_OFFSET = COLOR_BOTLE_HEIGHT - COLOR_HEIGHT + 0.02;\nconst double BRUSH_HEIGHT = 0.01;\nconst double BRUSH_WIDTH = 0.01;\n```\nTheir names say it all, so fill them in according to the situation.\n\n## Calibrating Gaka-Chu\nThe calibration process itself is pretty simple.\n\n1) Start EKI interface on the KRC4:\n\nLog in in 'AUT' mode, turn on drivers and launch the script `eki_hw_interface`\n\n2) Start EKI interface on the NUC\n```\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\n```\nIt should output endless logs.\n\n3) Start RViz\n```\nroslaunch kuka_moveit_config demo.launch\n```\nYou should see the following:\n\n![KUKA in RViz](../images/kuka-real/kuka_rviz.png \"KUKA in RViz\")\n\nTry moving the end effector and clicking 'Plan and Execute'. The robot should move. On SmartPad go to **Display -> Actual position** and observe end effector's coordinate. Place a canvas horizontally to the robot base. Plug a brush into the brush holder and carefully move it till it barely touches the canvas. At this position, save end effector's coordinates. Repeat 12-15 times. Also, save the coordinates of the canvas center and paint tin.\nWhen you have a set of coordinates, use [these](https://github.com/nakata5321/Matlab_scripts_gaka-chu) Matlab scripts to resolve the missing constants and quaternion. Paste them. Rebuild your workspace with\n```\ncd ~/catkin_workspace\nrm -rf build logs devel\ncatkin build\n```\n\n## Testing Gaka-Chu calibration\nWhen calibrated, Gaka-Chu needs to be tested by drawing the borders of canvas. To make him do so execute each in new terminal:\n```\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\nroslaunch kuka_moveit_config demo.launch\nrosrun fake_painter_enviroment_tf tf_broadcaster\nrosrun local_task_planner draw_workspace\n```\nAfter this, you should see a canvas contour in RViz:\n\n![KUKA in RViz canvas](../images/kuka-real/kuka_rviz_canvas.png \"KUKA in RViz canvas\")\n\nIn terminal press \"S\" to perform testing. Robot's end effector should move right above the borders of the canvas and the brush should gently touch the canvas during the entire movement. If not so, try recalibrating. If the canvas model is rotated wrong, you can rotate it by changing quaternion in Matlab.\n\n## Making art\nYou need 6 basic modules to make it all work:\n- EKI interface;\n- MOVEit + RViz;\n- Environment frames broadcasting;\n- Picture converter service;\n- Trajectories drawing module;\n- Starting trigger.\n\nLet's launch them one by one.\n\n### Eki interface\nOn KRC4 launch `eki_hw_interface`, on NUC in a new terminal do:\n```\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\n```\n\n### RViz and MOVEit\nYou need a planner and a simulation. Launch them with\n```\nroslaunch kuka_moveit_config demo.launch\n```\n\n### Environment\nTell the robot where the paint tin and the canvas are. Note that it is not necessary to launch `draw workspace` node, the `tf_broadcaster` shares the canvas size. It just doesn't show it in RViz.\n```\nrosrun fake_painter_enviroment_tf tf_broadcaster\n```\n\n### Pictures processor\nAll incoming pictures need to be processed. Launch the service.\n```\nrosrun picture_preprocessing TextConverter.py\n```\nWhen it receives the call, it processes a picture with a HP filter and creates a rosbag file with trajectories.\n\n### Trajectories drawer\nThe mainest script here is the trajectories drawer itself. It waits for the picture, calls TextConverter service and draws the painting.\n```\nrosrun local_task_planner trajectory_drawing\n```\n\n## Send the robot a picture to draw\nThe robot listens to a specific ROS-topic where you need to pass the path to a desired picture. The picture should be square (width equals height) and made of lines. Send the path:\n```\nrostopic pub /run std_msgs/String \"data: '<path_to_picture>'\"\n```\nAfter that. Two windows pop up showing the contours and the tracks. Close them and see Gaka-Chu drawing. Watch out for safety and alwasy be ready to press emergency stop button.\nWhen Gaka-Chu finishes his art, you can send another path to picture and painter repeats the whole process.\n"}},{node:{id:"a87f4a8d1e39f9d0b66d7eb057ab56b0",title:"Connect an Amazon FreeRTOS Device to Robonomics by MQTT",path:"/docs/ja/freertos-mqtt/",content:"\nHere's the demonstration of how a microcontroller running [Amazon Web Services FreeRTOS](https://aws.amazon.com/freertos/) may be connected to Robonomics Network via MQTT. Please check [this repository](http://github.com/khssnv/freertos_mqtt_robonomics_example) for the project source code.\n\nWe use [ESP32 DevKitC](https://devices.amazonaws.com/detail/a3G0L00000AANtjUAH/ESP32-WROOM-32-DevKitC/) with FreeRTOS distribution and MQTT implementation provided by [Espressif IoT Development Framework](https://github.com/espressif/esp-idf) while Espressif is a vendor of the microcontroller used.\n\nAlso there is a [PMS-3003](http://www.plantower.com/en/content/?107.html) sensor for demonstration purposes. Sensor measures presence of particulated matter in the air and one may use it to estimate air quality.\n\nAir quality is not a topic of the article, you may find more about it at WHO's website: [Ambient (outdoor) air pollution](https://www.who.int/news-room/fact-sheets/detail/ambient-(outdoor)-air-quality-and-health). A goal of the system is to publish sensor measurements to Airalab's Robonomics network.\n\n## Hardware setup\n\nWe connect PMS3003 TXD PIN5 to ESP32 DevKitC IO17 to transfer measurements by UART.\nAlso both devices require power and common ground.\n\n![Wiring Diagram](../images/freertos-mqtt/wiring.png)\n\n## Data Flow\n\nIn order to deliver sensor measurements to Robonomics network, on a firmware level our goal is to get data from a sensor by embedded communication protocol it supports (UART in our case) and pass it to AIRA instance by MQTT / TCP.\n\n![Sending](../images/freertos-mqtt/send.svg)\n\nIn our example we use AIRA cloud deployment available by public IP address and domain name assigned.\nOn AIRA instance we setup `mosquitto` MQTT broker and subscribe to `/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4` topic to get messages from MQTT.\n\nThen we pass messages to `robonomics io` writer by pipe.\n\n![Receiving](../images/freertos-mqtt/recv.svg)\n\nNow data available in Robonomics Network and we can be read it with `robonomics io` again.\n\n## Firmware\n\nWe use [ESP-MQTT sample application with TCP transport](https://github.com/espressif/esp-idf/tree/master/examples/protocols/mqtt/tcp) as a basis.\n\nWe only modify `main/app_main.c` for UART connection to the sensor, SNTP time synchronization and periodic MQTT publisher routine.\n\nIf you are trying to repeat the project, and it's your first ESP IDF based project, at first please follow [Espressif's ESP-IDF Programming guide](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/index.html#installation-step-by-step) introduction in order to familiarize with firmware operations like configuration, build and upload with `idf.py` tool.\n\n### Wi-Fi Configuration\n\nIn order to communicate with AIRA instance deployed in cloud, our microcontroller requires Internet connection.\nWe use ESP32's Wi-Fi for it.\nEspressif provides utilities to configure on-board Wi-Fi.\nIn our example we use development environment with Ubuntu 20.04 GNU/Linux.\nTo configure Wi-Fi we go to project folder and run SDK configuration tool.\n\n```console\ncd freertos_mqtt_robonomics_example/firmware\nidf.py menuconfig\n```\n\nThen we set Wi-Fi access point SSID and password in `Example Connection Configuration` section.\n\n![Menuconfig Wi-Fi](../images/freertos-mqtt/menuconfig-wi-fi.png)\n\n### MQTT Endpoint Configuration\n\nThere are two things to configure for MQTT.\nThe first is a MQTT broker address.\nIt is configurable with SDK configuration tool.\n\n```console\ncd freertos_mqtt_robonomics_example/firmware\nidf.py menuconfig\n```\n\nSet `Broker URL` in `Example Configuration` section.\n\n![Menuconfig MQTT](../images/freertos-mqtt/menuconfig-mqtt.png)\n\nThe second thing is a MQTT topic.\nWe set it in the firmware with the project name prefix followed with our ESP32 MAC address.\nIt gives us `/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4` for our particular microchip.\n\n## From MQTT to Robonomics\n\nAt first let's check we receive data by MQTT.\nWe can subscribe to our Mosquitto MQTT broker topic device publish to.\n\n```console\n$ nix-shell -p mosquitto --run \"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\"\nts=1615651809, PM1=2, PM2.5=6, PM10=3\n```\n\nHere we bring `mosquitto` package into our environment to use `mosquitto_sub` utility.\nThen we subscribe to the topic set in the firmware.\nWe got our measurements that means AIRA receives data by MQTT correctly.\nNow let's pipe these messages to Robonomics Network.\n\n```console\nnix-shell -p mosquitto --run \"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\" | robonomics io write pubsub --bootnodes=/ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\n```\n\nHere we use `robonomics` utility to publish messages in pubsub channel `/freertos_mqtt_robonomics_example`.\nWe specify `bootnodes` to ensure at least one connection established.\n\nNow we are read these messages from the same pubsub channel.\n\n```console\n$ robonomics io read pubsub --listen /ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\n2021-03-27 15:15:51  Generated random peer id: 12D3KooWB2nym5E6c3aPpnPKK5wB9Z6n9eZzcXSpyUBozxhi6dam\n2021-03-27 15:15:51  Subscribed to topic: _robonomics_pubsub_peer_discovery\n2021-03-27 15:15:51  Subscribed to topic: /freertos_mqtt_robonomics_example\n2021-03-27 15:15:56  New peer connected: PeerId(\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\")\n2021-03-27 15:15:56  GRAFT: Mesh link added for peer: PeerId(\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\") in topic: TopicHash { hash: \"_robonomics_pubsub_peer_discovery\" }\nts=1616843855, PM1=3, PM2.5=4, PM10=3\n```\n\n## Original Resources Used\n\n* ESP32 DevKitC pinout from GoJimmy's blog https://gojimmypi.blogspot.com/2017/03/jtag-debugging-for-esp32.html\n* PSM3003 data structure and decoder from OpenAirProject https://github.com/openairproject/sensor-esp32\n\n**Thank you all!**\n"}},{node:{id:"dd90352e834440095da2589eeb5af9eb",title:"Ethereum Common",path:"/docs/ja/ethereum-common/",content:'\nThe packages contains two launch files: `erc20.launch` and `signer.launch`. The last one is included in [Robonomics Liability](/docs/robonomics-liability).\n\nBelow is the description for `erc20` node which contains utils for convenient work with Ethereum accounts and XRT token.\n\n## ROS Parameters\n\n###  ~web3_http_provider\n\nWeb3 HTTP provider address. The type is `string`, defaults to `http://127.0.0.1:8545`\n\n### ~erc20_token\n\nERC20 token to work with. Type is `string`, defaults to `xrt.5.robonomics.eth`\n\n### ~factory_contract\n\nThe name of the liability factory. The type is `string`, defaults to `factory.5.robonomics.eth`\n\n### ~ens_contract\n\nThe checksumed address of ENS registry. The type is `string`, defaults to `""`\n\n### ~keyfile\n\nPath to keyfile. The type is `string`, defaults to `""`. **Required parameter**\n\n### ~keyfile_password_file\n\nPath to a file with password for the keyfile. The type is `string`, defaults to `""`. **Required parameter**\n\n## Published topics\n\n### /eth/event/transfer (ethereum_common/TransferEvent)\n\nThe event [ethereum_common/TransferEvent](/docs/ethereum-common-messages#ethereum_commontransfereventmsg) is emitted after the transfer of tokens was made\n\n### /eth/event/approval (ethereum_common/ApprovalEvent)\n\nThe event [ethereum_common/ApprovalEvent](/docs/ethereum-common-messages#ethereum_commonapprovaleventmsg) is emitted after the approval of tokens was made\n\n## Services\n\n### /eth/accounts (ethereum_common/Accounts)\n\nList of available Ethereum accounts. See [ethereum_common/Accounts](/docs/ethereum-common-messages#ethereum_commonaccountssrv)\n\n### /eth/account_eth_balance (ethereum_common/AccountBalance)\n\nReturns the balance of the given address in Wei. See [ethereum_common/AccountBalance](/docs/ethereum-common-messages#ethereum_commonaccountbalancesrv)\n\n### /eth/eth_balance (ethereum_common/Balance)\n\nReturns the balance of the default address. See :ref:`Ethereum-common-Balance.srv`\n\n### /eth/current_block (ethereum_common/BlockNumber)\n\nReturns current block number. See :ref:`Ethereum-common-BlockNumber.srv`\n\n### /eth/transfer (ethereum_common/Transfer)\n\nTransfers tokens from the default account to a given one. See :ref:`Ethereum-common-Transfer.srv`\n\n### /eth/transfer_from (ethereum_common/TransferFrom)\n\nTransfers tokens from a given account to another one. See :ref:`Ethereum-common-TransferFrom.srv`\n\n### /eth/approve (ethereum_common/Approve)\n\nApproves tokens from the default account to a given one. See :ref:`Ethereum-common-Approve.srv`\n\n### /eth/account_xrt_balance (ethereum_common/AccountBalance)\n\nReturns the XRT balance of a given account. See :ref:`Ethereum-common-AccountBalance.srv`\n\n### /eth/xrt_balance (ethereum_common/Balance)\n\nReturn the XRT balance of the default account. See :ref:`Ethereum-common-Balance.srv`\n\n### /eth/account_xrt_allowance (ethereum_common/AccountToAddressAllowance)\n\nReturns how much one account is allowed to spend from another account. See :ref:`Ethereum-common-AccountToAddressAllowance.srv`\n\n### /eth/xrt_allowance (ethereum_common/Allowance)\n\nReturns how much the Factory is allowed to spend from the default account. See :ref:`Ethereum-common-Allowance.srv`'}},{node:{id:"26ae19a4adc3634a3ffcc2cec1562ad8",title:"Ethereum Common Messages",path:"/docs/ja/ethereum-common-messages/",content:"\n## ethereum_common/Address.msg\n\n| Field   \t| Type            \t| Description                    \t|\n|---------\t|-----------------\t|--------------------------------\t|\n| address \t| std_msgs/String \t| Address in Ethereum blockchain \t|\n\n## ethereum_common/UInt256.msg\n\n| Field   \t| Type            \t| Description                \t|\n|---------\t|-----------------\t|----------------------------\t|\n| uint256 \t| std_msgs/String \t| A wrapper for big integers \t|\n\n## ethereum_common/TransferEvent.msg\n\n| Field      \t| Type                                                  \t| Description      \t|\n|------------\t|-------------------------------------------------------\t|------------------\t|\n| args_from  \t| [ethereum_common/Address](#ethereum_commonaddressmsg) \t| Sender address   \t|\n| args_to    \t| [ethereum_common/Address](#ethereum_commonaddressmsg) \t| Receiver address \t|\n| args_value \t| [ethereum_common/UInt256](#ethereum_commonuint256msg) \t| Amount of tokens \t|\n\n## ethereum_common/ApprovalEvent.msg\n\n| Field        \t| Type                                                  \t| Description      \t|\n|--------------\t|-------------------------------------------------------\t|------------------\t|\n| args_owner   \t| [ethereum_common/Address](#ethereum_commonaddressmsg) \t| Owner address    \t|\n| args_spender \t| [ethereum_common/Address](#ethereum_commonaddressmsg) \t| Spender address  \t|\n| args_value   \t| [ethereum_common/UInt256](#ethereum_commonuint256msg) \t| Amount of tokens \t|\n\n## ethereum_common/AccountBalance.srv\n\n**Request**\n\n| Field   \t| Type                                                  \t| Description      \t|\n|---------\t|-------------------------------------------------------\t|------------------\t|\n| account \t| [ethereum_common/Address](#ethereum_commonaddressmsg) \t| Ethereum address \t|\n\n**Response**\n\n| Field   \t| Type                                                  \t| Description    \t|\n|---------\t|-------------------------------------------------------\t|----------------\t|\n| balance \t| [ethereum_common/UInt256](#ethereum_commonuint256msg) \t| Balance in Wei \t|\n\n## ethereum_common/AccountToAddressAllowance.srv\n\n**Request**\n\n| Field   \t| Type                                                  \t| Description      \t|\n|---------\t|-------------------------------------------------------\t|------------------\t|\n| account \t| [ethereum_common/Address](#ethereum_commonaddressmsg) \t| Ethereum address \t|\n| to      \t| [ethereum_common/Address](#ethereum_commonaddressmsg) \t| Ethereum address \t|\n\n**Response**\n\n| Field  \t| Type                                                  \t| Description   \t|\n|--------\t|-------------------------------------------------------\t|---------------\t|\n| amount \t| [ethereum_common/UInt256](#ethereum_commonuint256msg) \t| Balance in Wn \t|\n\n## ethereum_common/Accounts.srv\n\n**Request**\n\nRequest is empty\n\n**Response**\n\n| Field     | Type                                                      | Description                   |\n|---------- |-------------------------------------------------------    |----------------------------   |\n| accounts  | [ethereum_common/Address[]](#ethereum_commonaddressmsg)     | List of available accounts    |\n\n## ethereum_common/Allowance.srv\n\n**Request**\n\nRequest is empty\n\n**Response**\n\n| Field     | Type                                                      | Description                                       |\n|--------   |-------------------------------------------------------    |-----------------------------------------------    |\n| amount    | [ethereum_common/UInt256](#ethereum_commonuint256msg)     | Amount of XRT the Factory is allowed to spend     |\n\n## ethereum_common/Approve.srv\n\n**Request**\n\n| Field     | Type                                                      | Description                   |\n|---------  |-------------------------------------------------------    |-----------------------------  |\n| spender   | [ethereum_common/Address](#ethereum_commonaddressmsg)     | Who is allowed to spend       |\n| value     | [ethereum_common/UInt256](#ethereum_commonuint256msg)     | How much tokens are allowed   |\n\n**Response**\n\n| Field     | Type                  | Description       |\n|--------   |--------------------   |------------------ |\n| txhash    | std_msgs/Uint8[32]    | Transaction hash  |\n\n## ethereum_common/Balance.srv\n\n**Request**\n\nRequest is empty\n\n**Response**\n\n| Field     | Type                                                      | Description                       |\n|---------  |-------------------------------------------------------    |--------------------------------   |\n| balance   | [ethereum_common/UInt256](#ethereum_commonuint256msg)     | The balance of default account    |\n\n## ethereum_common/BlockNumber.srv\n\n**Request**\n\nRequest is empty\n\n**Response**\n\n| Field     | Type              | Description           |\n|--------   |-----------------  |---------------------- |\n| number    | std_msgs/Uint64   | Current block number  |\n\n## ethereum_common/Transfer.srv\n\n**Request**\n\n| Field     | Type                                                      | Description           |\n|-------    |-------------------------------------------------------    |---------------------- |\n| to        | [ethereum_common/Address](#ethereum_commonaddressmsg)     | Ethereum address      |\n| value     | [ethereum_common/UInt256](#ethereum_commonuint256msg)     | The amount of tokens  |\n\n**Response**\n\n| Field     | Type                  | Description       |\n|--------   |--------------------   |------------------ |\n| txhash    | std_msgs/Uint8[32]    | Transaction hash  |\n\n## ethereum_common/TransferFrom.srv\n\n**Request**\n\n| Field     | Type                                                      | Description           |\n|-------    |-------------------------------------------------------    |---------------------- |\n| owner     | [ethereum_common/Address](#ethereum_commonaddressmsg)     | Owner's address       |\n| to        | [ethereum_common/Address](#ethereum_commonaddressmsg)     | Another account       |\n| value     | [ethereum_common/UInt256](#ethereum_commonuint256msg)     | The amount of tokens  |\n\n**Response**\n\n| Field     | Type                  | Description       |\n|--------   |--------------------   |------------------ |\n| txhash    | std_msgs/Uint8[32]    | Transaction hash  |\n"}},{node:{id:"98b1c2569cca28586e1c221a5e189f0b",title:"How to edit WIKI",path:"/docs/ja/edit-wiki/",content:'\n**Robonomics WIKI is open source. Any corrections are welcome: fixing errors, typos, some unclear or outdated information, translation into any language. You\'ll need a [GitHub](https://github.com/) account.**\n\n## Edit existing doc\n\n1. Choose page\n2. Click button "Edit page" marked with the Github logo on the page you want to edit\n3. Clicking on the button will take you to the .md file.\n4. Please, follow common rules for editing [Markdown files](https://en.wikipedia.org/wiki/Markdown), bearing in mind a few features of the WIKI stack:\n\n### Frontmatter\nDocs in Robonomics WIKI contain frontmatter block. It must be at the top of the Markdown file, and must take the form of valid YAML set between triple-dashed lines. Between the triple-dashed lines, you can set or edit folowing options:\n\n```YAML\n---\ntitle: How to contribute # Title for the page, you do not need to duplicate it in text\ncontributors: [positivecrash] # Main contributors (who actively curates this page). GitHub nickname required, without any additional symbols\ntranslated: true # "true" if it has been translated in current language (see locale folder name of doc)\n---\n```\n\n### Images\n1. Upload image in folder `/docs/images/url-of-your-doc`\n* If image needs to be localized, insert all of them in one folder\n* Use locale appendix in name of images if it\'s localized, e.g. `image_en.jpg`\n* Make sure your image is web optimised and at the same time it looks good\n2. Insert images standart way for Markdown files.\n\n### YouTube videos\nYou can embed any YouTube video in doc by inserting share link as separate paragraph without any additional quotes or tags, e.g.: `https://youtu.be/kQaSwNYHJQ8`\n\n### Asciinema\nRobonomics WIKI has support for Asciinema. To insert Asciinema, please, follow these instructions:\n* Import component after frontmatter block `import Asciinema from \'~/components/Asciinema.vue\'`\n* Insert as separate paragraph `<Asciinema vid="WCFcx8C6M8e52UKDNei1xZloU"/>`, where is vid is ID of specific asciicast\n\n> You can get the widget script for a specific asciicast by clicking on “Embed” link on asciicast page.\n> It looks like this:\n> `<script src="https://asciinema.org/a/14.js" id="asciicast-14" async><\/script>`\n[Asciinema docs](https://asciinema.org/docs/embedding)\n\nIn the example above vid is 14.\n\n## Add new doc\n\nIf you need to add new page in docs of Robonomics WIKI, please, follow these steps:\n\n1. Find the folder with the locale that matches the language of the article you are adding, e.g. `/docs/en/`\n2. Create .md file, using in name latin characters and follow common rules for [url structure](https://developers.google.com/search/docs/advanced/guidelines/url-structure)\n3. Edit file as described above\n4. Duplicate file to other locale folders, even if you do not plan to translate them. Do not forget mark in frontmatter not translated pages as `translated: false`\n5. Add doc in menu:\n* Open file `/data/sidebar_docs.yaml`\n* Decide where to place your doc\n* If you want to create new section, provide title with locale appendix, using only locales your section is translated\n* Add doc with link. The link must be only one, and must not contain locale characters. Correct is `/docs/url-of-your-doc`, not correct is `/docs/en/url-of-your-doc`\n* Use valid YAML for `/data/sidebar_docs.yaml` and rely on the existing file structure\n\n## Submit Pull Request\n\n[Make pull request](https://docs.github.com/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request) for any content you changed including typos, translations, outdated information or broken links.\n\nDecisions about individual PRs made by Robonomics core team. Special grants in [XRT](https://robonomics.network/community#token) are also possible for extended contribution 🤖💙💛💚💎🍭🎉🔌'}},{node:{id:"9c2332216d547fb7a5c86cf3fe221ae4",title:"Cross-chain Message",path:"/docs/ja/cross-chain-messages/",content:"\nXCM (Cross-chain Message) allows sending messages between parachains. You can send launchXcm transaction to run/stop your robot or datalogXcm transaction to save data to blockchain.\n\nhttps://www.youtube.com/watch?v=a6XrqoaYhK8&feature=emb_logo\n\n## Create Account\n\nLets try to send message from Earth to Mars.\nGo to [parachain.robonomics.network](https://parachain.robonomics.network/#/explorer) and choose `Airalab Rococo` testnet:\n\n![testnets](../images/cross-chain/testnet.jpg)\n\nIn `Network/Parachains` you will see two parachains with their id:\n\n![ids](../images/cross-chain/Parachains_id.jpg)\n\nThen go to Earth parachain and [create](https://wiki.robonomics.network/docs/create-account-in-dapp/) two accounts (for example `ROBOT` and `EMPLOYER`). In a new tab go to Mars parachain.\n\n## LaunchXcm\n\nIn Earth parachain go to `Developer/Extrinsics` and choose your `EMPLOYER` account and launchXcm. Then write Mars parachain id (2000) and choose the `ROBOT` account:\n\n![launch](../images/cross-chain/launch.jpg)\n\nNow press `Submit Transaction`.\n\nTo see your transaction in Mars parachain go to `Network/Explorer` and look at Recent Events.\n\n![recent_launch](../images/cross-chain/recent_launch.jpg)\n\n## DatalogXcm\n\nIn Earth parachain go to `Developer/Extrinsics` and choose your `ROBOT` account and datalogXcm. Write Mars parachain id (2000) and the message:\n\n![datalog](../images/cross-chain/datalog.jpg)\n\nNow press `Submit Transaction`.\n\nYou can see your transaction in Recent Events in Mars parachain:\n\n![recent_datalog](../images/cross-chain/recent_datalog.jpg)\n\n\n"}},{node:{id:"ecad3f4a1150c61fe472a4e455505c04",title:"Create digital identity run by Ethereum",path:"/docs/ja/create-digital-identity-run-by-ethereum/",content:'\nOne of the Robonomics services is [Digital Passport Registration](https://dapp.robonomics.network/#/passport/) for arbitrary data. The service allows you to create a digital identity saving the hashes of the data to the public blockchain and assigning a unique address.\n\nYou may find "Digital passport registration" service in [Robonomics DApp](https://dapp.robonomics.network/) in the "Services" section or just follow this [direct link](https://dapp.robonomics.network/#/passport/).\n\n\n## Video walkthrough\n\nThe following video shows a progress of Robonomics Whitepaper registration:\n\nhttps://www.youtube.com/embed/E8R6VbZvf9w\n\n## Step-by-step in pictures\n\n### 1. Open the service\n\n![Digital passport registration applying form](../images/case_digital_passport_1.jpg "Digital passport registration applying form")\n\n### 2. Add necessary information and files\n\nPlease note, it is possible to add multiple images.\n\n![Filled Form](../images/case_digital_passport_2.jpg "Filled Form")\n\n### 3. Sign the demand\n\n![Sign the demand for digital passport creation](../images/case_digital_passport_3.jpg "Sign the demand for digital passport creation")\n\n\n### 4. Approve tokens\n\nThe service charges a small fee. But first you must approve the required amount of tokens to be spent from your account.\n\n![Approve Tokens](../images/case_digital_passport_4.jpg "Approve Tokens")\n\n\n### 5. Accept the offer and sign the message again\n\n![Send Order](../images/case_digital_passport_5.jpg "Send Order")\n\n### 6. Have a look at the created passport\n\n![The Digital Identity](../images/case_digital_passport_6.jpg "The Digital Identity") \n\nThe process of registration takes some time. In the end you will see a link to the created identity.\n'}},{node:{id:"c1bcdea4ffa2219ae5c02a1962672477",title:"Create an Account on Robonomics Portal",path:"/docs/ja/create-account-in-dapp/",content:'\n**In order to be able to complete all the playground tutorials below, one should have several accounts on Robonomics portal. These accounts do not contain any personal data, neither they are anyhow valuable (if you play on a local dev network or on a self-owned test one). But still their keys, both public and private, are necessary for launching any demo.**\n\n## 1. Choose your network and navigate to Robonomics portal\nGlobally, there are 3 different ways to work with Robonomics:\n- Launch your own local network with [robonomics binary](https://github.com/airalab/robonomics/releases/) by `./robonomics --dev`. This method is used in all playground tutorials. (_tip: to avoid failures on next launches clean chain data by `rm -rf /home/$USER/.local/share/robonomics/chains/dev/db` after each session_)\n- Launch your own test network following [this](/docs/robonomics-test-network-manual/) manual\n- Connect to an existing network on a portal (more information on this below)\n\nRegardless of method chosen, go to [parachain.robonomics.network](https://parachain.robonomics.network) and draw your attention to the top-left corner:\n\n![Portal top-left](../images/creating-an-account/portal-top-left.jpg "Portal top-left")\n\nPress on the current network icon and choose you network:\n- **Development -> Local Node** if you have launched local network\n- **Custom Endpoint -> insert endpoint** if you have created a test network on a remote server\n- **Live Networks** or **Test Networks** if you are operating in a public one\nDon\'t forget to press `Switch` button to confirm network choice. In all the playgrounds we will use local networks.\n\n![Choosing local network](../images/creating-an-account/choosing-local-node.jpg "Choosing local network")\n\n## 2. Create accounts\nNow that you have chosen your network, go to **Accounts -> Accounts** and press `Add account` button\n\n![Accounts page](../images/creating-an-account/accounts-page.jpg "Accounts page")\n\nYou should see the following panel:\n\n![Add account panel](../images/creating-an-account/add-account-panel.jpg "Add account panel")\n\n- *Name* is just you account\'s name in this exact browser. It makes no sense but convenience.\n- *Seed*. Each transaction must be signed by account\'s unique seed. It has two forms: *Mnemonic* (human-readable) and *Raw* (a sequence of digits and letters). Change *Mnemonic* to *Raw* and copy the seed. **It\'s very important to store it somewhere securely** since secret seeds are used for transactions in [Robonomics IO](/docs/rio-overview/) module. If you have created an account before, you can insert its secret seed here to restore its balance and history.\n- *Password* is used to sign transactions on a portal (in GUI). Create one and remember it.\n\nClick `Save`, `Create and backup account`. A downloaded JSON-file is another way to restore account\'s data on the portal.\n\n## 3. Manage your accounts\nNow you can fully operate with your fresh-created account. Send and receive tokens, messages, write datalog and more. You can forget this account for this exact browser by clicking three dots in opposite of your account\'s name and choosing *Forget this account*. Feel free to explore all the features of portal. To copy your account\'s address simply click on its icon, address will be copied to clipboard.\n\n## 4. Some notes before proceeding to playground\nMost of the playground demos require "Control" account and one or several "Worker" accounts. Transfer units to both before starting, since "Control" needs to send "ON"/"OFF" transactions and "Worker" publishes datalog. Also, each "ON"/"OFF" transaction requires target address, so don\'t forget to copy it from the portal.\n'}},{node:{id:"a98a4b4c83ef0924a5d40a258ad6ac94",title:"How to contribute",path:"/docs/ja/contributing/",content:"\nRobonomics network is an open-source project built by core maintainers from Airalab and contributors. We want to make it easy for anyone to contribute. You may contribute to core, suggest changes, improve documentation or write a blog post. Please, read some rules and suggestions for contributing.\n\n## Main Airalab repositories \n\n- [aira](https://github.com/airalab/aira) - AIRA client for Robonomics network. \n- [robonomics_comm](https://github.com/airalab/robonomics_comm) - Robonomics communication stack\n- [robonomics_contracts](https://github.com/airalab/robonomics_contracts) - smart contracts of Robonomics network\n\n## Bugs and proposals for improvements\n\nIf you find a bug in AIRA client, Robonomics repositories, this documentation or would like to propose an improvement, please, open a new issue in the same repository, that you want to contribute.\n\n### Rules for reporting\n\nWhen opening a new issue, do not forget about a few basic rules for reporting:\n\n1. Choose exact repository, that you want to submit an issue.\n\n2. If you are reporting bug, make sure the bug was not already reported.\n\n3. Be sure to include title and clear description, as much relevant information as possible.\n\n4. Please prefix your issue with one of the following: `[BUG]`, `[PROPOSAL]`, `[QUESTION]`.\n\n\n## Pull requests\n\nAny Airalab repository or this documentation may be subject to pull requests or changes by contributors where you believe you have something valuable to add or change. Please, do not forget about basic rules for contributors.\n\n### Rules for contributing\n\n1. Pull requests are preferred to issues, if you have some fixes, especially for small changes such as typos.\n\n2. Make sure the PR description clearly describes the problem and the solution. Include the relevant issue number if applicable.\n\n3. Please, do not fix whitespace, format code, or make a purely cosmetic patch.\n\n4. Please, attempt to adhere to the prevailing Markdown style, language, and layout.\n\n\n"}},{node:{id:"bc0a302d7db419a1e8ef759221b97e4b",title:"Connect the simplest CPS",path:"/docs/ja/connect-simple-cps/",content:'\nIn this section we will build the simplest real cyber-physical system!\n\nWe will buy a "wink" from Arduino, e.g. make Arduino blink with its onboard led. The lesson is tested on Arduino Uno, but any other board with a led will do the job.\n\n> The source code of this lesson is [here](https://github.com/airalab/robonomics_tutorials/tree/master/arduino_blink).\n\n## Arduino\n\nThe firmware for the board is located in [arduino_blink/misc/arduino/arduino.ino](https://github.com/airalab/robonomics_tutorials/blob/master/arduino_blink/misc/arduino/arduino.ino). Use [Arduino IDE](https://www.arduino.cc/en/Main/Software) to load the code to your Arduino board.\n\nIn the code we subscribe for the ``/blink_led`` topic and set a callback. The type of the topic is ``Empty``, so the board waits until someone publishes to the topic and performs the LED blinking.\n\n```\n  #include <ros.h>\n  #include <std_msgs/Empty.h>\n\n  ros::NodeHandle  nh;\n\n  void blink(int led, int mil) {\n\n    digitalWrite(led, HIGH);\n    delay(mil);\n    digitalWrite(led, LOW);\n    delay(mil);\n\n  }\n\n  void messageCb( const std_msgs::Empty& toggle_msg){\n    blink(LED_BUILTIN, 500);\n    blink(LED_BUILTIN, 500);\n    blink(LED_BUILTIN, 500);\n  }\n\n  ros::Subscriber<std_msgs::Empty> sub("blink_led", &messageCb );\n\n  void setup()\n  {\n    pinMode(LED_BUILTIN, OUTPUT);\n    nh.initNode();\n    nh.subscribe(sub);\n  }\n\n  void loop()\n  {\n    nh.spinOnce();\n    delay(1);\n  }\n```\n\n\n## AIRA client\n\n> You can download the latest release from [here](https://github.com/airalab/aira/releases).\n\nSet up the COM port forwarding. You should forward your `/dev/ttyUSB0` or `/dev/ttyACM0` port (depending on the system) to `COM1`. In the client `/dev/ttyS0` will represent the board. After this launch the virtual machine.\n\n## ROS\n\nWhen new liability is created it goes to `/liability/ready` topic. We have to remember the address and call `/liability/start` service to get the data from objective.\n\n```\n  def newliability(l):\n    self.liability = l.address\n    rospy.loginfo("Got new liability {}".format(self.liability))\n\n    prefix = "/liability/eth_" + self.liability\n    rospy.Subscriber(prefix + \'/blink\', Empty, self.blink)\n\n    rospy.wait_for_service("/liability/start")\n    rospy.ServiceProxy(\'/liability/start\', StartLiability)(StartLiabilityRequest(address=self.liability))\n  rospy.Subscriber("/liability/ready", Liability, newliability)\n```\n\nA message in the `/blink` topic come from the objective field. Have a look at [Basic usage](/docs/aira-basic-usage) page.\n\n## AIRA\n\nConnect to AIRA client via SSH as described [here](/docs/aira-connecting-via-ssh). All tutorials are pre-installed. To launch the ros package run the following command:\n\n```\n$ rosrun arduino_blink blink.py\n```\n\nAlso we need to add a rosbag file to IPFS::\n\n```\n$ ipfs add rosbag/blink.bag\n```\n\n> Before the next step you should approve XRT tokens on the Factory.\n\nOn your host system build and launch an Dapp for the lesson:\n\n```\n$ git clone https://github.com/airalab/robonomics_tutorials/\n$ cd robonomics_tutorials/arduino_blink_dapp\n$ npm i && npm run dev\n```\n\nOpen [http://localhost:8000/](http://localhost:8000/) and press "Demand" then "Offer" buttons. Wait until a new liability is created and you should see the board blinking. Congratulations on the first agent!\n'}},{node:{id:"36508ccdf68d4864b6d43be36878f329",title:"Connect Sensor To Robonomics Network",path:"/docs/ja/connect-sensor-to-robonomics/",content:'\n## Requiremets\n* ESP8266 Node MCU v3\n* particle sensor SDS011\n* micro USB cable\n* connecting wires\n\n## Assembling\n### Connection Diagram\n\n![scheme](../images/sensors-connectivity/schema.jpg)\n\n### Connecting SDS011\n\n* Pin 1 (TX) -> (RX) Pin D1 (GPIO5)\n* Pin 2 (RX) -> (TX) Pin D2 (GPIO4)\n* Pin 3 (GND) -> GND\n* Pin 4 (2.5m) -> unused\n* Pin 5 (5V) -> VU\n* Pin 6 (1m) -> unused\n\nSensor is shipped with a USB adapter and connection wires. You don\'t need USB adapter, so disconnect wires from it.\n\n![disconnect](../images/sensors-connectivity/2_assembly_usb.jpg)\n\nYou may connect it to ESP via connecting wires "Female-Male":\n\n![f-m](../images/sensors-connectivity/3_conn.jpg)\n\nAnd connect them to your ESP according to the connection diagram.\n\nOr you can use wires from USB adapter. Disconnect one wire: push on it with some sharp object and carefully pull the wire:\n\n![extreme_con](../images/sensors-connectivity/4_assembly_wires.jpg)\n\nInsert it to last connector:\n\n![extr](../images/sensors-connectivity/5_wires1.jpg)\n\nThen cut the connector in the middle:\n\n![cut](../images/sensors-connectivity/6_assembly_wires2.jpg)\n\nAnd connect them to ESP according to the diagram:\n\n![esp_con](../images/sensors-connectivity/6_esp_con.jpg)\n\n### Connecting DHT22\n\n\n* Pin 1 => 3V3\n* Pin 2 => Pin D7 (GPIO13)\n* Pin 3 => unused\n* Pin 4 => GND\n\n### Connecting BME280/HTU21D\n\n* VCC -> Pin 3V3\n* GND -> Pin GND\n* SCL -> Pin D4 (GPIO2)\n* SDA -> Pin D3 (GPIO0)\n\n\n## Device Firmware\nDownload `airrohr-flasher` from the [latest release](https://github.com/airalab/sensors-connectivity/releases) for your OS. \nConnect ESP to computer via micro-USB and run flasher. \n\n### For Linux:\nFirstly you need to add the user to `dialout` group:\n```bash\nsudo usermod -a -G dialout $USER\n```\nThen logout and login or restart computer.\n\nNow you can run flasher (don\'t forget to give it permission to execute):\n```bash\nchmod +x airrohr-flasher-linux\n./airrohr-flasher-linux\n```\n\n### For Windows:\nUnpack flasher and run it with double click.\nYou need to install drivers for the USB2serial chipset (Windows 10 should be able to automatically download these):\n\n* Drivers for NodeMCU v3 (CH340): [Windows](http://www.wch.cn/downloads/file/5.html) ([2018/09/04 v3.4 mirror](https://d.inf.re/luftdaten/CH341SER.ZIP))\n\n\n### For MacOS\nDownload flasher and run it.\nYou need to install drivers for the USB2serial chipset: \n* Drivers for NodeMCU v3 (CH340): [MacOS](http://www.wch.cn/downloads/file/178.html) ([2018/09/04 v1.4 mirror](https://d.inf.re/luftdaten/CH341SER_MAC.ZIP))\n\n\nChoose firmware (English or Russian) and press upload. It will take a few minutes.\n\n![flasher](../images/sensors-connectivity/7_flasher.jpg)\n\n\n## Configuration\nReboot your ESP (simply reconnect USB to computer).\nThen connect to airRohr--xxxxxxx Wi-Fi network and in your browser write address 192.168.4.1:\n\n![menu](../images/sensors-connectivity/8_menu1.jpg)\n\nGo to Configuration -> Wi-Fi Settings and add the information about your Wi-Fi network:\n\n![config](../images/sensors-connectivity/9_W-fi.jpg)\n\nThen press "Save configuration and restart" and ESP will be connected to the provided Wi-Fi network.\n\n![save](../images/sensors-connectivity/10_save.jpg)\n\n\nThen find ESP in local network (for that your computer and ESP must be in one network). You can do it using airrohr-flasher. Run it, go to the Discovery tab and press Refresh, then you\'ll be able to see the address.\n\n![addr](../images/sensors-connectivity/11_flaser2.jpg)\n\n\n\nOpen ESP local address in your browser, go to `APIs` tab in  `Configuration` and click `Robonomics`. \n\n![robonomics](../images/sensors-connectivity/12_APIrobonomics.jpg)\n\n> If you want to send data to your own server, enable `Custom API` and write your address and port \n\nThen go to `Sensors` tab, enable GPS and put in your coordinates. Also enable the sensors you connected:\n\n![gps](../images/sensors-connectivity/13_gps.jpg)\n\nThen press `Save configuration and restart`.\n\n\n\n## Results\nGo to [sensors.robonomics.network](https://sensors.robonomics.network/#/), and you will see your sensor on the map.\n\n![map](../images/sensors-connectivity/14_map.jpg)\n'}},{node:{id:"9a477fa449601547bb20455eea5a53c8",title:"Connect Mars Curiosity rover under Robonomics parachain control",path:"/docs/ja/connect-mars-curiosity-rover-under-robonomics-parachain-control/",content:'\n**Let\'s see how Robonomics Parachain control allows to make Mars Curiosity rover move. Requirements:**\n- Ubuntu 18.04 LTS\n- ROS Melodic + Gazebo + RViz (installation manual [here](http://wiki.ros.org/melodic/Installation))\n- extra packages:\n```shell\nsudo apt-get install ros-melodic-gazebo-ros-control ros-melodic-effort-controllers ros-melodic-joint-state-controller\n```\n- IPFS 0.4.22 (download from [here](https://dist.ipfs.io/go-ipfs/v0.4.22/go-ipfs_v0.4.22_linux-386.tar.gz) and install)\n- Python dependencies:\n```\npip install ipfshttpclient\n```\n- Robonomics node (binary file) (download latest release [here](https://github.com/airalab/robonomics/releases))\n- IPFS browser extension (optional)\n\nHere is the video showing successful launch:\n\nhttps://youtu.be/pl3eIEC_T2o\n\n## 1. Set up a simulation\nDownload Curiosity rover package:\n```\nmkdir -p robonomics_ws/src\ncd robonomics_ws/src\ngit clone https://bitbucket.org/theconstructcore/curiosity_mars_rover/src/master/\ncd ..\n```\nWe need to adjust starting conditions to make our rover spawn smoothly:\n- Go to\n\n`/robonomics_ws/src/master/curiosity_mars_rover_description/worlds` and change line 14 of the file` mars_curiosity.world` to\n`<pose>0 0 9 0 0 0</pose>`.\n\n- Go to\n\n`/robonomics_ws/src/master/curiosity_mars_rover_description/launch` and change line 4 of the file `mars_curiosity_world.launch` to\n`<arg name="paused" default="false"/>`.\n\nDon’t forget to add source command to `~/.bashrc`:\n```\necho "source /home/$USER/robonomics_ws/devel/setup.bash" >> ~/.bashrc\n```\n\n## 2. Download controller package\nIn terminal do the following. This will download a sample script used in the demo:\n```\ncd ~/robonomics_ws/src\ngit clone https://github.com/PaTara43/robonomics_sample_controller\ncd ../..\ncatkin build\n```\n\n## 3. Manage accounts in DAPP\nSince we are testing, let\'s create a local robonomics network node with robonomics binary file:\n```\n./robonomics --dev --rpc-cors all\n```\n**Important!** Before next launches it is necessary to remove a directory `db` with\n\n```\nrm -rf /home/$USER/.local/share/robonomics/chains/dev/db\n```\n\nAfter a successful launch create accounts for the rover and for it\'s employer following [this](/docs/create-account-in-dapp) manual. **Do not forget to save each account\'s seed (RAW SEED) and address! You will need them for transactions**. Add these addresses, seeds and path to robonomics binary file to file `config.config` in `robonomics_ws/src/robonomics_sample_controller/src`. Transfer some money (units) to these accounts:\n\n![Config](../images/curiosity-demo/config.jpg "Config")\n\n![Balances](../images/curiosity-demo/balances.jpg "Balances")\n\n## 4. Start Robonomics\nUp to now the **only thing running** should be the robonomics local node.\nIn a separate terminal launch IPFS:\n```\nipfs init # you only need to do this once\nipfs daemon\n```\nIn another separate terminal launch Curiosity simulation:\n```\nroslaunch curiosity_mars_rover_description main_real_mars.launch\n```\nWait till it stays still and after that in another terminal launch the controller:\n```\nrosrun robonomics_sample_controller sample_controller.py\n```\n\n![Curiosity](../images/curiosity-demo/curiosity.jpg "Curiosity")\n\nNow you can send a transaction triggering the Rover to start moving and collecting data. To do so, you should use the [Robonomics IO](https://wiki.robonomics.network/docs/rio-overview/)  `write` subcommand of robonomics binary file:\n```\necho "ON" | ./robonomics io write launch -r <CURIOSITY ADDRESS> -s <EMPLOYER’S KEY>\n```\nWhere `<CURIOSITY ADDRESS>`  and `<EMPLOYER’S KEY>` are replaced with  previously saved strings accordingly.\nYou should see the log `"Arming..."` and the robot should start moving its camera and arm. Later, when the job is done (there is a log informing user when the program has finished), on the Robonomics portal go to `Developer` -> `Chain state` and add a CURIOSITY datalog using `“+”` button with selected `datalog` as state query:\n\n![Datalog](../images/curiosity-demo/hash_in_chain.jpg "Datalog")\n\nThe IPFS hash of the telemetry has been saved in the blockchain. To see the data simply copy the hash and add it to the local [gateway](https://gateway.ipfs.io/ipfs/QmeYYwD4y4DgVVdAzhT7wW5vrvmbKPQj8wcV2pAzjbj886/docs/getting-started/) address `localhost:8080/ipfs/`:\n\n![Voila](../images/curiosity-demo/datalog.jpg "Voila")\n\n## Troubleshooting\n\nIf due to some reason addresses in IO module and on the portal are displayed unequally (e.g. `5...` and `4...`) and the program outputs "Not my job is paid", fill in configuration file with address of the same type as in IO module.\n'}},{node:{id:"d20714a5fab77d0b492c08e3cdfcdea7",title:"Connect any ROS-compatitable robot under Robonomics parachain control. Part 2, IPFS",path:"/docs/ja/connect-any-ros-compatitable-robot-under-robonomics-parachain-control-2/",content:'\n**In this article we will continue using Robonomics tools to make a drone be controlled by a parachain. This time we will add sending data to IPFS and hash storing in chain options. Below is the instruction and code snippets. Requirements:**\n- [**Part 1 of this tutorial**](/docs/connect-any-ros-compatitable-robot-under-robonomics-parachain-control-1)\n- Ubuntu 18.04 LTS\n- ROS Melodic + Gazebo + RViz (installation manual [here](http://wiki.ros.org/melodic/Installation))\n- IPFS 0.4.22 (download from [here](https://dist.ipfs.io/go-ipfs/v0.4.22/go-ipfs_v0.4.22_linux-386.tar.gz) and install)\n- Robonomics node (binary file) (download latest release [here](https://github.com/airalab/robonomics/releases))\n- Python dependencies:\n```\npip install cv_bridge ipfshttpclient\n```\nThe entire process of coding this part of demo is presented in a video below.\n\nhttps://www.youtube.com/watch?v=dliLb6GHgpo&feature=youtu.be\n\n\n## 1. Add dependencies\nIf we launch a simulation and look at the topic list (see previous tutorial), we will see, that there is one topic containing front camera data and using `sensor_msgs/Image` message type:\n\n![front_camera](../images/drone-demo/front_camera.jpg "front_camera")\n\nLet\'s try to take a picture every 1 second and after the flight publish these photos to IPFS. If you have completed the first tutorial, you don\'t need to download anything else. It\'s the `drone_sample_controller_pictures.py` script.\n## 2. Manage accounts in DAPP\nAs done in a previous tutorial, create a local robonomics network node with robonomics binary file:\n```\n./robonomics --dev\n```\n**Important!** Before next launches it is necessary to remove a directory `db` with\n```\nrm -rf /home/$USER/.local/share/robonomics/chains/dev/db\n```\nAfter a successful launch create accounts following [this](/docs/create-account-in-dapp) manual. **Do not forget to save each account\'s seed and address! You will need them for transactions**. Add these addresses, seeds and path to robonomics binary file to file `config.config` in `robonomics_ws/src/robonomics_sample_controller/src`. Transfer some money (units) to these accounts:\n\n![balances](../images/drone-demo/balances.jpg "balances")\n## 3. Launch\nUp to now the **only thing running** should be the robonomics local node. In a separate terminal launch drone simulation:\n```\nroslaunch sjtu_drone simple.launch\n```\nIn another one launch ipfs daemon:\n```\nifps init # you only need to do this once\nipfs daemon\n```\nRun the script:\n```\nrosrun drone_simulator_controller drone_sample_controller_pictures.py\n```\nNow you can send a transaction triggering the drone to start flying and taking pictures. To do so, you should use the Robonomics IO `write` subcommand of robonomics binary file:\n```\necho "ON" | ./robonomics io write launch -r <DRONE_ADDRESS> -s <EMPLOYER’S_KEY>\n```\nWhere `<DRONE_ADDRESS>`  and `<EMPLOYER’S_KEY>` are replaced with  previously saved strings accordingly.\nYou should see the log `"Taking Off"` and the drone should start flying and taking pictures:\n\n![flying_picturing](../images/drone-demo/flying_picturing.jpg "flying_picturing")\n\nLater, when the job is done, on the Robonomics portal go to `Developer` -> `Chain state` and add a `DRONE` datalog using `“+”` button with selected `datalog` as state query. The IPFS hash of the telemetry has been saved in the blockchain. To see the data simply copy the hash and add it to the local [gateway](https://gateway.ipfs.io/ipfs/QmeYYwD4y4DgVVdAzhT7wW5vrvmbKPQj8wcV2pAzjbj886/docs/getting-started/) address `localhost:8080/ipfs/`:\n\n![Voila](../images/drone-demo/datalog.jpg "Voila")\n'}},{node:{id:"e495811454e18d6c06d71d5280de1f8d",title:"Connect ROS-compatibale Drone To Robonomics Parachain. Part 1. Launch by Transaction",path:"/docs/ja/connect-any-ros-compatitable-robot-under-robonomics-parachain-control-1/",content:'\n**In this article we will show that with the help of Robonomics tools you can control any ROS-compatitable device. We will find a random drone simulation package on the web and adjust it to run with Robonomics.**\n**Requirements:**\n- Ubuntu 18.04 LTS\n- ROS Melodic + Gazebo + RViz (installation manual [here](http://wiki.ros.org/melodic/Installation))\n- Robonomics node (binary file) (download latest release [here](https://github.com/airalab/robonomics/releases))\n\nThe entire process of coding this part of demo is presented in a video below.\n\nhttps://www.youtube.com/watch?v=fDpwhBasQ5o&feature=youtu.be\n\n## 1. Find a simulation\nLet\'s surf the web. Google for `ROS drone simulator`. The first link will mostly likely show you the `tum_simulator` page on [http://wiki.ros.org/tum_simulator](http://wiki.ros.org/tum_simulator)\n\n![tum_simulator](../images/drone-demo/tum_simulator.jpg "tum_simulator")\n\nIt\'s pretty outdated, so we better find a fork for our system. Google for `tum_simulator Ubuntu 18 Gazebo 9 fork`. The first result is a GitHub [repo](https://github.com/tahsinkose/sjtu-drone) with an appropriate package. Dowload it\n```\nmkdir -p drone_simulator_ws/src\ncd drone_simulator_ws/src\ngit clone https://github.com/tahsinkose/sjtu-drone\ncd ..\ncatkin build\n```\nDon’t forget to add source command to `~/.bashrc`:\n```\necho "source /home/$USER/drone_simulator_ws/devel/setup.bash" >> ~/.bashrc\nsource "~/.bashrc"\n```\nNow we can run the simulation to see what do we need to do to take the drone under parachain control.\n```\nroslaunch sjtu_drone simple.launch\n```\n\n## 2. Inspect ROS topics\nWhen the simulation is runnung, in a new tab run the following command to see the list of topics used by the drone:\n```\nrostopic list\n```\nLet\'s take a look at `/cmd_vel`, `/drone/takeoff` and `/drone/land`:\n```\nrostopic info /cmd_vel\nrostopic info /drone/takeoff\nrostopic info /drone/land\n```\n\n![topics_info](../images/drone-demo/topics_info.jpg "topics_info")\n\nAs may be seen, there should be messages of `Twist` and `Empty` types, they are parts of `std_msgs` and `geometry_msgs`, we\'ll use this in the controller. Shut the simulation for a while.\n## 3. Download controller package\nGlobally, the main difference from the casual ROS robot controller is a block of code, which checks all the transactions in the network using [Robonomics IO](https://wiki.robonomics.network/docs/rio-overview/). The package itself is available on GitHub. Download it and build the workspace:\n```\ncd ~/drone_simulator_ws/src\ngit clone https://github.com/PaTara43/drone_simulator_controller\ncd drone_simulator_controller/src\nchmod +x *.py\ncd ~/drone_simulator_ws/src\ncatkin build\n```\n## 4. Manage accounts in DAPP\nSince we are testing, let\'s create a local robonomics network node with robonomics binary file:\n```\n./robonomics --dev\n```\n**Important!** Before next launches it is necessary to remove a directory `db` with\n\n```\nrm -rf /home/$USER/.local/share/robonomics/chains/dev/db\n```\nAfter a successful launch create accounts following [this](/docs/create-account-in-dapp) manual. **Do not forget to save each account\'s seed and address! You will need them for transactions**. Add these addresses, seeds and path to robonomics binary file to file `config.config` in `robonomics_ws/src/robonomics_sample_controller/src`. Transfer some money (units) to these accounts:\n\n![balances](../images/drone-demo/balances.jpg "balances")\n## 5. Launching the drone under parachain control\nUp to now the **only thing running** should be the robonomics local node. In a separate terminal launch drone simulation:\n```\nroslaunch sjtu_drone simple.launch\n```\nRun the script:\n```\nrosrun drone_simulator_controller drone_sample_controller.py\n```\n\n![launched_drone](../images/drone-demo/launched_drone.jpg "launched_drone")\n\nNow you can send a transaction triggering the drone to start flying. To do so, you should use the Robonomics IO `write` subcommand of robonomics binary file:\n```\necho "ON" | ./robonomics io write launch -r <DRONE_ADDRESS> -s <EMPLOYER’S_KEY>\n```\nWhere `<DRONE_ADDRESS>`  and `<EMPLOYER’S_KEY>` are replaced with  previously saved strings accordingly.\nYou should see the log `"Taking Off"` and the drone should start flying:\n\n![flying](../images/drone-demo/flying.jpg "flying")\n\nThat\'s how any ROS-compatitable robot can be controlled by Robonomics parachain control. Proceed to [part 2](/docs/connect-any-ros-compatitable-robot-under-robonomics-parachain-control-2) to learn more\n'}},{node:{id:"c87920f846f5ae1464a4a54371444a59",title:"Configuration Options Description",path:"/docs/ja/configuration-options-description/",content:'\nBasically, you can think of the package as a black box with one input (sensor data) and many outputs.\nFor now only SDS011 sensor is supported, but if you are familiar with Python it\'d be easy to add other sensors as well.\n\nHave a look at [configuration](https://github.com/airalab/sensors-connectivity/blob/master/config/default.json) file:\n\n```json\n{\n   "general":{\n      "publish_interval":30\n   },\n   "comstation":{\n      "enable":false,\n      "port":"/dev/ttyUSB0",\n      "work_period":300,\n      "geo":"",\n      "public_key":""\n   },\n   "httpstation":{\n      "enable":true,\n      "port":8001\n   },\n   "mqttstation": {\n      "enable": true,\n      "host": "connectivity.robonomics.network",\n      "port": 1883\n   },\n   "luftdaten":{\n      "enable":true\n   },\n   "robonomics":{\n      "enable":true,\n      "ipfs_provider":"/ip4/127.0.0.1/tcp/5001/http",\n      "ipfs_topic":"airalab.lighthouse.5.robonomics.eth"\n   },\n   "datalog":{\n      "enable":false,\n      "path":"",\n      "suri":"",\n      "remote":"wss://substrate.ipci.io",\n      "dump_interval":3600,\n      "temporal_username":"",\n      "temporal_password":""\n   },\n   "dev":{\n      "sentry":""\n   }\n}\n```\nAt the moment it\'s possible to publish data to [Luftdaten](https://luftdaten.info/), [Robonomics Network](https://robonomics.network/) and [Datalog](https://github.com/airalab/robonomics).\nThe last one is experimental!\n\n> DO NOT edit `config/default.json` file. Instead make a copy\n\nPlay around with the configuration!\n\nExplanation of options:\n\n| Field                         | Description                                                                                                                                                                                                                                           |\n|------------------------------    |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------    |\n| `general/publish_interval`         | integer number from 1 and above. Tells how often send measurements. Keep in mind that if measurements from sensors come less often than this number connectivity sends last data      |\n| `comstation/enable`                | true/false. Enabling/disabling the station      |\n| `comstation/port`                  | valid path to com port, for example `/dev/ttyUSB0`. It is where a sensor is connected to      |\n| `comstation/work_period`           | integer from 0 to 1800. For SDS011 sensor 0 means continuous work. Recommended period is 300 seconds     |\n| `comstation/geo`                   | `lat,lon` a string with two floats separated by a comma. It represents latitude and longitude of a sensor     |\n| `comstation/public_key`            | Ed25519 verifying key in hex format. If not provided connectivity generates a new one      |\n| `httpstation/enable`                | true/false. Enabling/disabling the station   |\n| `httpstation/port`                  | what port listen to      |\n| `mqttstation/enable`                | true/false. Enabling/disabling the station   |\n|`mqttstation/host`                   | the hostname or IP address of the remote broker |\n|`mqttstation/port`                   | the network port of the server host to connect to |\n| `luftdaten/enable`                 | true/false. Whether or not publish data to [Luftdaten](https://devices.sensor.community/). Don\'t forget to register the sensor\'s mac address on the site         |\n| `robonomics/enable`                | true/false. Whether or not publish data to IPFS topic according to Robonomics communication protocol      |\n| `robonomics/ipfs_proveder`         | an endpoint for IPFS daemon. By default it\'s `/ip4/127.0.0.1/tcp/5001/http` that means local daemon. The endpoint must by in multiaddr format. For example for [Infura.io](https://infura.io/) it would be `/dns/ipfs.infura.io/tcp/5001/https`       |\n| `robonomics/ipfs_topic`            | IPFS topic\'s name. If you want to use [DApp](https://sensors.robonomics.network) provided by Robonomics team leave it untouched                 |\n| `datalog/enable`                   | true/false. Enable/Disable saving log to [Robonomics on Substrate chain](https://ui.ipci.io/)    |\n| `datalog/path`                     | full path to `robonomics` executable file. You can find the latest release on [this](https://github.com/airalab/robonomics/releases) page  |\n| `datalog/suri`                     | a private key from substrate chain account  |\n| `datalog/remote`                   | an endpoint to substrate instance                                                           |\n| `datalog/dump_interval`            | specify a period of time for collecting log in seconds                                      |\n| `datalog/temporal_username`        | set username to upload files to [Temporal.Cloud](https://temporal.cloud/) (Optional)                  |\n| `detalog/temporal_password`        | set password to upload files to [Temporal.Cloud](https://temporal.cloud/) (Optional)                  |\n| `dev/sentry`                       | for development purpose. If you have a [Sentry.io](https://sentry.io/) account you can put sentry\'s credentials in here   |\n\n## Scenario #1: Connect SDS011 to serial port\n\nThe easiest and the most straightforward way to connect your sensor to the network is using the serial port\n\nConnect you SDS011 sensor to a USB port, let\'s assume it got `/dev/ttyUSB0` address\n\n```json\n{\n   "general":{\n      "publish_interval":30            \n   },\n   "comstation":{\n      "enable":true,\n      "port":"/dev/ttyUSB0",\n      "work_period":300,\n      "geo":"59.944954,30.294534",\n      "public_key":""\n   },\n   "httpstation":{\n      "enable":false,\n      "port":8001\n   },\n   "luftdaten":{\n      "enable":true\n   },\n   "robonomics":{\n      "enable":true,\n      "ipfs_provider":"/ip4/127.0.0.1/tcp/5001/http",\n      "ipfs_topic":"airalab.lighthouse.5.robonomics.eth"\n   },\n   "datalog":{\n      "enable":false,\n      "path":"",\n      "suri":"",\n      "remote":"wss://substrate.ipci.io",\n      "dump_interval":3600,\n      "temporal_username":"",\n      "temporal_password":""\n   },\n   "dev":{\n      "sentry":""\n   }\n}\n```\n\n## Scenario #2: Connect SDS011 via HTTP\n\n### Connectivity Configuration\n\n```json\n{\n   "general":{\n      "publish_interval":30            \n   },\n   "comstation":{\n      "enable":false,\n      "port":"/dev/ttyUSB0",\n      "work_period":300,\n      "geo":"59.944954,30.294534",\n      "public_key":""\n   },\n   "httpstation":{\n      "enable":true,\n      "port":8001\n   },\n   "luftdaten":{\n      "enable":true\n   },\n   "robonomics":{\n      "enable":true,\n      "ipfs_provider":"/ip4/127.0.0.1/tcp/5001/http",\n      "ipfs_topic":"airalab.lighthouse.5.robonomics.eth"\n   },\n   "datalog":{\n      "enable":false,\n      "path":"",\n      "suri":"",\n      "remote":"wss://substrate.ipci.io",\n      "dump_interval":3600,\n      "temporal_username":"",\n      "temporal_password":""\n   },\n   "dev":{\n      "sentry":""\n   }\n}\n```\n\n> Do not forget to open the port in system firewall\n>\n> On NixOS you can do:\n> ```\n> networking.firewall.allowedTCPPorts = [ 31313 ];\n> ```\n\n## Scenario #3: Connect SDS011 via MQTT\n\n### Connectivity Configuration\n\n```json\n{\n   "general":{\n      "publish_interval":30\n   },\n   "comstation":{\n      "enable":false,\n      "port":"/dev/ttyUSB0",\n      "work_period":300,\n      "geo":"",\n      "public_key":""\n   },\n   "httpstation":{\n      "enable":true,\n      "port":8001\n   },\n   "mqttstation": {\n      "enable": true,\n      "host": "connectivity.robonomics.network",\n      "port": 1883\n   },\n   "luftdaten":{\n      "enable":true\n   },\n   "robonomics":{\n      "enable":true,\n      "ipfs_provider":"/ip4/127.0.0.1/tcp/5001/http",\n      "ipfs_topic":"airalab.lighthouse.5.robonomics.eth"\n   },\n   "datalog":{\n      "enable":false,\n      "path":"",\n      "suri":"",\n      "remote":"wss://substrate.ipci.io",\n      "dump_interval":3600,\n      "temporal_username":"",\n      "temporal_password":""\n   },\n   "dev":{\n      "sentry":""\n   }\n}\n```\n\n## Scenario #4: Connect Multiple Sensors and Publish to Datalog\n\n### Install Robonomics\n\nFrom `root` user do:\n\n```\necho "https://github.com/airalab/airapkgs/archive/nixos-unstable.tar.gz nixos" > /root/.nix-channels\nnix-channel --update\n```\n\nThen edit `/etc/nixos/configuration.nix` and add:\n\n```\n...\n  environment.systemPackages = with pkgs; [\n        substrate-node-robonomics-bin\n  ];\n...\n```\n\nRun rebuild and find out where `robonomics` is:\n```\nnixos-rebuild switch\nwhereis robonomics\n```\n\nLet\'s assume you got the following path: `/nix/store/2gz2ik17w5xad8w819bsb05a23pbjbya-system-path/bin/robonomics`\n\n### Configuration\n\n```json\n{\n   "general":{\n      "publish_interval":30            \n   },\n   "comstation":{\n      "enable":false,\n      "port":"/dev/ttyUSB0",\n      "work_period":300,\n      "geo":"59.944954,30.294534",\n      "public_key":""\n   },\n   "httpstation":{\n      "enable":true,\n      "port":8001\n   },\n   "luftdaten":{\n      "enable":true\n   },\n   "robonomics":{\n      "enable":true,\n      "ipfs_provider":"/ip4/127.0.0.1/tcp/5001/http",\n      "ipfs_topic":"airalab.lighthouse.5.robonomics.eth"\n   },\n   "datalog":{\n      "enable":true,\n      "path":"/nix/store/2gz2ik17w5xad8w819bsb05a23pbjbya-system-path/bin/robonomics",\n      "suri":"0x...",\n      "remote":"wss://substrate.ipci.io",\n      "dump_interval":3600,\n      "temporal_username":"temporaluser",\n      "temporal_password":"temporalpass"\n   },\n   "dev":{\n      "sentry":""\n   }\n}\n```\n\n\n'}},{node:{id:"e3944f34d4d0a1c8789124183746d959",title:"Community",path:"/docs/ja/community/",content:"\n**Here you can learn how to get involved in the Robonomics Network Community.**\n\nThere are many ways to contribute to Robonomics Network: you can contribute directly based on your skills and professional background, you can attend an event, join the conversation online or watch for our latest news and release.\n\n## For Developers\n\n- [Robonomics' code base and new releases on GitHub](https://github.com/airalab)\n- [Ask your technical question on Riot](https://riot.im/app/#/room/#robonomics:matrix.org)\n\n## For Researchers & Academics\n\n- [Read Robonomics White Paper and our scientific articles](https://robonomics.network/community/#science)\n\nIf you have a background in mathematics, cryptography, or economics you might be interested for collaboration with us, write us to [research@aira.life](mailto:research@aira.life)\n\n## For All, even non-technical\n\n- [Get familiar with Robonomics services and statistics in dApp - open in browser with Metamask](https://dapp.robonomics.network)\n- [Read our blog](https://blog.aira.life)\n- [Stay tuned by following us on Twitter](https://twitter.com/AIRA_Robonomics)\n\nIf you are not a developer or a researcher, you can start with other suggestions for getting involeved in Robonomics Network Community. If you want to organize a meetup in your city, write content about Robonomics, translate Robonomics content into your native language, write to [community@aira.life](mailto:community@aira.life)\n"}},{node:{id:"d1aec3a1462e0a0afb0af73d09f74112",title:'Say "Hello Baxter!" with robonomics',path:"/docs/ja/baxter2/",content:'\nExample of how it works is available [here][db1].\n\n## Requirements:\n - Ubuntu 18.04\n - ROS Melodic + Gazebo (installation manual [here][db2])  \n - extra packages:\n```sh\nsudo apt-get install ros-melodic-qt-build ros-melodic-driver-common ros-melodic-gazebo-ros-control ros-melodic-gazebo-ros-pkgs ros-melodic-ros-control ros-melodic-control-toolbox ros-melodic-realtime-tools ros-melodic-ros-controllers ros-melodic-xacro python-wstool ros-melodic-tf-conversions ros-melodic-kdl-parser python-wstool python-catkin-tools qt4-default\n```\n\n- IPFS 0.4.22 (download from [here][db3] and install)\n- pip:\n```sh\nsudo apt install python-pip\n```\n\n- ipfshttpclient\n```sh\npip install ipfshttpclient\n```  \n\n\n - Robonomics node (binary file) (download latest [release][db4] here)\n - Create __Baxter__ and __Employer__ accounts  on **Robonomics Portal**  \n (you can find tutorial ["Create an Account on Robonomics Portal"][db8] here).\n - IPFS browser extension (not necessary)\n\n## 1. Download Baxter model\nDownload packages:\n```sh\ncd ~\nmkdir -p robot_ws/src\ncd robot_ws/src/\nwstool init .\nwstool merge https://raw.githubusercontent.com/RethinkRobotics/baxter_simulator/master/baxter_simulator.rosinstall\nwstool update\ngit clone https://github.com/nakata5321/Baxter_simulation_controller.git\n```\nThis packages were created for ROS indigo. We have to change some files to run them on ROS melodic.\nWe will use **patch** files.\n```sh\npatch ./baxter_simulator/baxter_sim_io/include/baxter_sim_io/qnode.hpp ./Baxter_simulation_controller/patch/qnode_patch\npatch ./baxter_simulator/baxter_sim_kinematics/src/arm_kinematics.cpp ./Baxter_simulation_controller/patch/arm_patch\n```\nAnd let\'s build  all our packages:\n```sh\ncd ..\ncatkin build\n```\nDont forget to add source command:\n```sh\necho "source /home/$USER/robot_ws/devel/setup.bash" >> ~/.bashrc\nsource ~/.bashrc\n```  \n__Important!__ At the end save *Robonomics node (binary file)* in **robot_ws** directory.\n\n## 2. Start simulation\nFirst of all copy and edit `baxter.sh`\n```sh\ncp src/baxter/baxter.sh .\n```\n\nFind your local ip adress with command:\n```\nip a\n```\n![ip_a][im14]\n\nEdit the following values in `baxter.sh` :\n```\nnano baxter.sh\n```\n\nEdit the following values in `baxter.sh` :\n\n- your_ip - put your local ip address. See `ip a`\n- ros_version - for example "melodic"\n\n![baxtersh][im15]\n\nRun the baxter shell script with sim specified:\n```sh\n./baxter.sh sim\nroslaunch baxter_gazebo baxter_world.launch\n```\nYou can put some models in front of our baxter. It will be more intresting.\n![baxter][im2]\n\n## 3.Manage accounts in DAPP\n\nSince we are testing, let us create a local robonomics network with robonomics binary file. Go to folder with robonomics file and run:\n```sh\n./robonomics --dev --rpc-cors all\n```\n![robonomics][im3]\n\nDon\'t forget to remove `db` folder after every launch:\n```sh\nrm -rf /home/$USER/.local/share/robonomics/chains/dev/db\n```\n\nGo to [https://parachain.robonomics.network][db5] and switch to local node\n![local node][im4]\n\nGo to Accounts and transfer some money to __Baxter__ and __Employer__ accounts.\n\nYou can find The manual "Create an Account on Robonomics Portal" [here.][db8]\n\n\nAdd Baxter\'s secret key and adress to `config.yaml` in `robot_ws/src/Baxter_simulation_controller/config/`\n\n## 4.Beginning of work\n\nIn new window run:\n```sh\nifps init #you only need to do this once\nipfs daemon\n```\nOpen separate terminal and start *controller package*:\n```sh\nrosrun robot_controller robot_control.py\n```\n![waiting][im7]\n\nReturn to the first terminal, open new window and send command to [**robonomics io**][db6]. This command will turn ON your robot:\n```sh\necho "ON" | ./robonomics io write launch -r <BAXTER ADDRESS> -s <EMPLOYER’S KEY>\n```\nWhere `<BAXTER ADDRESS>`  and `<EMPLOYER’S KEY>` are replaced with previously saved strings accordingly.\n\n![rob_message][im8]\n\nYou should see the following:\n\n![working][im9]\n\nwhen the work is over go to the Robonomics Portal to `Developer > Chain state`. Choose *datalog* in **state query** and add Baxter datalog message using "+" button.\n\n![datalog][im10]\n\nNow the IPFS hash of the telemetry and photos is saved in the blockchain. To see the data simply copy the hash and insert it in the search bar with URL: `gateway.ipfs.io/ipfs/<put your hash here>`\n\n\nThat\'s all!\n\n![result1][im12]\n![result2][im13]\n\n[db1]: <https://youtu.be/2AQGFVzkGdg>\n[db2]: <http://wiki.ros.org/melodic/Installation>\n[db3]: <https://dist.ipfs.io/go-ipfs/v0.4.22/go-ipfs_v0.4.22_linux-386.tar.gz>\n[db4]: <https://github.com/airalab/robonomics/releases>\n[db8]: </docs/create-account-in-dapp>\n[im1]: <../images/baxter_demo/empty_world.jpg>\n[im2]: <../images/baxter_demo/baxter_simulation.jpg>\n[im3]: <../images/baxter_demo/robonomics.jpg>\n[db5]: <https://parachain.robonomics.network>\n[im4]: <../images/baxter_demo/local_node.jpg>\n[im7]: <../images/baxter_demo/waiting.jpg>\n[im8]: <../images/baxter_demo/rob_message.jpg>\n[im9]: <../images/baxter_demo/working.jpg>\n[im10]: <../images/baxter_demo/datalog.jpg>\n[im11]: <../images/baxter_demo/ipfs.jpg>\n[im12]: <../images/baxter_demo/result1.jpg>\n[im13]: <../images/baxter_demo/result2.jpg>\n[db6]: </docs/rio-overview>\n[im14]:<../images/baxter_demo/ip_a.png>\n[im15]:<../images/baxter_demo/baxter_sh.jpg>\n'}},{node:{id:"92b1d2270c986871832ad10e7277f00b",title:"Control Baxter robot with robonomics",path:"/docs/ja/baxter/",content:'\nExample of how it works:\n\nhttps://youtu.be/AeufQmaNRWk\n\n## Requirements:\n - Ubuntu 18.04\n - ROS Melodic + Gazebo (installation manual [here][db2])  \n - extra packages:\n```sh\nsudo apt-get install ros-melodic-gazebo-ros-control ros-melodic-effort-controllers ros-melodic-joint-state-controller\n```\n- IPFS 0.4.22 (download from [here][db3] and install)\n- pip:\n```sh\nsudo apt install python-pip\n```\n\n- ipfshttpclient:\n```sh\npip install ipfshttpclient\n```\n\n\n - Robonomics node (binary file) (download latest [release][db4] here)\n - Create __Baxter__ and __Employer__ accounts  on **Robonomics Portal**  \n (you can find tutorial ["Create an Account on Robonomics Portal"][db6] here).\n - IPFS browser extension (not necessary)\n\n## 1. Download Baxter model and controller packages\nDownload packages:\n```sh\ncd ~\nmkdir -p robot_ws/src\ncd robot_ws/src\ngit clone https://github.com/nakata5321/Baxter_simulation_controller.git\ncd Baxter_simulation_controller\ngit checkout old_version\ncd ../..\ncatkin build\n```\nDont forget to add source command:\n```sh\necho "source /home/$USER/robot_ws/devel/setup.bash" >> ~/.bashrc\nsource ~/.bashrc\n```\n\n## 2. Create simulation world\nLet\'s start gazebo world and put our baxter in it:\n```sh\nroslaunch gazebo_ros empty_world.launch\n```\n![empty world][im1]\n\nOpen one more window in terminal:\n```sh\nrosrun gazebo_ros spawn_model -file `rospack find baxter_description`/urdf/baxter.urdf -urdf -z 1 -model baxter\n```\nYou can put some models in front of our baxter. It will be more intresting.\n![baxter][im2]\n\n## 3.Manage accounts in DAPP\n\nSince we are testing, let us create a local robonomics network with robonomics binary file. Go to folder with robonomics file and run:\n```sh\n./robonomics --dev --rpc-cors all\n```\n![robonomics][im3]\n\nDon\'t forget to remove `db` folder after every launch:\n```sh\nrm -rf /home/$USER/.local/share/robonomics/chains/dev/db\n```\n\nGo to [https://parachain.robonomics.network][db5] and switch to local node\n![local node][im4]\n\nGo to Accounts and transfer some money to __Baxter__ and __Employer__ accounts.\n\nYou can find The manual "Create an Account on Robonomics Portal" [here.][db6]\n\nAdd Baxter\'s secret key and adress to `configuration.txt` in `robot_ws/src/robot_controller/src/`\n\n## 4.Start simulation\n\nIn new window run:\n```sh\nifps init #you only need to do this once\nipfs daemon\n```\nOpen separate terminal and start *controller package*:\n```sh\nrosrun robot_controller robot_control.py\n```\n![waiting][im7]\n\nReturn to the first terminal, open new window and send command to [**robonomics io**][db7]. This command will turn ON your robot:\n```sh\necho "ON" | ./robonomics io write launch -r <CURIOSITY ADDRESS> -s <EMPLOYER’S KEY>\n```\nWhere `<CURIOSITY ADDRESS>` and `<EMPLOYER’S KEY>` are replaced with previously saved strings accordingly\n\n![rob_message][im8]\n\nYou should see the following:\n\n![working][im9]\n\nwhen the work is over go to the Robonomics Portal to `Developer > Chain state`. Choose *datalog* in **state query** and add Baxter datalog message using "+" button.\n\n![datalog][im10]\n\nNow the IPFS hash of the telemetry and photos is saved in the blockchain. To see the data simply copy the hash and insert it in IPFS Companion:\n\n![ipfs][im11]\n\nClick  __View on Gateway__ and that\'s all!\n\n![result1][im12]\n![result2][im13]\n\n[db2]: <http://wiki.ros.org/melodic/Installation>\n[db3]: <https://dist.ipfs.io/go-ipfs/v0.4.22/go-ipfs_v0.4.22_linux-386.tar.gz>\n[db4]: <https://github.com/airalab/robonomics/releases>\n[im1]: <../images/baxter_demo/empty_world.jpg>\n[im2]: <../images/baxter_demo/baxter_simulation.jpg>\n[im3]: <../images/baxter_demo/robonomics.jpg>\n[db5]: <https://parachain.robonomics.network>\n[im4]: <../images/baxter_demo/local_node.jpg>\n[im7]: <../images/baxter_demo/waiting.jpg>\n[db6]: </docs/create-account-in-dapp>\n[im8]: <../images/baxter_demo/rob_message.jpg>\n[im9]: <../images/baxter_demo/working.jpg>\n[im10]: <../images/baxter_demo/datalog.jpg>\n[im11]: <../images/baxter_demo/ipfs.jpg>\n[im12]: <../images/baxter_demo/result1.jpg>\n[im13]: <../images/baxter_demo/result2.jpg>\n[db7]: </docs/rio-overview>\n'}},{node:{id:"b50f46ed9c5ea9e7556a3e589da2c0cf",title:"AIRA Overview",path:"/docs/ja/aira-overview/",content:"\n## Introduction\n\nAIRA stands for \"Autonomous Intelligent Robot Agent\". It implements the standard of economic interaction between human-robot and robot-robot. AIRA makes it possible to connect a variety of different robots under decentralized computer's control (currently supported Ethereum and Polkadot/Substrate).\n\nBasically it is the client for Robonomics Network developed by [Airalab](https://aira.life).\n\nAIRA is NixOS based operating system and officially supports the following architectures: x86, Raspberry Pi 3 B+ and Raspberry Pi 4.\n\nThe most simple way to get familiar with AIRA is to try installing AIRA as a [virtual machine](/docs/aira-installation-on-vb/).\n\nAIRA comes with a few preinstalled and configured services to help you focus on [agent](/docs/glossary#agent) development.\n\nMeanwhile it's highly customizable, but it's recommended to understand [NixOS](http://nixos.org/) and [Nix](https://nixos.org/nix/) language.\n\n## What's included? \n\nThe following services are included in the default distribution:\n\n* [Robonomics communication stack](https://github.com/airalab/robonomics_comm)\n* [IPFS](https://ipfs.io/)\n* OpenSSH\n* [cjdns](https://github.com/cjdelisle/cjdns)\n* [Yggdrasil-go](https://yggdrasil-network.github.io/)\n\nBesides at the first launch AIRA [generates](/docs/aira-installation-on-vb#launch-the-machine) for you new Ethereum address and IPNS identifier.\n\nIt's possible to use AIRA as a virtual machine or install as a main operating system. Also you can install only the services you need.\n"}},{node:{id:"7e5be80d03ded19ce4ce981224eb234d",title:"AIRA Installation",path:"/docs/ja/aira-installation/",content:"\n- [**How to launch AIRA on VirtualBox**](/docs/aira-installation-on-vb/)\n\n- **The installation on Raspberry Pi** is as simple as writing an image of AIRA on SD card using `dd` or [Etcher](https://www.balena.io/etcher/), for example.\n\n\n"}},{node:{id:"cf7476fb84c6c3be3b6662d4270adec8",title:"AIRA Installation on VirtualBox",path:"/docs/ja/aira-installation-on-vb/",content:'\nAIRA stands for "Autonomous Intelligent Robot Agent". It is the client for Robonomics Network developed by [Airalab](https://aira.life). It is an operating system based on [NixOS](https://nixos.org/). With AIRA you can  turn any cyber-physical system in an economic agent, where robots operate as a services for the reasonable payments. [More theory about AIRA here](/docs/aira-overview).\n\nIt\'s possible to install AIRA on a x86_64 PC. Also there are images for Raspberry Pi 3 and 4 supported by the team.\n\nThe best way to try AIRA is to start from installing it as a virtual machine on [VirtualBox](https://www.virtualbox.org/).\n\n## Requirements\n\n* VirtualBox\n* [VirtualBox Extension Pack](https://www.virtualbox.org/wiki/Downloads#VirtualBox6.1.2OracleVMVirtualBoxExtensionPack)\n* 2Gb of RAM for the machine\n* 40Gb of free disk space\n\n## Obtain the image\n\nAIRA has [stable](https://aira.life/channels/aira-stable/) and [unstable](https://aira.life/channels/aira-unstable/) channels.\n\nTo get stable image download the file with `.ova` extension.\n\tThe link for stable image is [here](https://releases.aira.life/channels/aira/stable/862-aira-stable/nixos-20.03pre-git-x86_64-linux.ova)\n\nDon\'t forget to compare checksum of the downloaded image with the last column `SHA-256 hash` on the [download page](https://aira.life/channels/aira-stable/). It must be equal to the output of the following command (it is an example, please check the name of downloaded by you .ova file first):\n\n```\nsha256sum nixos-20.03pre-git-x86_64-linux.ova\n```\n\nYou may wish to check out the walkthrough video:\n\nhttps://www.youtube.com/embed/cDcaypYPBhI\n\n## Troubleshooting\n\nIf you have fresh installed VirtualBox, you need to install the [extension](https://www.virtualbox.org/wiki/Downloads) pack or disable USB 2.0 controller.\n\nAlso VirtualBox may show a warning about `Display settings`. Consider switching `Graphics Controller` in settings of the VM to `VMSVGA`.\n\n## Import to VirtualBox\n\nOpen VirtualBox and press `Ctrl+I` or go to `File > Import Applicance...`\n\n![AIRA import VB image](../images/aira-installation/aira_import_vb_image.jpg "AIRA import VB image")\n\nAt this moment the next step is not necessary but it will help you to connect to the VM via SSH easily.\n\nFirst add `Host-Only` adapter in VirtualBox menu `File > Host Network Manager...` or by pressing `Ctrl+H`\n\n![Host Only](../images/aira-installation/host_only_adapter.jpg "Host Only")\n\nThen go to the image\'s settings, Network and add the second network adapter\n\n![Second adapter](../images/aira-installation/add_second_adapter.jpg "Second adapter")\n\nFor more details look at the standalone [lesson](/docs/aira-connecting-via-ssh/).\n\nOptionally you can increase the amount of video memory and switch `Graphics Controller` to `VMSVGA`.\n\n## Launch the machine\n\nFinally press Start and you\'ll see AIRA welcoming you with generated Ethereum address and IPFS identifier\n\n![AIRA image ready, Welcome screen](../images/aira-installation/aira_image_ready.jpg "AIRA image ready, Welcome screen")\n\nAt the very first initialization AIRA generates new Ethereum address and IPNS identifier for you.\n\n'}},{node:{id:"0705abac9038b5676dc00c5ff2e74ecc",title:"Frequently Asked Questions about AIRA",path:"/docs/ja/aira-faq/",content:"\n## How to see logs from main services?\n\nIPFS in real time:\n\n    journalctl -u ipfs -f\n\nand Liability::\n\n    journalctl -u liability -f\n\n## How to check the quantity of IPFS peers?\n\n    ipfs pubsub peers \n\n## IPFS can't connect to the daemon, what should I do?\n\nTry to specify `--api` option\n\n    ipfs swarm peers --api=/ip4/127.0.0.1/tcp/5001/\n\n## How to change ethereum address of AIRA?\n\nDelete `keyfile` and `keyfile-psk` in `/var/lib/liability` and restart the service\n\n```\nsystemctl restart liability\n```\n\n## IPFS daemon doesn't start\n\nThe error mostly occurs on single-board computers like Raspberry Pi or LattePanda after unexpected electricity lost.\n\nUsually the file `/var/lib/ipfs/api` is corrupted and one may see error:\n\n```\nError: Failed to parse '/var/lib/ipfs/api' file.\n  error: failed to parse multiaddr \"\": empty multiaddr\nIf you're sure go-ipfs isn't running, you can just delete it.\nOtherwise check:\n  ps aux | grep ipfs\n```\n\nYou can delete `/var/lib/ipfs/api` file and restart the service\n\n"}},{node:{id:"fdb82cf8b8e66b4c7e0741d07680b03c",title:"Connecting AIRA via SSH",path:"/docs/ja/aira-connecting-via-ssh/",content:'\nIt is more convenient to work with virtual machine via ssh connection. In this section we will configure VM.\n\n> **It\'s required to have your ssh public key on Github. In case you don\'t have one, please follow the [link](https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/)**\n\nBelow is the walkthrough video:\n\nhttps://www.youtube.com/embed/R6waDG5iwm0\n\n## Add Host Adapter\n\nGo to `File` -> `Host Network Manager...` or press `Ctrl+H`\n\n![VirtualBox Network Manager](../images/virtualbox_network_manager.png "VirtualBox Network Manager")\n\nClick `Create` button.\n\n## Add the Second Adapter to the VM\n\nSelect imported VM and click `Settings`. Go to `Network` tab and enable the second adapter\n\n![Add Second Adapter](../images/add_second_adapter_to_vm.png "Add Second Adapter")\n\n## Populate Authorized Keys\n\nLaunch the VM and run the following command replacing `<username>` with your Github user name:\n\n```\nmkdir .ssh\nchmod 700 .ssh\ncurl -sSL https://github.com/<username>.keys >> .ssh/authorized_keys\n```\n\nFind out the VM\'s IP address by running:\n\n```\nip a\n```\n\nYou should look for an address which starts with `192.168.xx.xx`\n\n## Log in via SSH\n\nNow open your terminal and log in via SSH as usual using the address from the previous step:\n\n```\nssh root@192.168.xx.xx\n```\n'}},{node:{id:"86b3f1c497cdee4f0ddc3cdcc3661e3c",title:"Basic usage of AIRA",path:"/docs/ja/aira-basic-usage/",content:"\nTo get familiar with AIRA, let's see what is under the hood.\n\nOnce you launch the client several ros nodes will already be on the run. Here's a list of robonomics communication stack nodes:\n\n```bash\n$ rosnode list\n/eth/erc20_token\n/eth/eth_node\n/graph/aira_graph\n/liability/executor\n/liability/infochan/eth/signer\n/liability/infochan/ipfs_channel\n/liability/persistence\n/liability/listener\n/rosout\n```\n\n- `/eth/erc20_token`, `/eth/eth_node` - proved services for Ethereum blockchain and ERC20 tokens\n- `/graph/aira_graph` - service node for exploring other AIRA instances\n- `/liability/executor` - gets rosbag file from IPFS and plays it\n- `/liability/infochan/ipfs_channel` - is responsible for offer, demand and result messages. It catches messages from the channel and sends signed messages back\n- `/liability/infochan/eth/signer` - offers services for signing offer, demand and result messages\n- `/liability/listener` - watches for a new liability contracts. When the event is received the node calls executor node\n- `/liability/persistence` - helps to store incoming liabilities and restart them after shutdown\n\nAnd here's a list of robonomics stack topics.\n\n```bash\n$ rostopic list\n/eth/event/approval\n/eth/event/transfer\n/graph/greetings\n/liability/complete\n/liability/finalized\n/liability/incoming\n/liability/infochan/eth/sending/demand\n/liability/infochan/eth/sending/offer\n/liability/infochan/eth/sending/result\n/liability/infochan/eth/signing/demand\n/liability/infochan/eth/signing/offer\n/liability/infochan/eth/signing/result\n/liability/infochan/incoming/demand\n/liability/infochan/incoming/offer\n/liability/infochan/incoming/result\n/liability/persistence/add\n/liability/persistence/del\n/liability/persistence/update_timestamp\n/liability/ready\n/liability/result\n/rosout\n/rosout_agg\n```\n\nThe most important topics for us are:\n\n- `/liability/incoming` - when a new liability is created, this topic publishes Ethereum address of the contract\n- `/liability/result` - this topic is for publishing results. But don't publish a result directly to this topic! Use a service instead\n- `/liability/infochan/incoming/*` - a CPS gets information about offer, demand or result from corresponding topics\n- `/liability/infochan/eth/signing/*` - a CPS sends offer, demand or result messages to corresponding topics\n\nFor the details check out the [API page](/docs/robonomics-liability/).\n\nLet's start with greetings - say hello to AIRA!\n\nYou should just launch a pre-installed package `hello_aira`:\n\n```\n$ rosrun hello_aira hello_aira\n```\n\nWe've launched our agent. It will wait for a demand message. Now it's time to send the message. Go to [dapp](https://airalab.github.io/robonomics_tutorials/) and press Order.\nNow go back to the console and see the result!"}},{node:{id:"34ec3362199344bcc5b9a72a3ef4d885",title:"Agent development examples",path:"/docs/ja/agent-development-examples/",content:"\nUseful pieces of code and a few scenarios. All source code is [here](https://github.com/vourhey/robonomics_tutorials).\n\n1. [Broadcast Demand](https://github.com/Vourhey/robonomics_tutorials/tree/master/01_broadcast_demand/)\n2. [Broadcast Offer](https://github.com/Vourhey/robonomics_tutorials/tree/master/02_broadcast_offer/)\n3. [Trader](https://github.com/Vourhey/robonomics_tutorials/tree/master/03_trader/)\n4. [Trader with ACL](https://github.com/Vourhey/robonomics_tutorials/tree/master/04_trader_with_acl/)\n5. [Open Sensor Data](https://github.com/Vourhey/robonomics_tutorials/tree/master/05_open_sensor_data/)\n\n"}},{node:{id:"d97aa8c0c70c0214551d89682c1e0f14",title:"Lección 4, Robonomics Parachain en la Práctica",path:"/docs/es/wschool2021-robonomics-parachain-in-practice/",content:"import Asciinema from '~/components/Asciinema.vue'\n\nLa Parachain de Robonomics no es una parachain de propósito general en el ecosistema de Polkadot. El objetivo de Robonomics es la construcción de la economía de las máquinas, el parachain en este ámbito de objetivos ayuda a integrar el ecosistema Polkadot con los conceptos de IoT, Smart Cities e Industria 4.0.\n\n## Requerimientos\n\n* Docker, por favor [instale](https://docs.docker.com/engine/install/).\n* Polkadot-launch, por favor [instale](https://github.com/paritytech/polkadot-launch#install).\n\n## Lanzar el Relay\n\nLa cadena de retransmisión es un núcleo de Polkadot, [proporciona seguridad](https://wiki.polkadot.network/docs/en/learn-security) compartida para todos los niños parachains e implementa mecanismos de transmisión de mensajes para ellos. Lancemos una instancia local de la Rococó relay chain (polkadot testnet) con dos parachains basadas en robonomics como niños. Usaré la etiqueta de imagen preparada de [Docker: “winter-school-2”](https://hub.docker.com/layers/robonomics/robonomics/winter-school-2/images/sha256-92f4795262f3ded3e6a153999d2777c4009106a7d37fd29969ebf1c3a262dc85?context=explore) pero todo el código fuente de los ejemplos está disponible en [Robonomics GitHub](https://github.com/airalab/robonomics/tree/master/scripts/polkadot-launch).\n\n<Asciinema vid=\"419Jrg22ziFfMFPZlh2WtiLvg\"/>\n\nPodría llevar un tiempo, pero sea partícipe. Como resultado, debe tener tres instancias de cadena en los puertos:\n\n* `9944` - local rococo relay chain.\n* `9988` - robonomics parachain with `id=100`\n* `9989` - robonomics parachain with `id=200`\n\nSi usa un servidor remoto, necesita crear algunos túneles SSH en la VM:\n```\nssh -f -N -L 9944:127.0.0.1:9944 root@REMOTE_SERVER_IP\nssh -f -N -L 9988:127.0.0.1:9988 root@REMOTE_SERVER_IP\nssh -f -N -L 9989:127.0.0.1:9989 root@REMOTE_SERVER_IP\n```\nDespués de eso, puede usar `ws://127.0.0.1:9944`, `ws://127.0.0.1:9988`and `ws://127.0.0.1:9989` en https://parachain.robonomics.network/\n\n![relay](https://ipfs.io/ipfs/QmR9Tj86yPkrXQsSwereJwqDxsZgkAdySB16G4SMHrhpBu/upcoming.png)\n\nHace algún tiempo se deberían registrar las parachains.\n\n![relay2](https://ipfs.io/ipfs/QmR9Tj86yPkrXQsSwereJwqDxsZgkAdySB16G4SMHrhpBu/parachains.png)\n\nY empieza a producir bloques.\n\n![relay3](https://ipfs.io/ipfs/QmR9Tj86yPkrXQsSwereJwqDxsZgkAdySB16G4SMHrhpBu/parachains2.png)\n\nComo siguiente paso, creemos un canal HRMP para pasar mensajes entre parachains. Usaré la llamada del módulo `sudo` en la página de la relay chain.\n\n![hrmp](https://ipfs.io/ipfs/QmR9Tj86yPkrXQsSwereJwqDxsZgkAdySB16G4SMHrhpBu/hrmp.png)\n\nCuando se crea el canal, las llamadas XCM están disponibles. Usemos la paleta `datalogXcm`, una versión XCM de la paleta de `datalog`.\n\n![datalogXcmSend](https://ipfs.io/ipfs/QmR9Tj86yPkrXQsSwereJwqDxsZgkAdySB16G4SMHrhpBu/datalogXcmSend.png)\n\nComo resultado, el mensaje en el segundo parachain llamará a la paleta de `datalog` y escribirá los datos en la cadena.\n\n![datalogXcmRecv](https://ipfs.io/ipfs/QmR9Tj86yPkrXQsSwereJwqDxsZgkAdySB16G4SMHrhpBu/datalogXcmRecv.png)\n\nComo resultado, este ejemplo demuestra cómo se podría utilizar XCM para el uso de cadenas cruzadas de palets estándar de robonomics.\n"}},{node:{id:"f5829d6bd28b4b4102d737deea5a7fdf",title:"Lección 3, Robonomics IO en la Practica",path:"/docs/es/wschool2021-robonomics-io-in-practice/",content:'import Asciinema from \'~/components/Asciinema.vue\'\n\n## Requirements\n\n* the Docker is required, please [install](https://docs.docker.com/engine/install/) it first.\n* the [Nova SDS011](https://aqicn.org/sensor/sds011) sensor is *optional*.\n\n### SDS011 check (optional)\n\nIf you have connected SDS011 sensor then please check that it presented in `/dev` and have correct access rights.\n\n<Asciinema vid="WCFcx8C6M8e52UKDNei1xZloU"/>\n\n## Quick start\n\nWhen docker is installed let\'s launch robonomics docker image from [Official repository](https://hub.docker.com/r/robonomics/robonomics). I\'ll use `winter-school` tag during this lesson.\n\n<Asciinema vid="wM43jozIVfcRmt52ENrJ6yPlH"/>\n\nWhen docker image is ready let\'s try to read a data using `robonomics io` command (optiona if you have SDS011 device).\n\n<Asciinema vid="iztt22tKGaV8wq3cMXY1oUEYv"/>\n\nIf you have no SDS011 sensor then feel free to use virtual SDS011 sensor available in the same docker container via `vsds011.sh`. And everywhere in folloding command please use it as transparent replacement for physical sensor.\n\n<Asciinema vid="GCkSiJBA1DgpLAAHiMhIOSpgG"/>\n\nThe Robonomics IO subsystem have two kind of commands:\n\n* `read` - get data from device that support read access;\n* `write` - write data into device that support write access.\n\nSome devices support them both, in that case devices presented in both command arguments.\n\n> For example, virtual device `ipfs` supports `read` data from IPFS by hash as same as `write` data into IPFS.\n\nFull list of supported devices is possible to get running `robonomics io read` or `robonomics io write` without arguments.\n\n## IPFS access\n\nOn next step runned IPFS daemon is required. For this purpose let\'s run init IPFS and run daemon on dedicated\nterminal tab.\n\n<Asciinema vid="ir6ziXSBUDrRltTmNxg7sdXVY"/>\n\nWhen daemon launched is possible to connect docker image in separate tab and use `robonomics io` for writing and reading a data.\n\n<Asciinema vid="ZtwcmpB9Lhum2Sc221QmNwHG4"/>\n\nThe output forwarding is also works here, that means it\'s possible to forward SDS011 sensor data into IPFS using `|` (pipe) symbol in console. Let\'s try to do it.\n\n<Asciinema vid="XS0QESWG7f8ELsQe1bGQllb9O"/>\n\nWhere JSON data from SDS011 forwarded as input for IPFS writer and result is published on stdout.\n\nThis approach permits engineer extrimely quickly make a simple program just combine a primitive readers and writers from `robonomics io` tools.\n\n```bash\nrobonomics io read sds011 | gz | robonomics io write pubsub my-sensor-data\n```\n\n## Robonomics Datalog\n\n> The target of Robonomics [Datalog](https://crates.robonomics.network/robonomics_protocol/datalog/index.html) is data blockchainization. This pallet provides function to store custom data on blockchain to make it immutable, impossible to change in future.\n\nFor the final part of this lesson runned robonomics node is required. Development mode is preffered because of quick block time and already distributed balances on preset accounts. Let\'s launch it on separate terminal tab in the same container.\n\n<Asciinema vid="QnN9l0sdaZZOyK9ah0DntvCXt"/>\n\nThen private seed also required as argument for `datalog` device. This seed is used to sign transaction and presents account as a sender. Let\'s generate it using embedded `robonomics key` command.\n\n<Asciinema vid="4Cdfl9F0GgjNWv1c1ZcTBBktF"/>\n\nSave generated address and seed on safe place for use it later.\n\nCurrently address balance is zero and the network don\'t permits to send transactions from this address. To fix it let\'s transfer a bit of tokens from `Alice` account. I\'ll use Robonomics Portal on https://parachain.robonomics.network connected to local node with address `ws://127.0.0.1:9944`.\n\n![portal transfer](https://ipfs.io/ipfs/QmbpArfthyor5wFWRexgPAyjK7GaFduasc1eoReaf9TpJg/tran.png)\n\nAnd then `datalog` device could be used for saving any data on blockchain. The key `-s` is used to set secret seed of account. Account should have non-zero balance to send transactions.\n\n<Asciinema vid="FzERH9TmFB8oRuas8ZU202Pv8"/>\n\nIf every thing is correct the you should see `Datalog` event on `Explorer` page of Robonomics portal.\n\n![portal datalog](https://ipfs.io/ipfs/QmbpArfthyor5wFWRexgPAyjK7GaFduasc1eoReaf9TpJg/datalog.png)\n\nThe final step is a bit complex but it\'s good to try use all knowledge of this lesson. Let\'s make a simple program\nthat collects data from SDS011 sensor (or file), pack it into IPFS and then send `datalog` transaction to save hash on blockchain.\n\n```\nSDS011 -> IPFS -> Blockchain\n```\n\nIt\'s easy to implement using Robonomics IO, let\'s do that.\n\n<Asciinema vid="MTpiawGo8DKEn081OozbYb5mU"/>\n\nIf everything well the `Datalog` event with IPFS hash should be presented.\n\n![portal datalog complex](https://ipfs.io/ipfs/QmbpArfthyor5wFWRexgPAyjK7GaFduasc1eoReaf9TpJg/datalog_complex.png)\n\n> Contributor [@Akru](https://github.com/akru)'}},{node:{id:"9800d77dd1aeccee1d01b7734403051a",title:"Lección 2, Robonomics Github Descripción General",path:"/docs/es/wschool2021-robonomics-github-overview/",content:"\n## Paso 1: Instalación de AIRA en VirtualBox\n\nhttps://youtu.be/ISKilRfY3Ow\n\n[Instrucción de texto](/docs/aira-installation-on-vb/)\n\n## Paso 2: Conexión de Aira a través de SSH\n\nhttps://youtu.be/W0rOcRA2sEc\n\n[Instrucción de texto](/docs/aira-connecting-via-ssh/)\n\n## Paso 3: Interactuar con AIRA\n\nhttps://youtu.be/fhRTF2mddfU\n\n[Instrucción de texto](/docs/interact-with-aira/)"}},{node:{id:"135f37f39d7e38b3873a5e4a29d08652",title:"Robonomics Winter School 2021 Introducción y Ceremonia de Apertura",path:"/docs/es/wschool2021-intro/",content:"\nRobonomics Winter School 2021 se llevo a cabo del 10 al 24 de febrero de manera online y gratis. Para mas información del evento entren al siguiente link con toda la información de Robonomics Winter School 2021: [Robonomics Winter School 2021](https://medium.com/robonomics-espa%C3%B1ol/robonomics-winter-school-2021-1ce2d37fb158)\n\nSe publican las lecciones en línea de diferentes maneras: texto en Wiki, video en nuestro [canal de YouTube](https://www.youtube.com/channel/UCrSiho1uB-1n6F8cZpCLhjQ), anuncio en la cuenta de [Twitter](https://twitter.com/AIRA_Robonomics). Por favor, tenga en cuenta que las lecciones en video y las lecciones de texto no son lo mismo.  \n\nÚnase a nosotros, siga sus pasos a través de las lecciones, discuta y haga preguntas en [Discord](https://discord.gg/5UWNGNaAUf).\n\n## Miren la Ceremonia de Apertura\n\nhttp://www.youtube.com/watch?v=kQaSwNYHJQ8\n\n## Enlaces de contacto\n\nUnete a la Comunidad en Español de Robonomics: [https://t.me/RobonomicsESP](https://t.me/RobonomicsESP)  \n\nTelegram: [t.me/robonomics](http://t.me/robonomics)  \nTwitter: [twitter.com/aira_robonomics](http://twitter.com/aira_robonomics)  \nFacebook: [facebook.com/aira.robobomics](http://facebook.com/aira.robobomics)  \nInstagram: [instagram.com/aira_robonomics](http://instagram.com/aira_robonomics)  \nForum: [discourse.robonomics.network](http://discourse.robonomics.network/)  \nReddit: [reddit.com/r/robonomics](http://reddit.com/r/robonomics)  \nYoutube: [youtube.com/c/airalab](http://youtube.com/c/airalab)  \nGithub: [github.com/airalab](http://github.com/airalab)  \nMedium: [blog.aira.life](http://blog.aira.life/)"}},{node:{id:"1bd1698fe196417fbb72ea478d18368a",title:"Lección 5, Conectividad",path:"/docs/es/wschool2021-connectivity-service/",content:'\n## IoT como un pie multiple\n\n* Software del dispositivo\n    * FreeRTOS\n    * ESP/Arduino\n    * Computadoras de placa única (RPi, LattePanda, etc.)\n* Conectividad\n    * IoT Hub\n    * IoT Manager\n* Servicios analíticos\n    * AWS\n    * Google Cloud IoT Core\n    * ThingsBoard\n\nComo regla general, la mayoría no está interesada en sensores y servidores, sino en análisis de datos. Para obtenerlo, debe decidir qué dispositivo usar, cómo trabajar con él y dónde conectarse.\n\n## Software del Dispositivo\n\nConsidere el ejemplo de una estación meteorológica doméstica. Es necesario recopilar datos sobre contaminación atmosférica (SDS011), temperatura y humedad (BME). El microcontrolador ESP8266 puede manejar esta tarea.\n\nRequisitos:\n\n* Leer correctamente los datos de los sensores\n* Tener un identificador único\n* Transferir datos a un servidor conocido\n* Proporcionar firma digital de datos (opcional)\n\nPuede encontrar el firmware actual [aquí](https://github.com/LoSk-p/sensors-software/tree/366b19bf447a5fc19220ef89eab0f2440f8db1c2).\n\n## Que es Conectividad?\n\nEn el mundo de IoT, la conectividad se refiere a la conexión de varios dispositivos de IoT a Internet para enviar datos y/o controlar el dispositivo.\n\nLas soluciones arquitectónicas conocidas se pueden dividir aproximadamente en 3 grupos:\n\n* Totalmente descentralizado. Por ejemplo, los dispositivos están conectados por una red de malla. No apto para redes de área extensa debido a los altos requisitos de hardware.\n* Centralizado. Por ejemplo, AWS. Proporciona un único punto de entrada y facilidad de conexión, pero existe un alto riesgo de falla en caso de problemas con el servidor.\n* Híbrido. Por ejemplo, [Robonomics Connectivity](https://github.com/airalab/sensors-connectivity). Proporciona una dirección para dispositivos en una red “local” y publica datos en un canal de mensajes IPFS distribuido.\n\n## Comparison of AWS and Robonomics Connectivity\n\n| Management services \t| AWS                               \t|               Robonomics              \t|\n|---------------------\t|-----------------------------------\t|---------------------------------------\t|\n| Transaction type    \t| Technical                         \t| Technical and economic                \t|\n| Security            \t| IT-company cloud control          \t| Polkadot and Ethereum                 \t|\n| Protocol            \t| HTTPS, MQTT                       \t| IPFS, Robonomics                      \t|\n| Ecosystem           \t| Private                           \t| Shared                                \t|\n| Access to DeFi      \t| No                                \t| Yes                                   \t|\n| Costs               \t| Pushing data - $1-2 a sensor      \t| Pushing data - $0                     \t|\n|                     \t| Shadow         - from $10 a month \t| Digital Twin    - $0,01 a transaction \t|\n\n## Instalación de Conectividad en AIRA\n\nhttps://www.youtube.com/watch?v=JbBNMHAzJKM\n\n### Requerimientos\n\n* [VirtualBox 6.1 o superior](https://www.virtualbox.org/wiki/Downloads) and above\n* [Aira OS ova image](https://static.aira.life/ova/airaos-21.03_robonomics-winter-school.ova)\n\nImporte la Aira Image en VirtualBox como se describe [aquí](/docs/aira-installation-on-vb/)\n\nConfigurar una conexión a través de [SSH](/docs/aira-connecting-via-ssh/)\n\nCuando todo esté configurado e inicie sesión con éxito a través de SSH, clonemos el paquete principal y compilemos.\n\n```\ngit clone https://github.com/airalab/sensors-connectivity\ncd sensors-connectivity\nnix build -f release.nix\n```\n\nAhora creemos una copia del archivo de configuración predeterminado para su uso posterior. Para conocer todas las opciones, consulte [este artículo]((/docs/configuration-options-description/). Luego lanza el paquete con `roslaunch`.\n\n```\ncp config/default.json config/my.json\nsource result/setup.zsh\nroslaunch sensors_connectivity agent.launch config:=$PWD/config/my.json\n```\n\n## Conectar el Sensor a la Conectividad\n\nhttps://www.youtube.com/watch?v=yxqxBk-6bpI\n\n### Requerimientos\n\n* [Nova SDS011](https://aqicn.org/sensor/sds011) sensor \n* [Yarn Packet Manager](https://yarnpkg.com/getting-started/install)\n\nAhora conectemos un sensor real, enviemos el puerto USB a la máquina virtual, configuremos un mapa y miremos nuestras propias medidas.\n\nPrimero, detenga el AIRA OS si se estaba ejecutando y agregue un dispositivo USB correspondiente.\n\n![VB USB Forwarding](../images/vb_forward_usb.jpg)\n\nInicie la VM, conéctese a través de SSH y configure la opción de `comstation/port` de acuerdo con su dispositivo USB en la VM. También habilite la `comstation` y configure su latitud y longitud. Al final, `config/my.json` debería verse así:\n\n```\n{\n   "general":{\n      "publish_interval":30\n   },\n   "comstation":{\n      "enable":true,\n      "port":"/dev/ttyUSB0",\n      "work_period":0,\n      "geo":"59.944917,30.294558",\n      "public_key":""\n   },\n   "httpstation":{\n      "enable":false,\n      "port":8001\n   },\n   "mqttstation": {\n      "enable": false,\n      "host": "connectivity.robonomics.network",\n      "port": 1883\n   },\n   "luftdaten":{\n      "enable":false\n   },\n   "robonomics":{\n      "enable":true,\n      "ipfs_provider":"/ip4/127.0.0.1/tcp/5001/http",\n      "ipfs_topic":"airalab.lighthouse.5.robonomics.eth"\n   },\n   "datalog":{\n      "enable":false,\n      "path":"",\n      "suri":"",\n      "remote":"wss://substrate.ipci.io",\n      "dump_interval":3600,\n      "temporal_username":"",\n      "temporal_password":""\n   },\n   "dev":{\n      "sentry":""\n   }\n}\n```\n\n> Si no tiene un sensor real, puede usar el script de `sensors-connectivity/utils/virtual-sensor.py` para emular uno.\n> \n> Habilite `HTTPStation` y deshabilite `COMStation` cambiando el archivo de configuración como:\n> ```\n> {\n>    "general":{\n>       "publish_interval":30\n>    },\n>    "comstation":{\n>       "enable":false,\n>       "port":"/dev/ttyUSB0",\n>       "work_period":0,\n>       "geo":"59.944917,30.294558",\n>       "public_key":""\n>    },\n>    "httpstation":{\n>       "enable":true,\n>       "port":8001\n>    },\n>    ...\n> }\n> ```\n>\n> y el lanzamiento de `utils/virtual-sensor.py` en una terminal dedicada en la VM.  \n\nGuarde el archivo e inicie la conectividad desde la carpeta de `sensors-connectivity`:\n\n```\nsource result/setup.zsh\nroslaunch sensors_connectivity agent.launch config:=$PWD/config/my.json\n```\n\nDebería ver las primeras medidas en la salida de la consola\n\nBusque su ID de IPFS en la VM. Aparece justo después de iniciar la imagen o mediante el comando `ipfs id`. Lo necesitaremos más tarde.\n\nAhora configuremos nuestra propia instancia del mapa. En su computadora portátil (no en la VM), clone [este](https://github.com/airalab/sensors.robonomics.network) repositorio y compile la aplicación:\n\n```\ngit clone https://github.com/airalab/sensors.robonomics.network\ncd sensors.robonomics.network\nyarn install\n```\n\nEdite el archivo `src/agents.json` y ponga su ID de IPFS. Por ejemplo:\n\n```\n[\n  "12D3KooWSCFAD3Lpew1HijniE6oFTuo4jsMwHzF87wNnXkpCRYWn"\n]\n```\n\nLanzar el mapa:\n\n```\nyarn serve\n```\n\nVaya a [http://localhost:8080/](http://localhost:8080/) o la dirección que le dio el hilo y busque el sensor.\n\n## Practice\n\n### Trajectory 1. Flash a sensor ESP + SDS011\n\nRequirements:\n\n* ESP8266\n* At least one of sensors SDS011, BME280, HTU21D\n\nUse the [instruction](https://wiki.robonomics.network/docs/connect-sensor-to-robonomics/) to connect a sensor to Robonomics Connectivity. \n\nCheck that your sensor appears on our [map](https://sensors.robonomics.network/#/).\n\n### Trajectory 2. Launch Connectivity\n\nRequirements:\n\n* ROS\n* Python\n* Nix (optional)\n\nBuild and launch [sensors-connectivity](https://github.com/airalab/sensors-connectivity#get-a-package-and-build)\n\n> How it build, install [here](https://wiki.robonomics.network/docs/iot-sensors-connectivity/) and configure [here](https://wiki.robonomics.network/docs/configuration-options-description/)\n\nGeneral scheme of the package:\n\n```\n    station1 \\                        / feeder1\n    station2 -  sensors-connectivity  - feeder2\n    station3 /                        \\ feeder3\n```\n\nThe choice is proposed to implement either a new station, for example, a random number generator, or a new feeder, for example, displaying a string on the screen.\n\nInterface `IStation` [here](https://github.com/airalab/sensors-connectivity/blob/master/src/stations/istation.py#L73).\n\nInterface `IFeeder` [here](https://github.com/airalab/sensors-connectivity/blob/master/src/feeders/ifeeder.py#L5)\n\n\n'}},{node:{id:"e19b2ca25ff47f01fecbeee99d41c4dc",title:"Lección 1, Conectar la robótica a la dapp",path:"/docs/es/wschool2021-connect-robotics-to-user-app/",content:"\nhttps://youtu.be/NOQxyojvaao\n\n- [Instrucción de texto](/docs/get-weather-on-fuji-mountain/)\n- [Dapp](https://dapp.robonomics.network/#/)"}},{node:{id:"71bffb0a71c38c4beece48d97290cd82",title:"Build IoT Dapps For End Users, part 2",path:"/docs/es/wschool2021-build-dapp-interface/",content:'\n![Building User Interface for Decentralized Applications, on top of Robonomics and Polkadot](../images/build-dapp-interface/sum.gif "Building User Interface for Decentralized Applications, on top of Robonomics and Polkadot")\n\n## Introduction\n\nThis tutorial continues the previous lesson, where you have already built simple application and were focused on connecting an account to a node, sending transactions and other vital functions of the dapp. Now we will **build user-friendly interface** for this application.\n\n## Prerequisites\n\nThis tutorial is designed for people who are familiar with **HTML, CSS, JavaScript** a bit and want to learn how to apply these skills for decentralized applications.\n\nFor building your dapp\'s interface you can choose any JavaScript framework which is comfortable for you or even try to build interface without any framework. In Robonomics 2021 we use [Vue.js](https://vuejs.org) as it is quite scalable and easy to use.\n\n## Set up for this tutorial\n\nIf you start with this step and prefer to **learn by doing**, please, follow this to-do list to launch the resulting dapp from the previous lesson:\n\n1. Download a local Robonomics node from [releases page](https://github.com/airalab/robonomics/releases/) that fits your OS. If you do not find your system in the latest release, please, find the most recent version in the previous releases.\n\n2. Launch the Robononomics node in the Developer mode by typing `./robonomics --dev` in your terminal.\n\n3. Download the Polkadot Extension for Chrome or Firefox [here](https://polkadot.js.org/extension/)\n\n4. Clone [this repository](https://github.com/vol4tim/example-robonomics-dapp/).\n\n5. Install [Yarn](https://yarnpkg.com).\n\n6. Install [@vue/cli](https://cli.vuejs.org/guide/installation.html)\n\n7. Start developing dapp with `yarn serve` command in your terminal.\n\n\n**You should get this screen in your browser:**\n\n![Dapp Start](../images/build-dapp-interface/dapp-start.png "Dapp Start")\n\n\n<details>\n\n  <summary>Some additional tips for launching</summary>\n\n  - Make sure your **node is running**:\n    ![Example of running a Robonomics node](../images/build-dapp-interface/robonomics-node-launch.png "Example of running Robonomics node")\n\n  - In **macOS** you may need to change the **access permissions** `chmod +x robonomics`\n\n  - Make sure you allowed **access for Polkadot Extension**:\n    ![Polkadot Extension giving access](../images/build-dapp-interface/polkadot-permission.png "Polkadot Extension giving access")\n\n  - If you have errors in log of the running node and dapp is not loading correctly, please, try to delete data base of dev chain: `sudo rm -rf <YOUR LOCAL PATH>/robonomics/chains/dev/db/` and restart the node. If it does not help, restart your machine.\n\n</details>\n\n## Inspecting the code\n\nLet\'s inspect the structure of the dapp to clear up what and where we can fix in order to change UI.\n\n```\n.\n├── public/\n│   ├── favicon.ico           # Icon for your dapp\n│   └── index.html            # The template file (injects icons links, JavaScript and CSS files for the app)\n├── src/\n│   ├── assets/               # Folder for images and global styles\n│   ├── components/           # Folder with components\n│   │   ├── Datalog.vue       # Tab \'Datalog\' in dapp\n│   │   ├── Demo.vue          # Tab \'Demo\' in dapp\n│   │   ├── Launch.vue        # Tab \'Launch\' in dapp\n│   ├── utils/                # Folder with important for app js functions (we will touch api.js in this tutorial)\n│   ├── App.vue               # The root of our app, contains HTML, CSS, JS for the whole page. In fact it is Vue Component also\n│   ├── main.js               # The app’s entry file, we will import here global styles\n├── ...                       # There are config files and dependencies files, that we will not change mannually\n├── README.md                 # You can write here any instructions for your dapp\n\n```\n\n> **The code of this tutorial is in this [repository](https://github.com/positivecrash/wscool21-ui-dapp)**\n\n## CSS-in-JS VS. Global stylesheets\n\nIn this tutorial I show how to change the interface of a small dapp from scratch without any stable library of UI components. So I will import and create not only different Vue components, but also write my own styles.\n\nIf your application is big or your project has the whole bunch of dapps, in future you\'d better look for building library of components specifically for your project to make UI more organized and efficient ([for example, here is a tool for organizing components](https://storybook.js.org)). Or if you are okay with standart interface themes, you can use any UI Libraries of third party ([for example](https://vuetifyjs.com/)).\n\n## First import or where to start\n\nI don\'t have any specific design for this dapp, but I have [Brandbook](https://static.robonomics.network/assets/Robonomics-Visual-Identity.pdf) and [quit well-established](https://robonomics.network) typography, fonts, button styles etc. So for the start I will import the following css files globally:\n\n```\n...\n├── src/\n│   ├── assets/\n│   │   ├── styles/\n│   │   │   ├── reset.css         # The goal is to reduce browser inconsistencies\n│   │   │   ├── variables.css     # Contains specific values to be reused such as colors, font-names, space values etc.\n│   │   │   ├── typography.css    # Global typography for the whole dapp\n│   │   │   ├── animation.css     # Keyframe animations used throughout the dapp\n...\n\n```\n\nThe content of any of these files you can write in App.vue instead, if it fits your perception better. But I recommend to import some CSS files globally for this example to keep App.vue a little bit more clear.\n\nImport these CSS files into your app by editing **main.js** file:\n\n![Import global CSS in Vue app](../images/build-dapp-interface/import-css-vue-1.png "Import global CSS in Vue app")\n\n```JS\nimport \'./assets/styles/reset.css\'\nimport \'./assets/styles/variables.css\'\nimport \'./assets/styles/typography.css\'\nimport \'./assets/styles/animation.css\'\n```\n\n**Check if fonts have been changed in the dapp:**\n\n![Dapp Interface changing step 1](../images/build-dapp-interface/dapp-1.png "Dapp Interface changing step 1")\n\n\n## Change layout and prettify the title\n\nLet\'s change layout of the application. As I mentioned earlier, you can write your styles directly in App.vue, but for this example I prefer to separate this process.\n\n- Comment or delete styles from tag `<style>` in **App.vue**\n\n- Create css file **app.css** in styles folder for this application and import it into **main.js**\n\n```JS\nimport \'./assets/styles/app.css\'\n```\n\n<details>\n\n<summary>Write in app.css first basic styles for the app:</summary>\n\n```css\n#app {\n  display: grid;\n  grid-template-rows: auto 1fr;\n  align-items: stretch;\n\n  text-align: center;\n}\n\nbody {\n  background-color: var(--color-gray-light);\n}\n```\n\n</details>\n\n\n<details>\n\n<summary>Change the title of the app [App.vue]</summary>\n\n```html\n<div class="top">\n    <h1>dApp Robonomics Demo</h1>\n    <i>Winter School 2021</i>\n    <img class="label" alt="" src="./assets/images/robonomics-winter-school-2021-logo.png"/>\n</div>\n```\n\n</details>\n\n\n\n<details>\n\n<summary>Write styles for the title [app.css]</summary>\n\n```css\n.top {\n  position: relative;\n  padding-top: var(--space);\n  padding-bottom: calc(var(--space)*2);\n\n  border-bottom: 2px solid var(--color-dark);\n  background-color: var(--color-light);\n}\n\n.top h1 {\n  font-size: 1.8rem;\n}\n\n.top i {\n  display: block;\n}\n\n.top .loader-label {\n  display: block;\n  margin: calc(var(--space)/3) auto;\n  max-width: 150px;\n\n  visibility: hidden;\n  opacity: 0;\n  animation: 0.5s FadeIn 0.3s ease forwards, 0.5s ScaleDown 0.1s ease forwards;\n}\n\n.top .label {\n  position: absolute;\n  width: 100px;\n  bottom: -50px;\n  left: calc(50% - 50px);\n  display: block;\n\n  transform: translateY(1rem);\n  visibility: hidden;\n  opacity: 0;\n  animation: 0.7s FadeIn 0.5s ease forwards, 1s ScaleUp 0.5s ease forwards;\n}\n```\n\n</details>\n\n- Place a file with the logo of the Robonomics winter school 2021 in the folder **./src/assets/images**\n\n**You will get the following screen:**\n![Dapp Interface changing step 2](../images/build-dapp-interface/dapp-2.png "Dapp Interface changing step 2")\n\n## Define styles according to the dapp\'s data\n\nNow I will wrap the app\'s content in `<div>` element. Also I will need different styles for different states of the dapp (loaded or not loaded).\n\n- Open the **App.vue** and write a wrapping element:\n```html\n<div class="content">\n  \x3c!--here is everything going after the title--\x3e\n</div>\n```\n- Find the variable `load`, it has already been defined in `<script>`.\n- Pass an object to `v-bind:class` to dynamically toggle classes (I use shortened version `:class`):\n```html\n<div class="content" :class="{ load: load }">\n  \x3c!--here is everything going after the title--\x3e\n</div>\n```\nThat\'s how you can easily toggle styles in your app according to the data you get. You will see the usage of this class below.\n\n## Define views according to the dapp\'s data\n\nLet\'s change the loader for the app.\n- For this purpose I will import my component from another Robonomics project \n\n<details>\n\n<summary>./src/components/AnimatedRobonomicsLogo.vue</summary>\n\n```HTML\n<template>\n  <div class="logo-animated" :style="{transform: \'scale(\'+scale+\')\'}">\n      <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="196.9px" height="170.3px" viewBox="0 0 196.9 170.3" style="enable-background:new 0 0 196.9 170.3;" xml:space="preserve">\n\t\t<g transform="translate(2530 155)">\n            <path class="line" d="M-2523.4,7.9l184.2,0.5l-91.7-158.1L-2523.4,7.9z"/>\n\n            <circle class="dot" cx="-2339.7" cy="8.7" r="6.6"/>\n            <circle class="dot" cx="-2523.4" cy="8.2" r="6.6"/>\n            <circle class="dot" cx="-2430.8" cy="-148.4" r="6.6"/>\n            \n            <path class="triangle-1" d="M-2477.3-18.3l92.1,0.3l-45.8-79L-2477.3-18.3z"/>\n            <path class="triangle-2" d="M-2431.2-18.1l46,0.1l-45.8-79L-2431.2-18.1z"/>\n            <path class="triangle-3" d="M-2477.3-18.3l92.1,0.3l-46-20.3L-2477.3-18.3z"/>\n          </g>\n\t</svg>\n  </div>\n</template>\n\n<script>\n\nexport default {\n\n  props: {\n    scale: {\n      type: String,\n      default: \'1\'\n    },\n  },\n\n};\n<\/script>\n\n<style scoped>\n    /*\n    Global styles required:\n    FadeIn - keyframe animation from animation: .css\n    all --color- variables from variables.css\n    */\n\n    .logo-animated {\n        transform-origin: 0 0;\n    }\n\n    .logo-animated .dot {\n        fill: var(--color-blue);\n        visibility: hidden;\n        opacity: 0;\n        animation: 1s FadeIn 0.3s ease forwards;\n    }\n\n    .logo-animated .line {\n        fill: transparent;\n        stroke: var(--color-blue);\n        stroke-miterlimit:10;\n        stroke-dasharray: 700;\n        stroke-dashoffset: 700;\n        animation: 1s DrawSvgPath 0.5s ease-in-out forwards; \n    }\n\n    .logo-animated .triangle-1 {\n        fill: var(--color-blue);\n        visibility: hidden;\n        opacity: 0;\n        animation: 0.5s FadeIn 0.3s ease forwards, 5s logo-triangle-1 0.1s linear infinite;\n    }\n\n    .triangle-2 {\n        fill: var(--color-violet-light);\n        visibility: hidden;\n        opacity: 0;\n        animation: 0.5s FadeIn 0.3s ease forwards, 5s logo-triangle-2 0.1s linear infinite;\n    }\n\n    .triangle-3 {\n        fill: var(--color-violet-mid);\n        visibility: hidden;\n        opacity: 0;\n        animation: 0.5s FadeIn 0.3s ease forwards, 5s logo-triangle-3 0.1s linear infinite;\n    }\n\n\n    @keyframes DrawSvgPath\n        {\n        to {\n            stroke-dashoffset: 0;\n        }\n        }\n\n    @keyframes logo-triangle-1\n    {\n        0% { fill: var(--color-blue); }\n        25% { fill: var(--color-blue); }\n        50% { fill: var(--color-blue); }\n        75% { fill: var(--color-violet-light); }\n        100% { fill: var(--color-blue); }\n    }\n\n    @keyframes logo-triangle-2\n    {\n        0% { fill: var(--color-violet-light); }\n        25% { fill: #E0BDED; }\n        50% { fill: var(--color-blue); }\n        75% { fill: var(--color-blue); }\n        100% { fill: var(--color-violet-light); }\n    }\n\n    @keyframes logo-triangle-3\n    {\n        0% { fill: var(--color-violet-mid); }\n        25% { fill: var(--color-violet-light); }\n        50% { fill: var(--color-violet-light); }\n        75% { fill: var(--color-violet-dark); }\n        100% { fill: var(--color-violet-mid); }\n    }\n</style>\n```\n\n</details>\n\n- Register this component in **App.vue**\n```JS\nexport default {\n  components: {\n    Loader: () => import("./components/AnimatedRobonomicsLogo")\n  }\n}\n```\n- Insert it with conditional Vue directive `v-if`, using the already known variable `load`:\n```HTML\n<div class="content" :class="{ load: load }">\n  <Loader v-if="load" />\n  <template v-else>\n    \x3c!-- here will be main content of loaded dapp --\x3e\n  </template>\n</div>\n```\n- Watch the result in browser. It has some issues that we will fix now:\n\n1. Loader pops up to the title (it should be in the center). Let\'s insert these lines to **app.css**:\n```css\nbody, html, #app {\n  height: 100%;\n  position: relative;\n}\n```\n2. If your connection goes too fast, you will see just blinking loader for a moment. It may confuse a lot. Let\'s set a timeout for the app\'s responce. To do that open **api.js** and find in the function `initAccount` this code:\n```JS\nconst timeout = new Promise(resolve => {\n  setTimeout(resolve, 300);\n});\n```\nI set `1700` instead of `300` and check the result:\n\n![Dapp Interface changing step 3](../images/build-dapp-interface/dapp-3.gif "Dapp Interface changing step 3")\n\n\n## Using reusable components\n\nYou have already watched how to register and use a component in the previous section about Loader, but now I want to focus on it more carefully.\n\nLet\'s change the Account section. Here I will use self-written components (box, button, icon) and the third party\'s one ([from Vue Polkadot Library](https://vue-polkadot.js.org/vue-ui/vue-identicon/#vue-polkadot-vue-identicon )).\n\n### Adding the box\n\n<details>\n\n<summary>Create Box component in ./src/components/Box.vue file </summary>\n\n```HTML\n<template>\n    <section class="box" :class="classList">\n        <slot />\n    </section>\n</template>\n\n<script>\n\nexport default {\n\n  props: {\n    classList: {\n      type: String\n    },\n  },\n\n};\n<\/script>\n\n<style>\n    /*\n    Global styles required for css variables from variables.css\n    */\n\n    .box {\n        background-color: var(--color-light);\n        border: 1px solid var(--color-dark);\n        padding: calc(var(--space)*0.5) var(--space);\n        box-shadow: 2px 2px 0 var(--color-dark);\n        margin-bottom: calc(var(--space)*1.5);\n    }\n</style>\n```\n</details>\n\nNow we can use it many times throught out the dapp. Let\'s see this on the Account section example:\n\n- Register component (**App.vue**):\n\n```JS\nexport default {\n  components: {\n    Box: () => import("./components/Box")\n  }\n}\n```\n\n- Use it for the Account section with an additional class passed with prop `classList`:\n\n```HTML\n<Box :classList="\'account\'">\n  Account: <b>{{ account }}</b> {{ balance }} |\n  <button @click="faucet">\n    faucet\n  </button>\n</Box>\n```\n\n**Check the result:**\n![Dapp Interface changing step 4](../images/build-dapp-interface/dapp-4.png "Dapp Interface changing step 4")\n\n### Adding the button\n\nYou may even not notice the button in the box that we have added. Let\'s fix it and add a component for buttons as it is not the only button in the app.\n\n<details>\n\n<summary>Create Button component in ./src/components/Button.vue file </summary>\n\n```HTML\n<template>\n  <button type="button" :class="classList" @click="onClick" :disabled="disabled" class="inline-block">\n    {{ label }}\n  </button>\n</template>\n\n<script>\n\nexport default {\n\n  components: {\n    Icon: () => import("./Icon")\n  },\n\n  props: {\n    label: {\n      type: String,\n    },\n    type: {\n      type: String,\n      default: \'primary\',\n      validator: function (value) {\n        return [\'primary\', \'secondary\'].indexOf(value) !== -1;\n      }\n    },\n    disabled: {\n      type: Boolean,\n      default: false,\n    },\n    size: {\n      type: String,\n      default: \'medium\',\n      validator: function (value) {\n        return [\'small\', \'medium\', \'large\'].indexOf(value) !== -1;\n      }\n    }\n  },\n\n  computed: {\n    classList() {\n      return {\n        \'button\': true,\n        [`${this.type}`]: true,\n        [`button__${this.size}`]: true,\n      };\n    },\n  },\n\n  methods: {\n    onClick() {\n      this.$emit(\'onClick\');\n    },\n  },\n\n};\n<\/script>\n\n<style>\n    /*\n    Global styles required for css variables from variables.css\n    */\n\n    .button {\n        appearance: none;\n        -webkit-appearance: none;\n        outline: 0;\n        border: 0;\n\n        transition: 0.1s all linear;\n\n        padding: .15rem 0.6rem;\n        border-width: 1px;\n        border-style: solid;\n        border-radius: .25rem;\n  \n        cursor: pointer;\n\n        font-family: var(--font-family);\n        font-size: calc(var(--font-size)*0.9);\n        line-height: 1;\n        font-weight: 500;\n\n        text-transform: uppercase;\n        letter-spacing: 1px;\n    }   \n\n    .button:not([disabled]):hover {\n    filter: saturate(1.5);\n    }\n\n    .button[disabled] {\n        cursor: default;\n        opacity: 0.6;\n    }\n\n    button.primary {\n        border-color: var(--color-green);\n        background-color: var(--color-green);\n        color: var(--color-light);\n    }\n\n    button.secondary {\n        border-color: var(--color-blue);\n        color: var(--color-blue);\n    }\n\n    button.secondary:not([disabled]):hover {\n        background-color: var(--color-blue);\n        color: var(--color-light);\n    }\n\n    .button__small {\n        font-size: .85rem;\n        padding: .1rem 0.45rem;\n    }\n\n    .button__large {\n        font-size: 1.2rem;\n        padding: .5rem 1.7rem;\n    }\n\n</style>\n```\n</details>\n\n\n- Register the component (**App.vue**):\n\n```JS\nexport default {\n  components: {\n    Button: () => import("./components/Button")\n  }\n}\n```\n\n- Use it for the \'Faucet\' button with props defined in the \'Button\' component\n\n```HTML\n<Box :classList="\'account\'">\n  Account: <b>{{ account }}</b> {{ balance }}\n  <Button label="Faucet" size="large" @onClick="faucet" />\n</Box>\n```\n\n**We get this view:**\n![Dapp Interface changing step 5](../images/build-dapp-interface/dapp-5.png "Dapp Interface changing step 5")\n\nFor the Button component we have emited the click from prop with `@onClick`, so I will pay attention if the faucet function is working correctly now (the balance should change on click):\n\n![Dapp Interface changing step 6](../images/build-dapp-interface/dapp-6.gif "Dapp Interface changing step 6")\n\n### Adding the icon\n\nLet\'s add an icon to this button to attract more attention to this element of the interface, as user can\'t interact with the dapp properly without units and clicking on this button.\n\nFor this purpose you can use any ready Vue library for icons, I will create my own component with the icon.\n\n- I found an appropriate icon on [the big online archive of icons](https://www.flaticon.com).\n- Downloaded .svg file and edited it in the vector graphics editor to make the proper size.\n- Inserted svg as a text in the Icon.vue component.\n\n<details>\n\n<summary>Here is what I got as the Icon.vue component</summary>\n\n```JS\n<template>\n  <div class="icon inline-block" :class="classList">\n    <svg v-if="icon == \'faucet\'" class="icon-fill" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" :width="SvgWidth(20)"  viewBox="0 0 20 24.9" style="enable-background:new 0 0 20 24.9;" xml:space="preserve">\n      <path d="M2.7,24.9c0.2,0,2.4,0,2.4-2.4c0-2-2.2-5.2-2.2-5.2s-2.5,3.3-2.5,5.3C0.4,24.6,2.4,24.9,2.7,24.9z M20,10.8V7.2V3.1h-2.6v2.6h-3.1V1.5h2.6c0.4,0,0.8-0.3,0.8-0.8S17.3,0,16.9,0h-6.7C9.8,0,9.5,0.3,9.5,0.8s0.3,0.8,0.8,0.8h2.6v4.1H7.9c-4.7,0-6.2,3.2-6.3,4.8c0,0,0,0.1,0,0.1v2.8H0v2.1h6.2v-2.1H4.6v-2.7c0-0.3,0.4-1.9,3.3-1.9h9.6v2.1L20,10.8L20,10.8z"/>\n    </svg>\n\n  </div>\n</template>\n\n<script>\n\nexport default {\n  props: {\n    icon: {\n      type: String\n    },\n    classList: {\n      type: String\n    },\n    scale: {\n      type: String,\n      default: \'1\'\n    },\n  },\n\n  methods: {\n    SvgWidth(SvgWidth) {\n      return `${SvgWidth * this.scale}px`;\n    }\n  }\n};\n<\/script>\n\n<style>\n.icon {\n    line-height: 1;\n}\n</style>\n\n```\n\n</details>\n\nTo use it with the button, edit the Button component.\n\nImport the Icon in **Button.vue**:\n\n```JS\ncomponents: {\n    Icon: () => import("./Icon")\n}\n```\n\nRegister prop:\n\n```JS\nprops: {\n  icon: {\n    type: String,\n    default: \'none\'\n  }\n}\n```\n\nAdd the Icon to the button (we can specify different templates with `v-if` condition):\n\n```HTML\n<template v-if="icon != \'none\'">\n  <Icon :icon="icon" />\n  <span v-if="label != \'\'" class="inline-block">{{ label }}</span>\n</template>\n<template v-if="icon == \'none\' & label != \'\'">\n  {{ label }}\n</template>\n```\n\nAdd styles:\n\n```CSS\n.button .icon-fill path {\n  fill: var(--color-light);\n}\n\n.button > *:not(:last-child) {\n  margin-right: calc(var(--space)/2);\n}\n\n```\n\nAdd the icon prop into the button in **App.vue**:\n\n```HTML\n<Button label="Faucet" size="large" icon="faucet" @onClick="faucet" />\n```\n\n**Check:**\n\n![Dapp Interface changing step 7](../images/build-dapp-interface/dapp-7.png "Dapp Interface changing step 7")\n\n### Add the Polkadot avatar\n\n- Install [@vue-polkadot/vue-identicon](https://vue-polkadot.js.org/vue-ui/vue-identicon/#vue-polkadot-vue-identicon)\n\n- Import to App.vue:\n```JS\ncomponents: {\n    Identicon: () => import("@vue-polkadot/vue-identicon")\n}\n```\n\n- Insert the avatar instead of the word \'Account\', pass props according to the documentation, use `account` data as a value prop:\n```HTML\n<Identicon\n  :value="account"\n  :theme="\'polkadot\'"\n  :size="40"\n  :class="\'inline-block\'"\n/>\n```\n\n**Check:**\n\n![Dapp Interface changing step 8](../images/build-dapp-interface/dapp-8.png "Dapp Interface changing step 8")\n\n## Data manipulation for the better view\n\nLet\'s cut the account address:\n\n- Wrap the variable `account` in the computed property:\n\n```JS\ncomputed: {\n  AccountAddress() {\n    return this.account.slice(0, 6) + "..." + this.account.slice(-4);\n  }\n}\n```\n\n- Replace the variable `account` with `AccountAddress` in the template\n\n**Check:**\n\n![Dapp Interface changing step 9](../images/build-dapp-interface/dapp-9.png "Dapp Interface changing step 9")\n\n## CSS magic\n\nLet\'s prettify the account section a little bit more:\n\n<details>\n\n<summary>Template</summary>\n\n```HTML\n<Box :classList="\'account\'">\n              \n  <div class="account__address">\n    <Identicon\n      :value="account"\n      :theme="\'polkadot\'"\n      :size="40"\n      :class="\'inline-block\'"\n    />\n\n    <code class="inline-block">{{ AccountAddress }}</code>\n  </div>\n  \n  <div class="account__balance">{{ balance }}</div>\n\n  <Button label="Faucet" size="large" @onClick="faucet" />\n  \n</Box>\n```\n\n</details>\n\n\n<details>\n\n<summary>Styles (in app.css)</summary>\n\n```CSS\n.account {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  align-items: center;\n  justify-items: stretch;\n  column-gap: var(--space);\n}\n\n.account__balance {\n    font-size: 150%;\n    font-weight: 500;\n    font-family: var(--font-family-code);\n    white-space: nowrap;\n}\n\n.account__address > *:not(:last-child) {\n    margin-right: calc(var(--space)/2);\n}\n```\n\n</details>\n\n![Dapp Interface changing step 10](../images/build-dapp-interface/dapp-10.gif "Dapp Interface changing step 10")\n\nLet\'s edit styles for the tabs:\n\n<details>\n\n<summary>Styles (in app.css)</summary>\n\n```CSS\n.tabs {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  margin-top: calc(var(--space)*2.5);\n}\n\n.tabs button {\n  text-transform: uppercase;\n  letter-spacing: 1px;\n  border-width: 0 0 1px;\n  font-family: var(--font-family);\n  font-size: calc(var(--font-size)*1.5);\n  font-weight: 300;\n  cursor: pointer;\n  transition: 0.2s all linear;\n}\n\n.tabs button:not(.active) {\n  opacity: 0.5;\n  border-color: var(--color-gray)\n}\n\n.tabs-content {\n  padding-top: var(--space);\n}\n```\n\n</details>\n\n<details>\n\n<summary>Minimal template changes:</summary>\n\n```HTML\n<div class="tabs-content">\n  <Demo v-if="tab === \'demo\'" :api="api" :account="account" />\n  <Launch v-if="tab === \'launch\'" :api="api" :account="account" />\n  <Datalog v-if="tab === \'datalog\'" :api="api" :account="account" /> \n</div>\n```\n\n</details>\n\n![Dapp Interface changing step 11](../images/build-dapp-interface/dapp-11.gif "Dapp Interface changing step 11")\n\n> Let me remind you that the finished code for this tutorial is in [this](https://github.com/positivecrash/wscool21-ui-dapp) repository. And let\'s shift to the next steps :)\n\n## Datalog\n\nStart with fixing UI elements that are already known in the dapp: buttons (same as we have done for the \'Faucet\', but with different props).\n\nThen I will wrap these elements in `<fieldset>` to separate them by meaning. And I will write my own styles for the fieldset and input elements.\n\n<details>\n\n<summary>Template in Datalog.vue:</summary>\n\n```HTML\n<div class="tools">\n  <fieldset>\n    <Button label="Read data" size="large" type="secondary" @onClick="read" />\n  </fieldset>\n\n  <fieldset>\n    <input v-model="data" :disabled="isWrite" class="large" />\n    <Button label="Write" :disabled="isWrite" size="large" type="secondary" @onClick="write" />\n  </fieldset>\n</div>\n```\n\n</details>\n\n\n<details>\n\n<summary>Styles for input elements in app.css - it\'s supposed to be global:</summary>\n\n```CSS\ninput, select{\n  padding: .3rem 0.6rem;\n  border: 1px solid var(--color-gray);\n  background-color: var(--color-light);\n  border-radius: var(--radius);\n  font-size: var(--font-size);\n  font-family: var(--font-family-code);\n  border-radius: .25rem;\n  transition: 0.2s ease all;\n}\n\ninput:focus {\n  border-color: var(--color-dark);\n}\n\ninput.large, select.large {\n  font-size: 1.2rem;\n  padding: .35rem 1rem;\n}\n\n\n.tools *, .tools fieldset:not(:last-child):after {\n  display: inline-block;\n  vertical-align: middle;\n  vertical-align: -moz-middle-with-baseline;\n  vertical-align: -webkit-baseline-middle;\n}\n\n.tools fieldset {\n  border: 0;\n}\n\n.tools fieldset:not(:last-child):after {\n  content: "•";\n}\n\n.tools fieldset > *,  .tools > * {\n  margin-right: calc(var(--space)/2)\n}\n```\n\n</details>\n\n**Let\'s check that everything works fine after updates:**\n\n![Dapp Interface changing step 12](../images/build-dapp-interface/dapp-12.gif "Dapp Interface changing step 12")\n\nWe have a datalog section through out the dapp, so I\'ll make a component for it.\n\n<details>\n\n<summary>I have got the following code for a new component DatalogSection.vue</summary>\n\n```HTML\n<template>\n    <div v-if="log" class="log">\n        <h4 class="log-title">Datalog</h4>\n\n        <div class="log-content">\n\n          <p v-if="log.length === 0" class="error">Not found</p>\n\n          <details v-for="(item, k) in log" :key="k" class="box" :open="k === 0">\n              <summary>{{ item[0] }}</summary>\n              <pre>{{ item[1] }}</pre>\n          </details>\n        </div>\n    </div>\n</template>\n\n<script>\n\nexport default {\n\n  props: {\n    log: {\n      type: Array\n    }\n  },\n\n}\n\n<\/script>\n\n<style>\n\n.log {\n  text-align: left;\n  margin: var(--space) auto;\n  width: 100%;\n}\n\n.log-content {\n  border: 1px solid var(--color-gray);\n  max-height: 500px;\n  overflow-y: auto;\n  padding: var(--space);\n  background-color: var(--color-gray-middark);\n  outline: 1px solid #fff;\n  box-shadow: 0 0 60px 20px #fff inset;\n}\n\n.log-title {\n  color: var(--color-gray-dark);\n  font-weight: 300;\n  font-family: var(--font-family-code);\n\n  border-bottom: 1px solid var(--color-gray);\n}\n\n.log .box {\n  margin-bottom: var(--space);\n}\n\ndetails {\n  transition: 0.2s all ease;\n}\n\ndetails summary {\n  cursor: pointer;\n}\n\ndetails.box {\n  padding-top: 0;\n  padding-bottom: 0;\n}\n\ndetails.box[open] {\n  padding-bottom: calc(var(--space)*0.5);\n}\n\ndetails.box:focus {\n  box-shadow: 0 0 5px var(--color-gray)\n}\n\ndetails.box summary {\n  padding-top: calc(var(--space)*0.5);\n  padding-bottom: calc(var(--space)*0.5);\n}\n\ndetails.box[open] summary {\n  border-bottom: 1px solid var(--color-dark);\n  margin-bottom: calc(var(--space)*0.5);\n  font-weight: 500;\n}\n\n.log details.box summary {\n  font-family: var(--font-family-code);\n}\n\n</style>\n```\n\n</details>\n\nWhat you should pay attention to here: we pass prop `log` as an array. I assume that this multidimensional array will contain log of entries and every entry has a title (I wrote there date for all logs in the dapp) and content. We need to reformat arrays in components **Datalog.vue** and **Launch.vue**.\n\nNow edit **Datalog.vue**. Find method, where we get the log:\n```JS\nasync read() {\n  this.log = (await this.api.query.datalog.datalog(this.account)).toArray();\n}\n```\n\nNow we have to format data in **Datalog.vue**, and pass ready log array for **DatalogSection.vue**. So let\'s map the log array:\n```JS\nasync read() {\n  this.log = (await this.api.query.datalog.datalog(this.account)).toArray().map((item) => {\n    return [new Date(Number(item[0])).toLocaleString(), u8aToString(item[1])]\n  });\n}\n```\n\nWe don\'t need this code anymore:\n```JS\nfilters: {\n  dateFormat: function(v) {\n    return new Date(Number(v)).toLocaleString();\n  },\n  dataFormat: function(v) {\n    return u8aToString(v);\n  }\n}\n```\n\n**Let\'s check the datalog section in Datalog tab:**\n\n![Dapp Interface changing step 13](../images/build-dapp-interface/dapp-13.gif "Dapp Interface changing step 13")\n\n## Launch\n\nFor this step, most of improvements have already been done, we just need to apply them to the template: import Button and Datalog components, remove the excessive title:\n\n![Dapp Interface changing step 14](../images/build-dapp-interface/dapp-14.gif "Dapp Interface changing step 14")\n\nLet\'s replace `select` control element with `checkbox`.\n\nInstead of this:\n```HTML\n<select v-model="parameter" :disabled="isWrite">\n  <option value="ON">ON</option>\n  <option value="OFF">OFF</option>\n</select>\n```\n\nWrite this:\n```HTML\n<div class="toggler inline-block">\n  <input v-model="parameter" :disabled="isWrite" type="checkbox" id="robot-switch" />\n  <label for="robot-switch"><span></span></label>\n</div>\n```\n\n<details>\n\n<summary>Styles in app.css:</summary>\n\n```CSS\n.toggler input { display: none; }\n.toggler label {\n  position: relative;\n  display: block;\n  width: 60px;\n  height: 40px;\n  border-radius: 4px;\n  font-weight: 500;\n  text-transform: uppercase;\n  letter-spacing: 1px;\n  cursor: pointer;\n  background-color: var(--color-gray);\n  color: var(--color-light);\n  text-align: center;\n}\n\n.toggler label:before {\n  content: \'Off\';\n  width: 100%;\n  text-align: center;\n  line-height: 40px;\n}\n\n.toggler label:after {\n  content: \'\';\n  display: block;\n  width: 6px;\n  height: 100%;\n  border-radius: 10px;\n  background-color: var(--color-gray-dark);\n\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: 10;\n\n  transition: 0.3s ease-out all;\n}\n\n.toggler input:checked + label {\n  background-color: var(--color-green);\n}\n\n.toggler input:checked + label:before {\n  content: \'On\';\n}\n\n.toggler input:checked + label:after {\n  transform: translateX(54px);\n  background-color: #007038;\n}\n```\n\n</details>\n\n![Dapp Interface changing step 15](../images/build-dapp-interface/dapp-15.gif "Dapp Interface changing step 15")\n\nI want to clarify something with the interface: with these elements we start some device. Let\'s visualize it. I\'ve chosen a drone, so I will toggle classes according to `item.parameter`.\n\nCreate a new property in `data`:\n```JS\ndata() {\n  status: false\n}\n```\n\nAssign value of `parameter` to `status` after button is clicked and tx is sent to the block:\n```JS\nmethods: {\n    async launch() {\n      try {\n        this.error = "";\n        this.isWrite = true;\n\n        const tx = await this.api.tx.launch\n          .launch(this.robot, this.parameter === "ON")\n          .signAsync(this.account);\n\n        await tx.send(result => {\n          if (result.status.isInBlock) {\n            this.isWrite = false;\n            this.status = this.parameter; // new line here\n          }\n        });\n      } catch (error) {\n        this.error = error.message;\n        this.isWrite = false;\n      }\n    }\n  }\n```\n\nWrite styles for the drone in **Launch.vue**. Don\'t forget `scoped` for `<style>` tag, to apply styles only for this component.\n\n<details>\n\n<summary>CSS for drone:</summary>\n\n```CSS\n<style scoped>\n.tools {\n  position: relative;\n  padding-left: 120px;\n  text-align: left;\n  display: inline-block;\n}\n\n.launch-drone {\n  position: absolute;\n  width: 100px;\n  left: 0;\n  filter: grayscale(1);\n  transition: 1s all ease-in;\n}\n\n.launch-drone.on {\n  filter: grayscale(0);\n  animation: DroneLaunch 10s linear infinite;\n}\n\n@keyframes DroneLaunch {\n  0%, 20%, 40%, 60%, 80%, 100% {\n    transform: translateY(0);\n  }\n  10%, 30%, 50%, 70%, 90% {\n    transform: translateY(-20%);\n  }\n}\n</style>\n```\n\n</details>\n\n![Dapp Interface changing step 16](../images/build-dapp-interface/dapp-16.gif "Dapp Interface changing step 16")\n\nNow let\'s add the **DatalogSection.vue** component.\n\n```JS\ncomponents: {\n  DatalogSection: () => import("./DatalogSection")\n}\n```\n\nReformat the log array from:\n\n```JS\nthis.log.push({\n  sender,\n  robot,\n  parameter\n});\n```\n\nto (for structure like `[["entry 1 date", "entry 1 content"], ["entry 2 date", "entry 2 content"]]`):\n\n```JS\nthis.log.push([new Date().toLocaleString(), {\n  sender,\n  robot,\n  parameter\n}]);\n```\n\nReplace the code from the template:\n\n```HTML\n<div v-if="log.length > 0" class="log">\n  <div v-for="(item, k) in log" :key="k" class="row">\n    sender: <b>{{ item.sender }}</b>\n    <br />\n    robot: <b>{{ item.robot }}</b>\n    <br />\n    parameter: <b>{{ item.parameter ? "ON" : "OFF" }}</b>\n  </div>\n</div>\n```\n\nwith this:\n\n```HTML\n<DatalogSection :log="log"/>\n```\n\n**Check:**\n![Dapp Interface changing step 17](../images/build-dapp-interface/dapp-17.gif "Dapp Interface changing step 17")\n\nSometimes you get some errors, it\'s almost inevitable. Something can go wrong with the connection or anything else can happen. So we have fallbacks with error messages through out the dapp, I haven\'t changed them from the start, in the code they look like:\n\n```HTML\n<div v-if="error" class="error">{{ error }}</div>\n```\n\nOn the interface errors look this way now:\n\n![Dapp Interface changing step 18](../images/build-dapp-interface/dapp-18.png "Dapp Interface changing step 18")\n\nAdd styles for the `.error` in **app.css**:\n\n```CSS\n.error {\n  font-weight: 400;\n  text-transform: uppercase;\n  letter-spacing: 1px;\n  color: var(--color-red);\n}\n```\n\nAnd I will fix a space between the `.tools` section and other content from the bottom as well in **app.css**:\n\n```CSS\n.tools {\n  margin-bottom: var(--space);\n}\n```\n\nWe get:\n\n![Dapp Interface changing step 19](../images/build-dapp-interface/dapp-19.png "Dapp Interface changing step 19")\n\nNow on this page we have to "primary" buttons. Technically it is okay, but this is not okay from the above user experience. It\'s better not to use more than one prevailing button on the screen. So let\'s fix it and add for the `Button` in **Launch.vue** with property `type="secondary"`:\n\n![Dapp Interface changing step 20](../images/build-dapp-interface/dapp-20.png "Dapp Interface changing step 20")\n\nGreat, now I\'ll fix some issues with my node and go to the Demo step.\n\n## Demo\n\nFor the start, I\'d like to swap tabs, to pay more attention to the most relevant one, but this is not the first step that we do to practice. Reverse tabs in **App.vue**.\n\nDon\'t forget to replace the default data:\n\n```JS\ndata() {\n    return {\n      ...\n      tab: "demo"\n    };\n},\n```\n\n![Dapp Interface changing step 21](../images/build-dapp-interface/dapp-21.png "Dapp Interface changing step 21")\n\nAs usual let\'s start with changing what we have already got.\n\n- Remove the title `<h2>Demo</h2>` as in the previous steps\n- Find UI elements that we have already learn – datalog, buttons, account address. But not so fast. Now we\'ll change the datalog only.\n\nAdd the component to **Demo.vue**:\n\n```JS\ncomponents: {\n  DatalogSection: () => import("./DatalogSection")\n}\n```\n\n```HTML\n<DatalogSection :log="log"/>\n```\n\nWe\'ve got raw data in the log, so we need to reformat the array with the log to pass in the component ready-view data as in the previous steps. Find the line `return [item[0], item[1]];` in `async created()` and replace it with:\n\n```JS\nreturn [new Date(Number(item[0])).toLocaleString(), JSON.parse(u8aToString(item[1]))];\n```\n\nRemove the unused code from the log:\n\n```HTML\n<div v-if="log" class="log">\n  <p v-if="log.length === 0" class="error">Not found</p>\n  <div v-for="(item, k) in log" :key="k" class="row">\n    <b>{{ item[0] | dateFormat }}</b>\n    <pre>{{ item[1] | dataFormat }}</pre>\n  </div>\n</div>\n```\n\nand:\n\n```JS\nfilters: {\n  dateFormat: function(v) {\n    return new Date(Number(v)).toLocaleString();\n  },\n  dataFormat: function(v) {\n    return JSON.parse(u8aToString(v));\n  }\n},\n```\n\n**Check:**\n![Dapp Interface changing step 22](../images/build-dapp-interface/dapp-22.png "Dapp Interface changing step 22")\n\nFor customization of this demo example with launching a robot, you are free to come up with any idea. Personally, I started with this town:\n\n![Dapp Interface changing step 23](../images/build-dapp-interface/dapp-23.gif "Dapp Interface changing step 23")\n\nI won\'t show the whole code for this not to confuse you at all, but schematically there will be something like this:\n\n```HTML\n<div class="demo" :class="[robot.state ? \'play\' : \'stop\']">\n  <div class="demo-back"></div>\n  <div class="demo-city"></div>\n  <div class="demo-car"></div>\n</div>\n```\n\nThan within the element `.demo.play` write styles for moving the city backward, and the car forward.\n\nWhile working on this, I came up with the idea of realization the CyberPunk city. As I have no any particullar task, so the car became a taxi, driver became a passenger, and now on the interface we have an AI robot hologram welcoming the passenger (these all are just CSS and graphics tweaks&&tricks).\n\n**The code for the Cyberpunk city demo:**\n\n<details>\n\n<summary>Template</summary>\n\n```HTML\n<div class="demo" :class="[robot.state ? \'play\' : \'stop\']">\n  <div class="demo-back-1"></div>\n  <div class="demo-back-2"></div>\n  <div class="demo-city-1"></div>\n  <div class="demo-car"></div>\n\n  <div class="demo-data">\n    <div class="demo-data-driver inline-block">\n      <img alt="Driver\'s avatar" src="../assets/images/cabman.png" v-if="robot.state"/>\n    </div>\n    <div class="demo-data-lines inline-block">\n      <div class="demo-data-line">\n          <div>Robot</div>\n          <div>[ {{ addressShort(robot.address) }} ]</div>\n      </div>\n\n      <div class="demo-data-line" v-if="robot.state">\n          <div>Passenger</div>\n          <div>[ {{ addressShort(robot.driver) }} ]</div>\n      </div>\n\n      <div class="demo-data-welcome" v-if="robot.state">\n          <span>Hello, passenger. </span>\n          <span>I\'ve linked to the vehicle. </span>\n          <span>Your ride begins, congrats! </span>\n      </div>\n    </div>\n\n  </div>\n\n  <Button :label="robot.state ? \'stop\' : \'run\'" :disabled="isWrite" size="large" @onClick="run" />\n</div>\n```\n\n</details>\n\nThere are more than one hash address that should be shortenned, so I added the method:\n\n```JS\nmethods: {\n  addressShort(address) {\n    return address.slice(0, 6) + "..." + address.slice(-4);\n  }\n}\n```\n\nDon\'t forget to register the Button component\n\n```JS\ncomponents: {\n  Button: () => import("./Button")\n}\n```\n\n<details>\n\n<summary>Styles</summary>\n\n```CSS\n<style scoped>\n.demo {\n    --h: 120px;\n    --color-yellow: #F2F209;\n\n    background-color: #AFCCD3;\n\n    background: linear-gradient(#010123, #4baac7);\n\n    position: relative;\n    height: 500px;\n    overflow: hidden;\n\n    border-width: 2px 2px 2px 15px;\n    border-style: solid;\n    border-color: var(--color-yellow);\n    \n}\n\n.demo:before {\n    content: \'[ Delamain cabs rental DEMO ]\';\n    background-color: var(--color-yellow);\n    color: #000;\n\n    position: absolute;\n    top: 0;\n    left: 0;\n    padding: .5rem 1rem;\n\n    text-transform: uppercase;\n    letter-spacing: 1px;\n    font-weight: 300;\n\n    border-width: 0 6px 2px 0;\n    border-style: solid;\n    border-color: #7B186E;\n}\n\ndiv[class^=demo-back-], div[class^=demo-city-] {\n    position: absolute;\n    left: 0;\n    width: 100%;\n    z-index: 2;\n}\n\ndiv[class^=demo-back-]{\n    border-top: 1px solid #364444;\n}\n\ndiv[class^=demo-city-] {\n    background-repeat: repeat-x;\n    background-size: cover;\n    background-position: 100% 0;\n\n    height: 300px;\n    bottom: var(--h);\n\n    animation: 50s MoveCity infinite linear 1.5s;\n}\n\ndiv.demo-back-1 {\n    background-color: #060236;\n    background: linear-gradient(#7B186E, #060236);\n    height: var(--h);\n    bottom: 0;\n}\n\ndiv.demo-back-2 {\n    background-color: #c515ae;\n    border-width: 2px 0;\n    border-style: solid;\n    border-color: #69045c;\n\n    height: 20px;\n    bottom: var(--h);\n    z-index: 10;\n}\n\ndiv.demo-city-1 {\n    background-image: url(../assets/images/city-1.png);\n}\n\n.demo-car {\n    background-image: url(../assets/images/car.png);\n    background-size: contain;\n    background-repeat: no-repeat;\n    background-position: 100% 0;\n\n    width: calc(508px * 0.5);\n    height: calc(257px * 0.5);\n    position: absolute;\n    bottom: calc(var(--h) + 4px);\n    z-index: 10;\n\n    transform: translateX(-100px);\n    animation: MoveCar 50s infinite 1.5s linear;\n}\n\n.demo.play div[class^=demo-city-], .demo.play .demo-car { animation-play-state: running; }\n.demo.stop div[class^=demo-city-], .demo.stop .demo-car { animation-play-state: paused; }\n\n.demo.play .demo-car {\n    background-image: url(../assets/images/car-ride.png);\n}\n\n\n.demo button {\n    background-color: var(--color-yellow);\n    border-color: var(--color-yellow);\n    color: #000;\n\n    position: absolute;\n    bottom: 30px;\n    right: 30px;\n    z-index: 1000;\n}\n\n.demo-data {\n    position: absolute;\n    bottom: 30px;\n    left: 30px;\n    z-index: 1000;\n\n    background-color: rgba(0, 0, 0, .5);\n    color: #fff;\n    padding: .5rem;\n    font-family: var(--font-family-code);\n\n    transition: 0.2s all ease;\n}\n\n.demo-data-lines {\n    max-width: 400px;\n}\n\n.demo-data-line {\n    display: grid;\n    grid-template-columns: 100px auto;\n    gap: .5rem;\n    text-align: left;\n}\n\n.demo-data-line div:first-child {\n    text-transform: uppercase;\n    letter-spacing: 1px;\n    font-weight: 700;\n}\n\n.demo-data-driver {\n    margin-right: 1rem;\n}\n\n.demo-data-driver img {\n    display: block;\n    max-width: 100px;\n\n    visibility: hidden;\n    opacity: 0;\n    animation: FadeInBlink .3s cubic-bezier(0.075, 0.82, 0.165, 1) 0.6s forwards;\n}\n\n.demo-data-welcome {\n    text-align: left;\n    padding-top: .5rem;\n}\n\n.demo-data-welcome span {\n    visibility: hidden;\n    opacity: 0;\n\n    animation-name: FadeIn;\n    animation-timing-function: cubic-bezier(0.075, 0.82, 0.165, 1);\n    animation-duration: 0.6s;\n    animation-fill-mode: forwards;\n}\n\n.demo-data-welcome span:nth-child(1) { animation-delay: 1.5s; }\n.demo-data-welcome span:nth-child(2) { animation-delay: 2.5s; }\n.demo-data-welcome span:nth-child(3) { animation-delay: 3.2s; }\n\n\n@keyframes MoveCity\n{\n  100% {\n    background-position: -1000px 0;\n  }\n}\n\n@keyframes MoveCar\n{\n    0% {\n        transform: translateX(-100px);\n    }\n    100% {\n        transform: translateX(960px);\n    }\n}\n</style>\n\n```\n\n</details>\n\n**Result:**\n\n![Dapp Interface changing step 25](../images/build-dapp-interface/dapp-25.gif "Dapp Interface changing step 25")\n\n## Conclusion\n\nCongratulations! Now you have redesigned the dapp and clues how to start building your application\'s interface.\n\n### Checkout links\n\n- [Full code of this tutorial](https://github.com/positivecrash/wscool21-ui-dapp)\n- [Discuss in Discord](https://discord.gg/5UWNGNaAUf)\n- [View the Robonomics Winter School 2021 schedule and summary](https://robonomics.network/blog/winter-robonomics-school/)\n- [Github of contributor](https://github.com/positivecrash)\n\n### Practice\n\nIf you have some extra time or want to practice your skills, there are some ideas for improvements that you could make to this demo:\n\n- Adapt UI for narrow screens, make the dapp mobile-friendly\n- Add the \'day/night\' mode, by editing the **_variables.scss** file and the template file of the dapp\n- Add \'Copy to clipboard\' buttons for addresses\n- Make delicate popus to inform users about changes (e.g. you can popup a message that units are received after clicking the \'Faucet\' button, or you can move in the popup an error that we had in the \'Launch\' section).\n\nPlease, fill free to ask questions and share your results in [Discord](https://discord.gg/5UWNGNaAUf), mark me in your message `@positivecrash`\n\n\n\n\n\n\n'}},{node:{id:"f2d5dd6f257e85ed16430c1379f5d547",title:"Lección 6.1, Crear dApps IoT para usuarios finales",path:"/docs/es/wschool2021-build-dapp-for-end-users/",content:'\n## Getting ready\n\n### Robonomics node launch\n\nFor dApp development and testing, we will use a local Robonomics node. To do this, you need to download the compiled binary file https://github.com/airalab/robonomics/releases. I will be using Ubuntu, so I download the appropriate version.\n\nUnpack the archive\n```sh\nwget https://github.com/airalab/robonomics/releases/download/v0.24.0/robonomics-ubuntu-0.24.0-x86_64.zip\nunzip robonomics-ubuntu-0.24.0-x86_64.zip\ncd robonomics-ubuntu-0.24.0-x86_64\nchmod +x robonomics\n```\n\nNow we can start the node in development mode. To do this, use the --dev flag\n```sh\n./robonomics --dev\n```\n\n> Troubleshooting\n```sh\n./robonomics purge-chain --dev\n```\n\n### Browser extension\n\nTo store keys in a browser, there is a `polkadot{.js} extension`. In dApp we will use it to sign transactions.\n\nThe extension is currently available for `Google chrome` and `Firefox` https://polkadot.js.org/extension/\n\nAfter installing the extension, create a new account.\n![screen1](../images/build-iot-dapps/screen1.png)\n\n> The first step is completed.\n\n## DApp development\n\n### Step 1\n\n> We will write the dApp using the vue.js framework, although you can use whatever you like/can.\n\nLet\'s start developing the dApp by creating a startup application with vue.js And here you can do it in two ways.\n\nWay 1:\n\nUsing the `Vue cli` console utility.\nTo do this, you need to install it https://cli.vuejs.org/guide/installation.html\n\nAfter installation, you can run the command in the terminal\n\n```sh\nvue create mydapp\n```\n\nAnswer a few questions of the setup wizard. We will be using version Vue 2, so we keep the default version `Default ([Vue 2] babel, eslint)`.\n\nWay 2:\n\nClone the prepared git repository with the example and switch to step 1\n\n```sh\ngit clone https://github.com/airalab/example-robonomics-dapp.git mydapp\ncd mydapp\ngit checkout step-1\n```\n\nAs a result, we will get a directory with the installed startup application, which can already be launched and opened in the browser.\n\n```sh\nyarn\nyarn serve\n```\n\n### Step 2. Getting started with polkadot.js\n\n#### Installing dependencies\n\nTo connect the dApp to the Robonomics chain, there is the `@polkadot/api` library. And for interaction of dApp with an extension with keys, we have the `@polkadot/extension-dapp` library. We need to install them into our application.\nMore details on using this library can be found in the documentation https://polkadot.js.org/docs/.\n\nWay 1:\n\n```sh\nyarn add @polkadot/api @polkadot/extension-dapp\n```\n\nYou also need to add the `vue.config.js` file to support `mjs` extension.\n\n`vue.config.js`\n```js\nmodule.exports = {\n  publicPath: "",\n  configureWebpack: {\n    resolve: {\n      extensions: ["*", ".mjs", ".js", ".vue", ".json", ".gql", ".graphql"]\n    },\n    module: {\n      rules: [\n        {\n          test: /\\.mjs$/,\n          include: /node_modules/,\n          type: "javascript/auto"\n        }\n      ]\n    }\n  }\n};\n```\n\n#### Connecting to Robonomics\n\nFirst, let\'s create a configuration file with the parameters for connecting to the Robonomics node. In the demo repository, there is an example of this file `config.template.json`.\n\n`src/config.json`\n```json\n{\n  "endpoint": "ws://localhost:9944",\n  "types": {\n    "Record": "Vec<u8>",\n    "Parameter": "Bool",\n    "Address": "AccountId",\n    "LookupSource": "AccountId"\n  }\n}\n```\n\nIn this file, we indicate the node, which we are going to connect to, and custom types. The types for Robonomics can be taken from github https://github.com/airalab/robonomics/blob/master/bin/node/cli/res/custom_types.json\n\nNow we need to write a script to connect to our running node.\n\n`src/utils/api.js`\n```js\nimport { ApiPromise, WsProvider } from "@polkadot/api";\nimport config from "../config.json";\n\nlet api;\nexport async function initApi() {\n  const provider = new WsProvider(config.endpoint);\n  api = await ApiPromise.create({\n    provider,\n    types: config.types\n  });\n  return api;\n}\n\nexport function getApi() {\n  return api;\n}\n```\n\nSo that we can sign transactions with the key from the extension, let’s add two functions for connecting to the extension and the function for initializing the account.\n\n`src/utils/api.js`\n```js\n...OTHER_CODE...\n\nimport {\n  web3Accounts,\n  web3Enable,\n  web3FromAddress\n} from "@polkadot/extension-dapp";\n\nasync function getExtension() {\n  const extensions = await web3Enable("demo");\n  if (extensions.length === 0) throw new Error("no extension");\n  return extensions[0];\n}\n\nexport async function initAccount(index = 0) {\n  const timeout = new Promise(resolve => {\n    setTimeout(resolve, 300);\n  });\n  await timeout;\n  await getExtension();\n  const accounts = await web3Accounts();\n  if (accounts.length > 0) {\n    const injector = await web3FromAddress(accounts[index].address);\n    api.setSigner(injector.signer);\n    return accounts[index].address;\n  }\n  throw new Error("no accounts");\n}\n\n...OTHER_CODE...\n```\n\nOur account will have a zero balance, while we need a little funds. So we need to create another faucet function. As we launched Robonomics with the `--dev` flag, we have `Alice` account with a large balance, so we will request funds from there.\n\n`src/utils/api.js`\n```js\n...OTHER_CODE...\n\nimport { Keyring } from "@polkadot/keyring";\n\nexport function getBalance(account, cb) {\n  api.query.system.account(account, ({ data: { free: currentFree } }) => {\n    cb(currentFree);\n  });\n}\n\nexport const keyring = new Keyring({ type: "sr25519" });\n\nexport async function faucet(address) {\n  keyring.setSS58Format(api.registry.chainSS58);\n  const account = keyring.addFromUri("//Alice");\n  const tx = api.tx.balances.transfer(address, 1000000000000000);\n  await tx.signAndSend(account);\n}\n\n...OTHER_CODE...\n```\n\nThe full version of script https://github.com/airalab/example-robonomics-dapp/blob/master/src/utils/api.js\n\nRun app\n\n```sh\nyarn serve\n```\n\nWay 2:\n\nIf you start the application with cloning the repository, then in order to complete these steps, it will be enough to switch to step 2 and install the rest of the dependencies.\n\n```sh\ngit checkout step-2\ncp src/config.template.json src/config.json\nyarn\nyarn serve\n```\n\n### Step 3. Vue connecting component\n\n#### Connecting\n\nWe have already written a script for connecting. Now we can use it on our interface. It is enough to call the written `initApi` function in  the root component `App.vue`. And while the user is waiting for a connection, we will show him a small loader, for now in the form of an ellipsis.\n\nWay 1:\n\nComponent template and base styles.\n\n`src/App.vue`\n```js\n<template>\n  <div id="app">\n    <h1>Robonomics dApp</h1>\n    <div v-if="load">...</div>\n    <template v-else>\n      <div v-if="error" class="error">{{ error }}</div>\n      <template v-else-if="api">\n        connected\n      </template>\n    </template>\n  </div>\n</template>\n\n...OTHER_CODE...\n\n<style>\n#app {\n  font-family: Avenir, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n  margin-top: 60px;\n}\nbutton {\n  font-size: 14px;\n  padding: 5px 12px;\n}\nbutton:hover {\n  cursor: pointer;\n}\ninput {\n  font-size: 14px;\n  padding: 5px;\n}\nselect {\n  font-size: 14px;\n  padding: 5px;\n}\nbutton:focus,\ninput:focus {\n  outline: none;\n}\n.error {\n  color: rgb(151, 31, 31);\n  font-weight: bold;\n  text-align: center;\n  margin: 10px 0;\n}\n</style>\n```\n\nThere is the component code where the  `initApi` function will be called\n\n`src/App.vue`\n```js\n<script>\nimport { initApi } from "./utils/api";\n\nexport default {\n  name: "App",\n  data() {\n    return {\n      load: false,\n      api: null,\n      error: null\n    };\n  },\n  created() {\n    this.init();\n  },\n  methods: {\n    async init() {\n      try {\n        this.load = true;\n        this.api = await initApi();\n        this.load = false;\n      } catch (error) {\n        this.error = error.message;\n        this.load = false;\n      }\n    }\n  }\n};\n<\/script>\n```\n\n#### Account with balance\n\nNow we can use our account, top up its balance and show it on the interface.\n\nLet’s add the appropriate markup to the template\n\n`src/App.vue`\n```js\n<template>\n\n  ...OTHER_CODE...\n\n    <template v-else>\n      <div v-if="error" class="error">{{ error }}</div>\n      <template v-else-if="api && account">\n        <p>\n          Account: <b>{{ account }}</b> {{ balance }} |\n          <button @click="faucet">\n            faucet\n          </button>\n        </p>\n      </template>\n    </template>\n\n  ...OTHER_CODE...\n\n</template>\n```\n\nLet’s add new fields for account address and balance\n\n`src/App.vue`\n```js\n\n...OTHER_CODE...\n\ndata() {\n  return {\n\n    ...OTHER_CODE...\n\n    account: null,\n    balance: 0,\n\n    ...OTHER_CODE...\n\n  };\n}\n\n...OTHER_CODE...\n```\n\nWe need to add the account initialization to the `init` function and get its balance\n\n`src/App.vue`\n```js\n<script>\nimport { initApi, initAccount, getBalance, faucet } from "./utils/api";\nimport { formatBalance } from "@polkadot/util";\n\n...OTHER_CODE...\n\nasync init() {\n\n  ...OTHER_CODE...\n\n  this.api = await initApi();\n  this.account = await initAccount();\n  getBalance(this.account, balance => {\n    this.balance = formatBalance(balance);\n  });\n\n  ...OTHER_CODE...\n\n}\n\n...OTHER_CODE...\n<\/script>\n```\n\nIt remains to add the function of replenishing the balance, when clicking on the button\n\n`src/App.vue`\n```js\n\n...OTHER_CODE...\n\n  methods: {\n    faucet() {\n      faucet(this.account);\n    },\n\n...OTHER_CODE...\n```\n\nhttps://github.com/airalab/example-robonomics-dapp/blob/step-3/src/App.vue\n\nRun app\n\n```sh\nyarn serve\n```\n\nWay 2:\n\nIf you start the application with cloning the repository, then to complete these steps, you will just need to switch to step 3.\n\n```sh\ngit checkout step-3\nyarn serve\n```\n\nAs a result we will get this picture in the browser\n\n![screen2](../images/build-iot-dapps/screen2.png)\n\n### Step 4. Datalog\n\nTo save and read any data in the chain, we use the `datalog` module.\n\nFor an example of how to use this module, let\'s make a `Datalog.vue` component.\n\nWay 1:\n\nIn the markup, we will have a button for reading data `read` with a block, where we will display a list in the form of a date and the data itself. And there will be a form with a text input, into which you can enter any data in the form of a string, and a `write` button.\n\n`src/components/Datalog.vue`\n```js\n<template>\n  <div>\n    <h2>Datalog</h2>\n    <button @click="read">read</button> |\n    <input v-model="data" :disabled="isWrite" />\n    <button @click="write" :disabled="isWrite">write</button>\n    <div v-if="error" class="error">{{ error }}</div>\n    <div v-if="log" class="log">\n      <p v-if="log.length === 0" class="error">Not found</p>\n      <div v-for="(item, k) in log" :key="k" class="row">\n        date: <b>{{ item[0] | dateFormat }}</b>\n        <br />\n        data: <b>{{ item[1] | dataFormat }}</b>\n      </div>\n    </div>\n  </div>\n</template>\n\n...OTHER_CODE...\n\n<style scoped>\n.log {\n  border: 1px solid #eee;\n  text-align: left;\n  width: 800px;\n  margin: 20px auto;\n}\n.log .row {\n  margin: 10px;\n}\n</style>\n```\n\nComponent code. Here the main point in sending a transaction is to call the function, into which we transfer data and which we sign with our account, via api `this.api.tx.datalog.record(stringToHex(this.data)).signAsync(this.account);`\n\n`src/components/Datalog.vue`\n```js\n<script>\nimport { stringToHex, u8aToString } from "@polkadot/util";\n\nexport default {\n  props: ["api", "account"],\n  data() {\n    return {\n      data: "data string",\n      log: null,\n      isWrite: false,\n      error: ""\n    };\n  },\n  filters: {\n    dateFormat: function(v) {\n      return new Date(Number(v)).toLocaleString();\n    },\n    dataFormat: function(v) {\n      return u8aToString(v);\n    }\n  },\n  methods: {\n    async read() {\n      this.log = (await this.api.query.datalog.datalog(this.account)).toArray();\n    },\n    async write() {\n      try {\n        this.error = "";\n        this.isWrite = true;\n        const tx = await this.api.tx.datalog\n          .record(stringToHex(this.data))\n          .signAsync(this.account);\n        await tx.send(result => {\n          if (result.status.isInBlock) {\n            this.read();\n            this.isWrite = false;\n          }\n        });\n      } catch (error) {\n        this.error = error.message;\n        this.isWrite = false;\n      }\n    }\n  }\n};\n<\/script>\n```\n\nhttps://github.com/airalab/example-robonomics-dapp/blob/master/src/components/Datalog.vue\n\nTo switch between components, added to `App.vue` the output of our component\n\n`src/App.vue`\n```js\n...OTHER_CODE...\n\n<template v-else-if="api && account">\n  <p>\n    Account: <b>{{ account }}</b> {{ balance }} |\n    <button @click="faucet">faucet</button>\n  </p>\n\n  <div>\n    <div class="tabs">\n      <button\n        @click="tab = \'datalog\'"\n        :class="{ active: tab === \'datalog\' }"\n      >\n        datalog\n      </button>\n    </div>\n    <Datalog v-if="tab === \'datalog\'" :api="api" :account="account" />\n  </div>\n</template>\n\n...OTHER_CODE...\n\n<script>\nimport Datalog from "./components/Datalog";\n\n...OTHER_CODE...\n\nexport default {\n  name: "App",\n  components: {\n    Datalog\n  },\n  data() {\n    return {\n      tab: "datalog"\n\n...OTHER_CODE...\n<\/script>\n\n<style>\n...OTHER_CODE...\n\n.tabs button {\n  font-size: 14px;\n  padding: 10px 20px;\n  font-weight: bold;\n  background: #ececec;\n  border: 1px solid #aaa;\n}\n.tabs button:hover {\n  background: #bfbfbf;\n}\n.tabs button:last-child {\n  border-left: none;\n}\n.tabs button.active {\n  background: #ced5e2;\n}\n</style>\n```\n\nRun app\n\n```sh\nyarn serve\n```\n\nWay 2:\n\nIf you start the application with cloning the repository, then to complete these steps, you will just need to switch to step 4.\n\n```sh\ngit checkout step-4\nyarn serve\n```\n\nAs a result we will get this picture in the browser\n\n![screen3](../images/build-iot-dapps/screen3.png)\n\n### Step 5. Launch\n\nThis function is used to start and stop the robot. To demonstrate how to use this module, let\'s write the `Launch.vue` component.\n\nWay 1:\n\nIn the component template, we will have a form where you can specify the address of the robot, the ON/OFF clicker and the button for sending.\n\n`src/components/Launch.vue`\n```js\n<template>\n  <div>\n    <h2>Launch</h2>\n    <input v-model="robot" :disabled="isWrite" placeholder="Robot address" />\n    <select v-model="parameter" :disabled="isWrite">\n      <option value="ON">ON</option>\n      <option value="OFF">OFF</option>\n    </select>\n    <button @click="launch" :disabled="isWrite">launch</button>\n    <div v-if="error" class="error">{{ error }}</div>\n    <div v-if="log.length > 0" class="log">\n      <div v-for="(item, k) in log" :key="k" class="row">\n        sender: <b>{{ item.sender }}</b>\n        <br />\n        robot: <b>{{ item.robot }}</b>\n        <br />\n        parameter: <b>{{ item.parameter ? "ON" : "OFF" }}</b>\n      </div>\n    </div>\n  </div>\n</template>\n\n...OTHER_CODE...\n\n<style scoped>\n.log {\n  border: 1px solid #eee;\n  text-align: left;\n  width: 800px;\n  margin: 20px auto;\n}\n.log .row {\n  margin: 10px;\n}\n</style>\n```\n\nThe code looks like the `Datalog.vue` component. The difference is just in reading. The robot will receive the command through events.\n\n`src/components/Launch.vue`\n```js\n<script>\nexport default {\n  props: ["api", "account"],\n  data() {\n    return {\n      robot: this.account,\n      parameter: "ON",\n      log: [],\n      isWrite: false,\n      error: "",\n      unsubscribe: null\n    };\n  },\n  async created() {\n    this.unsubscribe = await this.api.query.system.events(events => {\n      events.forEach(record => {\n        const { event } = record;\n        if (event.section === "launch" && event.method === "NewLaunch") {\n          const sender = event.data[0].toString();\n          const robot = event.data[1].toString();\n          const parameter = event.data[2].toHuman();\n          this.log.push({\n            sender,\n            robot,\n            parameter\n          });\n        }\n      });\n    });\n  },\n  destroyed() {\n    if (this.unsubscribe) {\n      this.unsubscribe();\n    }\n  },\n  methods: {\n    async launch() {\n      try {\n        this.error = "";\n        this.isWrite = true;\n        const tx = await this.api.tx.launch\n          .launch(this.robot, this.parameter === "ON")\n          .signAsync(this.account);\n        await tx.send(result => {\n          if (result.status.isInBlock) {\n            this.isWrite = false;\n          }\n        });\n      } catch (error) {\n        this.error = error.message;\n        this.isWrite = false;\n      }\n    }\n  }\n};\n<\/script>\n```\n\nhttps://github.com/airalab/example-robonomics-dapp/blob/master/src/components/Launch.vue\n\nFor display, add a new component to `App.vue`\n\n`src/App.vue`\n```js\n<template>\n...OTHER_CODE...\n\n  <div>\n    <div class="tabs">\n      <button\n        @click="tab = \'datalog\'"\n        :class="{ active: tab === \'datalog\' }"\n      >\n        datalog\n      </button>\n      <button\n        @click="tab = \'launch\'"\n        :class="{ active: tab === \'launch\' }"\n      >\n        launch\n      </button>\n    </div>\n    <Datalog v-if="tab === \'datalog\'" :api="api" :account="account" />\n    <Launch v-if="tab === \'launch\'" :api="api" :account="account" />\n  </div>\n\n...OTHER_CODE...\n</template>\n\n...OTHER_CODE...\n\n<script>\nimport Datalog from "./components/Datalog";\nimport Launch from "./components/Launch";\n\n...OTHER_CODE...\n\ncomponents: {\n  Datalog,\n  Launch\n},\n\n...OTHER_CODE...\n```\n\nRun app\n\n```sh\nyarn serve\n```\n\nWay 2:\n\nIf you start the application with cloning the repository, then to complete these steps, you will just need to switch to step 5.\n\n```sh\ngit checkout step-5\nyarn serve\n```\n\nAs a result we will get this picture in the browser\n\n![screen4](../images/build-iot-dapps/screen4.png)\n\n### Step 6. Demo\n\nIn this demo, we will have a car that can be started and stopped through the dApp. The car collects a log during the trip, and after stopping, saves it to the chain. Here we will use both modules, which we tried separately, in conjunction.\n\nTo emulate the behavior of a robot (car), we will write a Robot class. We will use the `Alice` key as an account for this robot. The `Robot` class will watch for `NewLaunch` events to turn itself on and off. After turning on, it starts collecting data into the log, in terms of data it will be just a timestamp. And after shutdown, it saves this log to the `datalog` module.\n\nWay 1:\n\nCreate file `src/utils/robot.js`. The full code of the file https://github.com/airalab/example-robonomics-dapp/blob/master/src/utils/robot.js\n\nFor visualization, we will create a `Demo.vue` component, where we will have a start button, car animation and log output.\n\n`src/components/Demo.vue`\n```js\n<template>\n  <div>\n    <h2>Demo</h2>\n    <template v-if="robot">\n      <h3>Robot: {{ robot.address }}</h3>\n      <p v-if="robot.state">Driver: {{ robot.driver }}</p>\n      <button @click="run" :disabled="isWrite">\n        <template v-if="!robot.state">run</template>\n        <template v-else>stop</template>\n      </button>\n      <div class="road">\n        <div\n          class="robot"\n          :class="[robot.state ? \'robot-play\' : \'robot-stop\']"\n        ></div>\n      </div>\n      <div v-if="error" class="error">{{ error }}</div>\n      <div v-if="log" class="log">\n        <p v-if="log.length === 0" class="error">Not found</p>\n        <div v-for="(item, k) in log" :key="k" class="row">\n          <b>{{ item[0] | dateFormat }}</b>\n          <pre>{{ item[1] | dataFormat }}</pre>\n        </div>\n      </div>\n    </template>\n  </div>\n</template>\n\n...OTHER_CODE...\n\n<style scoped>\n.log {\n  border: 1px solid #eee;\n  text-align: left;\n  width: 800px;\n  margin: 20px auto;\n  height: 500px;\n  overflow-y: auto;\n}\n.log .row {\n  margin: 10px;\n  border-bottom: 1px solid #eee;\n}\n.road {\n  width: 1000px;\n  margin: 20px auto;\n  background-color: #eee;\n  padding: 20px 0;\n  border: 5px solid #a5a5a5;\n  border-left: 0;\n  border-right: 0;\n  position: relative;\n}\n.road::before {\n  content: " ";\n  width: 1000px;\n  border-top: 5px dashed #a5a5a5;\n  position: absolute;\n  top: 50%;\n  left: 0;\n}\n@keyframes move {\n  from {\n    transform: translateX(0);\n  }\n  to {\n    transform: translateX(100%);\n  }\n}\n.robot {\n  height: 100px;\n  width: 100px;\n  color: #fff;\n  font-weight: bold;\n  font-style: 14px;\n  animation: move 30s linear infinite;\n  border-radius: 0 10px 10px 0;\n  background: url("../images/build-iot-dapps/car.png") no-repeat 0 0;\n  background-size: cover;\n}\n.robot-play {\n  animation-play-state: running;\n}\n.robot-stop {\n  animation-play-state: paused;\n}\n</style>\n```\n\nComponent code. Here we need to create an instance of the `Robot` class and a launch/stop function.\n\n`src/components/Demo.vue`\n```js\n...OTHER_CODE...\n\n<script>\nimport { u8aToString } from "@polkadot/util";\nimport Robot from "../utils/robot";\n\nexport default {\n  props: ["api", "account"],\n  data() {\n    return {\n      isWrite: false,\n      error: "",\n      robot: null,\n      log: []\n    };\n  },\n  filters: {\n    dateFormat: function(v) {\n      return new Date(Number(v)).toLocaleString();\n    },\n    dataFormat: function(v) {\n      return JSON.parse(u8aToString(v));\n    }\n  },\n  async created() {\n    this.robot = new Robot("//Alice", this.api);\n    await this.robot.subscribeLog(r => {\n      this.log = r.reverse().map(item => {\n        return [item[0], item[1]];\n      });\n    });\n  },\n  destroyed() {\n    this.robot.destroy();\n  },\n  methods: {\n    async run() {\n      try {\n        this.error = "";\n        this.isWrite = true;\n        const tx = await this.api.tx.launch\n          .launch(this.robot.account.address, !this.robot.state)\n          .signAsync(this.account);\n        await tx.send(result => {\n          if (result.status.isInBlock) {\n            this.isWrite = false;\n          }\n        });\n      } catch (error) {\n        this.error = error.message;\n        this.isWrite = false;\n      }\n    }\n  }\n};\n<\/script>\n\n...OTHER_CODE...\n```\n\nhttps://github.com/airalab/example-robonomics-dapp/blob/master/src/components/Demo.vue\n\nLet\'s add another picture of our car to `src/images/build-iot-dapps/car.png`. Example https://github.com/airalab/example-robonomics-dapp/blob/master/src/images/build-iot-dapps/car.png.\n\nFor display, add a new component to `App.vue`\n\n`src/App.vue`\n```js\n<template>\n\n...OTHER_CODE...\n\n  <div>\n    <div class="tabs">\n      <button\n        @click="tab = \'datalog\'"\n        :class="{ active: tab === \'datalog\' }"\n      >\n        datalog\n      </button>\n      <button\n        @click="tab = \'launch\'"\n        :class="{ active: tab === \'launch\' }"\n      >\n        launch\n      </button>\n      <button @click="tab = \'demo\'" :class="{ active: tab === \'demo\' }">\n        demo\n      </button>\n    </div>\n    <Datalog v-if="tab === \'datalog\'" :api="api" :account="account" />\n    <Launch v-if="tab === \'launch\'" :api="api" :account="account" />\n    <Demo v-if="tab === \'demo\'" :api="api" :account="account" />\n  </div>\n\n...OTHER_CODE...\n\n</template>\n\n...OTHER_CODE...\n\n<script>\nimport Datalog from "./components/Datalog";\nimport Launch from "./components/Launch";\nimport Demo from "./components/Demo";\n\n...OTHER_CODE...\n\ncomponents: {\n  Datalog,\n  Launch,\n  Demo\n},\n\n...OTHER_CODE...\n```\n\nRun app\n\n```sh\nyarn serve\n```\n\nWay 2:\n\nIf you start the application with cloning the repository, then to complete these steps, you will just need to switch to step 6.\n\n```sh\ngit checkout step-6\nyarn serve\n```\n\nAs a result we will get this picture in the browser\n\n![screen5](../images/build-iot-dapps/screen5.png)\n\nThis concludes our lesson.\n\nThanks!\n'}},{node:{id:"93ef003a14a8d47c9a576a8a98c5e18e",title:"How to participate in the Wiki translation",path:"/docs/es/translate-wiki/",content:'\nEveryone can contribute to Robonomics. If you want to contribute to the translation of the documentation, you are on the right track: this article will tell you how to do it.\n\n## Editing an article\n\nIf support for your language has already been added to the site, follow these steps:\n\n1. Click the "Edit this page" button on the article you would like to translate. Each article is duplicated in a supported language, even if it has not yet been translated from English.\n2. Edit by sticking to the existing markup. You can read the article [How to edit WIKI(/docs/edit-wiki)\n3. Submit [RP](https://docs.github.com/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request) with the changes you have made.\n\n## Adding a new language\n\nIf the language you would like to translate the article into has not yet been added, request it from the Robonomics root team by, [creating Issue](https://docs.github.com/desktop/contributing-and-collaborating-using-github-desktop/creating-an-issue-or-pull-request) on GitHub.\n\nWhen we add support for the requested language to the site, we will close the Issue, commenting on it if necessary. You will be notified accordingly. This means you can translate pages (they will already be duplicated in English in a folder like `/docs/locale`)\n\n## Notes\n* If you see a way to improve an existing translation of an article, you can also use the PR or Issue on GitHub to request changes\n* If you make a significant contribution to the translation, you can participate in the rewards program'}},{node:{id:"e038c8cc31739d0492dca7f5c2c75615",title:"Sensors Connectivity",path:"/docs/es/sensors-connectivity/",content:'\nThis Aira package allows you to read data from a SDS011 sensor and publish to different output channels. That said Aira is able to form a json formatted message with measurements and publish to a few channels. Also it includes Datalog feature which is still experimental. It could be used to publish data to Substrate based blockchain by Robonomics.\n\nThe last release is [Sensors Connectivity v0.2](https://github.com/airalab/sensors-connectivity/releases/tag/v0.2)\n\n## Sensor Connectivity Protocol :: v1\n\n### Sensor to Station\n\n**TCP Session diagram**\n\n| HEADER | DATA1 | DATA2 | DATA3 | ... | DATAN |\n|--------|-------|-------|-------|-----|-------|\n\nwhere `HEADER` is 34 bytes\n\n|      | Name      |\n|------|-----------|\n| 0x00 | public_id |\n| 0x20 | codec_id  |\n\n* `public_id` - Public identifier, generated on sensor setup.\n* `codec_id` - Type of used data codec.\n\n**Data frame**\n\n|      | Name      |\n|------|-----------|\n| 0x22 | payload   |\n| 0xNN | signature |\n\n\n* `payload` - Sensor measurements.\n* `signature` - Measurement Ed25519 signature, 64 bytes long. ([pynacl](https://github.com/pyca/pynacl))\n\nFor SDS011 sensor `payload` consists of 4 float numbers: PM2.5, PM10, GEO_LAT, GEO_LON\n\n### Station to Robonomics\n\nThe default output channel is Robonomics protocol over IPFS pubsub. For every measurement connectivity produces the following json formatted string:\n\n```\n{public_id: {"model": codec_id,"timestamp": unix_timestamp, "measurement": {"pm25": PM2.5, "pm10": PM10, "geo": "GEO_LAT,GEO_LON"}}}\n```\n\n## Stations and Feeders\n\nIn Sensors Connectivity there are two entities: station and feeder.\n\n### Station\n\nStation represents a source of data. The package can handle many inputs simultaneously:\n\n```\nstation1 \\                        / output1\nstation2 -  sensors-connectivity  - output2\nstation3 /                        \\ output3\n```\n\nThere are COM Station and TCP Station implemented. The first one reads data from a sensor that is connected to a serial port. TCP Station starts a tcp server and listens to incoming connections. \n\nTCP Station can accept data from every sensor or you can specify an access control list (ACL) for known sensors only.\n\n### Feeder\n\nFeeder is an output in terms of sensors connectivity:\n\n```\ninput1 \\                        / feeder1\ninput2 -  sensors-connectivity  - feeder2\ninput3 /                        \\ feeder3\n```\n\nAt current implementation the package can publish data to [Luftdaten](https://meine.luftdaten.info/), Robonomics or Robonomics on Substrate (using Datalog feature).\n\n## Connectivity Configuration\n\nThe package is highly configurable. The default configuration file looks like:\n\n```yaml\n# Please DO NOT edit this file\n# Make a copy instead, make changes and pass the absolute path to the copy in arguments\ngeneral:\n  publish_interval: 300 # time between two published messages\ncomstation:\n  port: "/dev/ttyUSB0"  # COM port of the device\n  work_period: 300      # time between two measurements in seconds\n  geo: ""               # Geo coordinates as latitude,longitude\n  public_key: ""        # If not provided, COMStation creates itself\ntcpstation:\n  address: ""           # IP and PORT to listen to, for example 0.0.0.0:31313\n  acl:                  # list of known addresses. If not specified accepts from everyone\n  # -\n  # -\nluftdaten:\n  enable: true          # whether or not publish to https://luftdaten.info/\nrobonomics:\n  enable: true          # enable use of Robonomics Network\n  ipfs_provider: ""     # ipfs endpoint\n  ipfs_topic: "airalab.lighthouse.5.robonomics.eth"\ndatalog:\n  enable: false         # enable use of Datalog Robonomics subcommand\n  path: ""              # path to Robonomics execution file\n  suri: ""              # private key of publisher account\n  remote: "wss://substrate.ipci.io"\n  dump_interval: 3600   # time between two transactions in seconds\n  temporal_username:    # set to pin files in Temporal.Cloud\n  temporal_password:\ndev:\n  sentry: ""\n```\n\nTo get familiar with all the options and launch scenarios check the [README.md](https://github.com/airalab/sensors-connectivity/tree/v0.2) out.\n\n'}},{node:{id:"41adccb8bb18451d7c615630151cb762",title:"Install Sensors Connectivity on Your Own Aira",path:"/docs/es/sensors-connectivity-on-aira/",content:'\n## Prerequirements\n\nYou must have an AIRA instance somewhere\n\n## Install the Package\n\n```\ngit clone https://github.com/airalab/sensors-connectivity\ncd sensors-connectivity\nnix build -f release.nix\n```\n\nFrom this point you can run the package with the default configuration file or create a systemd service to launch it automatically\n\n### Edit Configuration File\n\nAssuming you are in the package root directory edit the file:\n```\ncp config/default.json config/my.json\nvim config/my.json\n```\n\nExtended description of options is located [here](/docs/configuration-options-description)\n\n### Run Manually\n\nFrom the package directory:\n\n```\nsource result/setup.zsh\nroslaunch sensors_connectivity agent.launch config:=/root/sensors-connectivity/config/my.json\n```\n\n### Run via systemd\n\nAdd the following to `/etc/nixos/configuration.nix`:\n\n```\nsystemd.services.connectivity = {\n  requires = [ "roscore.service" ];\n  after = ["roscore.service" ];\n  wantedBy = [ "multi-user.target" ];\n  environment.ROS_MASTER_URI =  "http://localhost:11311";\n  script = \'\'\n    source /root/sensors-connectivity/result/setup.bash && roslaunch sensors_connectivity agent.launch config:=/root/sensors-connectivity/config/my.json\n  \'\';\n  serviceConfig = {\n    Restart = "on-failure";\n    StartLimitInterval = 0;\n    RestartSec = 60;\n    User = "root";\n  };\n};\n```\n\nThen\n\n```\nnixos-rebuild switch\n```\n\nRunning\n\n```\nsystemctl start connectivity.service\n```\n\n'}},{node:{id:"0dccc7288404a262bcaa2a12889e9c49",title:"Securely connect cloud AI to the factory floor",path:"/docs/es/securely-connect-cloud-ai-to-the-factory-floor/",content:"\nRobonomics technologies can already solve the challenges that Industry 4.0 faces and they are already applied to real-world scenarios in the industrial environment.\n\nA large number of AI companies are building solutions to optimize the processes on the factory floor, allowing plants to produce more with less cost. However, most plants are hesitant to connect their infrastructure to the cloud directly since this results in potential cybersecurity risks, which could lead to million-dollar losses and even the loss of human life.\n\n[MerkleBot](https://merklebot.com) has used [Robonomics Network](https://robonomics.network) to build a solution for industrial clients to connect their factory to the cloud-based AI in a secure way.\n\nThis article is written in the wake of an experiment we conducted with [Veracity Protocol](https://www.veracityprotocol.org/) that uses algorithms to create non-invasive protection of any physical item based on the photographs from a mobile device.\n\nThis use case shows the process of scanning the industrial parts using a robotic arm.\n\n[Demo video](https://youtu.be/8AL70LFVX5w)\n\n## Step-by-step process\n\n### DApp as user interface\n\n![](../images/google-play-store.gif)\n\nDApp acts as a user interface for the operator. It is used to request the launch of the robot to collect the photographs and its purpose is to allow secure communication between the factory environment and cloud-based AI.\n\n### Launching the robot\n\n![](../images/Veracity_Protocol_Transaction.gif)\n\nThe operator launches the robotic scan by signing the transaction in the DApp. This step guarantees that the process on the factory floor can only start based on the transaction in the public blockchain.\n\nThe robot receives a command from the blockchain through the Robonomics Network and begins the scan. Robonomics Network technologies allow us to close the gap between the business objective and robotics operation.\n\n### Data collection and sending to cloud-based AI\n\nIn the DApp the operator sees the confirmation and the robot begins to scan the items placed on the table, such as in this use case, or on the factory line directly if the need arises.\n\n![](../images/Veracity_Protocol_Launch.gif)\n\nWhen the robot collects the data, it stores it locally and makes it available to cloud-based AI through IPFS protocol. By encrypting the data and organizing the data exchange through a blockchain transaction as well, we can authorize access to cloud-based AI while making sure that the data remains secure and in place.\n\nThe security mechanism built into Robonomics based on the shared security of public blockchains allows gaining the level of security that is prohibitively expensive for most factories to organize on their own.\n\n### Digital passport creation\n\nWhen the cloud-based AI analyses the data, the log file and recommendations are recorded as a [Digital Passport](https://wiki.robonomics.network/docs/create-digital-identity-run-by-ethereum/) automatically. Every operation and scan can be traced back since the blockchain record has the hash to all these files through IPFS protocol.\n\n## Comments about the use case\n\nIn this use case, Universal Robot UR3 industrial arm was used. But thanks to Robonomics support for ROS, most major industrial manipulators can be used and connected to cloud-based AI securely, including KUKA, Fanuc, and Yaskawa.\n\nIf you are interested to learn more about the deployment and integration of cloud-based AI instruments securely please [reach out](mailto:v@merklebot.com)\n"}},{node:{id:"d30934987ca26923abb402ad05a8dd19",title:"Manual start of the Robonomics network, consisting of 3 nodes",path:"/docs/es/robonomics-test-network-manual/",content:'\n**Need to start Robonomics network of N (N> = 2) nodes**\n\n## Requirements\n- Robonomics binary, download latest here: https://github.com/airalab/robonomics/releases/\n- Subkey tool, download latest here: https://github.com/airalab/robonomics/releases/\n- 3 servers with root shell. Their ip-addresses in the current instruction will be `165.227.171.127`, `159.89.25.75` and `159.89.30.50`\n\n## Introduction\nIn this tutorial, we will first create all key files locally, and then upload them to their corresponding nodes. \n\n## Prepare directories\nDownload 2 archives from the links above and open the folder with them in the terminal.\nThen create a directory for the project, unpack the archives into it and go to the created folder:\n```\n$ mkdir robonomics_test_network\n$ tar -xf ./robonomics-ubuntu-0.21.0-x86_64.tar.xz -C ./robonomics_test_network/\n$ tar -xf ./subkey-ubuntu-0.21.0-x86_64.tar.xz -C ./robonomics_test_network/\n$ cd ./robonomics_test_network/\n```\n\nNext, create a separate **uploads** directory and the necessary subdirectories for each server. All files intended for uploading to a specific server will be stored in these subdirectories:\n```\n$ mkdir -p uploads/165.227.171.127/keystore && mkdir -p uploads/165.227.171.127/network\n$ mkdir -p uploads/159.89.25.75/keystore && mkdir -p uploads/159.89.25.75/network\n$ mkdir -p uploads/159.89.30.50/keystore && mkdir -p uploads/159.89.30.50/network\n```\n\nAlso, create a **local** folder with **validators** and **sudo** folders, which will store the validators and sudo keys locally.\n```\n$ mkdir -p local/validators && mkdir -p local/sudo\n```\n\n## Prepare spec.json\nUsing the robonomics binary, generate a **spec.json** file, which will use as the basis:\n```\n$ ./robonomics build-spec --chain dev > uploads/spec.json\n```\n\nNext, edit this file. At first correct the first three fields, make them look like this:\n```\n"name": "Test Robonomics Network",\n"id": "dev",\n"chainType": "Live",\n```\n\n### bootNodes\nThe **bootNodes** field is a list of strings of special format. For each of the bootnodes must write the corresponding string here.\nTo do this, first create a key file for each bootnode using **subkey**:\n```\n$ ./subkey generate-node-key uploads/165.227.171.127/network/secret_ed25519  \n12D3KooWBPq1fDLQC2iqQ4FpM2mUpiXjBRcb8ptk7tbaqr2B6HZN\n$ ./subkey generate-node-key uploads/159.89.25.75/network/secret_ed25519\n12D3KooWRbGmdpbz6o1fe66wFs7nJsUYfBp2f3W7J1uDXj3gt4Bh\n$ ./subkey generate-node-key uploads/159.89.30.50/network/secret_ed25519\n12D3KooWMuTrL9CmJxj8LjH43s4hsJMsyuMdbuB86zCaAf9VCwFf\n```\n\nEach command creates a key file in the specified directory and outputs to stdout the string that will be needed to fill in the **bootNodes** field in the **spec.json** file. As a result, the **bootNodes** section should look like following example:\n```\n"bootNodes": [\n"/ip4/165.227.171.127/tcp/30333/p2p/12D3KooWBPq1fDLQC2iqQ4FpM2mUpiXjBRcb8ptk7tbaqr2B6HZN",\n"/ip4/159.89.25.75/tcp/30333/p2p/12D3KooWRbGmdpbz6o1fe66wFs7nJsUYfBp2f3W7J1uDXj3gt4Bh",\n"/ip4/159.89.30.50/tcp/30333/p2p/12D3KooWMuTrL9CmJxj8LjH43s4hsJMsyuMdbuB86zCaAf9VCwFf"\n],\n```\nThe next 3 fields (telemetryEndpoints, protocolId, properties) can be filled like this:\n```\n "telemetryEndpoints": [\n     [\n       "/dns4/telemetry.polkadot.io/tcp/443/x-parity-wss/%2Fsubmit%2F",\n       0\n     ]\n ],\n"protocolId": "txrt",\n"properties": {\n    "ss58Format": 32,\n    "tokenDecimals": 9,\n    "tokenSymbol": "TXRT"\n},\n```\nFurther up to the **palletBalances** field leave unchanged.\n\n\n### palletBalances\nTo fill the palletBalances field create **the number of nodes + 1** (the last key is for **sudo**) keys. This can be done using **subkey**, in the file name must specify **SS58 Address** from the generated key, in the file content must specify **seed** phrase in quotes. \n\nExample creating one key.\n - Generate key:\n    ```\n    $ ./subkey -n robonomics generate\n    Secret phrase `display cargo domain april joy still bundle notice bridge pencil fat approve` is account:\n      Network ID/version: substrate\n      Secret seed:        0x0275ab9bce53e4359184f02112943162c708f483009e0b7b3ba63549c5c2e514\n      Public key (hex):   0xd0996b85dd1b2876080b26123f9c27097d698f871c5978c3cb9c299253e7a530\n      Account ID:         0xd0996b85dd1b2876080b26123f9c27097d698f871c5978c3cb9c299253e7a530\n      SS58 Address:       4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx\n    ```\n - Create key file:\n    ```\n    $ touch ./local/validators/4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx && echo \'"display cargo domain april joy still bundle notice bridge pencil fat approve"\' | tee ./local/validators/4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx\n    ```\n  \nCommand template for creating a validator key file:  \n`touch ./local/validators/**SS58_Address** && echo \'"**seed**"\' | tee ./local/validators/**SS58_Address**`\n\nCommand template for creating a sudo key file:   \n`touch ./local/sudo/**SS58_Address** && echo \'"**seed**"\' | tee ./local/sudo/**SS58_Address**`\n\nThree keys are stored in the **local/validators** folder and one in the **local/sudo** folder. As a result, the following content should appear in the **local** directory:\n```\n./local/\n├── sudo\n│   └── 4Dy6bzrvoApwjLaAjfrtvtX3tthCw6fnCU1Ym5KNyRGt3kKb\n└── validators\n    ├── 4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx\n    ├── 4EeMi84pk5P5nQpyupQeCZ1C4NhUFtMF7Xh1MXJLANkZ3BTd\n    └── 4FPRYfSVqwaX39vXZ78tT3DPBT9FmFXvdQDD7y5UQKncJGu1\n```\n\nNow fill the palletBalances section in the spec.json file with these keys.\nAs a result, it should look like this:\n```\n"palletBalances": {\n  "balances": [\n    [\n      "4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx",    <-- Generated validator 1 key\n      1000000000000000000\n    ],\n    [\n      "4EeMi84pk5P5nQpyupQeCZ1C4NhUFtMF7Xh1MXJLANkZ3BTd",    <-- Generated validator 2 key\n      1000000000000000000\n    ],\n    [\n      "4FPRYfSVqwaX39vXZ78tT3DPBT9FmFXvdQDD7y5UQKncJGu1",    <-- Generated validator 3 key\n      1000000000000000000\n    ],\n    [\n      "4Dy6bzrvoApwjLaAjfrtvtX3tthCw6fnCU1Ym5KNyRGt3kKb",    <-- Generated sudo key\n      1000000000000000000\n    ],\n  ]\n},\n```\nThe values that were previously presented in the palletBalances section must be deleted.\n\n### palletSession\nNext step is the **palletSession** section in file **spec.json**. First let\'s describe its format. \nThis section contains the "keys" field, that contains a list of three lists (equals of nodes count). Each of these lists looks like follows:\n```\n[\n    "%validator_SS58_address%",\n    "%validator_SS58_address%",\n    {\n        "babe": "%sr25519_babe_SS58_address%",\n        "im_online": "%sr25519_im_online_SS58_address%"\n        "authority_discovery": "%sr25519_authority_discovery_SS58_address%",\n        "grandpa": "%ed25519_grandpa_SS58_address%",\n    }\n]\n```\n**%validator_SS58_address%** is the validator key that was generated for each node in the **palletBalances** section of this manual. Just copy it twice for each node.\n\nTo fill in the remaining 4 lines for each node, you need to create 4 key files for each node and store them in the **keystore** folders.\nAs key files are generated, you can fill **palletSession**.\n\nEach key file must contain a **seed** phrase in quotes.\nMaking of the name of each key file require separate consideration.\nThe name of each key file is formed as **prefix** + **account_id without leading hexadecimal zero**.\n\nPrefixes matching:  \n>      grandpa: \'6772616e\'  \n>      babe: \'62616265\'\n>      im_online: \'696d6f6e\'  \n>      authority_discovery: \'61756469\'  \n\nAn example of creating keys for one node:\n- Creating a **babe** (prefix *62616265*) key file.   \n  ```\n  $ ./subkey --sr25519 -n robonomics generate\n  ```\n  >  Secret phrase **cover once garment syrup income chair elder business diary frozen rack damage** is account:  \n  >\n  >  Network ID/version: `substrate`\n  >\n  >  Secret seed:        `0x90ddeee3a9a0c464572021d311c245eefc41f9a59c739faefda47efcf4755677`\n  >\n  >  Public key (hex):   `0xfa44d96e310cf68350dd855c745794f7c1afa63089ebdb2c96bff3797972bb43`\n  >\n  >  Account ID:         `0xfa44d96e310cf68350dd855c745794f7c1afa63089ebdb2c96bff3797972bb43`\n  > \n  >  SS58 Address:       `4HirHF5BVHxkRBtqptFxBSmnAiZir1qQLs6pL9Utmm4eF77C`\n  \n ```\n $ touch uploads/165.227.171.127/keystore/62616265fa44d96e310cf68350dd855c745794f7c1afa63089ebdb2c96bff3797972bb43 && echo \'"cover once garment syrup income chair elder business diary frozen rack damage"\' | tee ./uploads/165.227.171.127/keystore/62616265fa44d96e310cf68350dd855c745794f7c1afa63089ebdb2c96bff3797972bb43 \n ```\n This command creates a **babe** key file for the `165.227.171.127` node. To fill in **spec.json**, need to take from this output the value **SS58 Address**: `4HirHF5BVHxkRBtqptFxBSmnAiZir1qQLs6pL9Utmm4eF77C`. This address need to insert instead of `%sr25519_babe_SS58_address%` in the above **palletSession** template.\n   \n **babe** key file creation command template:  \n`touch ./uploads/[node_ip]/keystore/62616265+[Account_ID] && echo \'"[seed]"\' | tee ./uploads/[node_ip]/keystore/62616265+[Account_ID]`  \n\nAs you can see, the name of the babe key file is the sum of two substrings: `babe prefix (\'62616265\')`, and the `account_id` of the generated key, without the leading zero (`fa44d96e310cf68350dd855c745794f7c1afa63089ebdb2c96bff3797972bb43`). \n  Note that the keys `babe, im_online, authority_discovery` are generated with the indication `--sr25519`.  \n  **grandpa** key have to generate with the indication `--ed25519`.\n \n\n- Creating an **im_online** (prefix *696d6f6e*) key file.  \n  ```\n  $ ./subkey --sr25519 -n robonomics generate\n  ```\n  > Secret phrase **envelope truly balance turkey undo casual waste skill average ordinary gun split** is account:\n  >\n  >   Network ID/version: `substrate`\n  > \n  >   Secret seed:        `0x8a19df08feeff9f1fa3581902ca22a305252aea32e284d32f10e990d00bb8926`\n  > \n  >   Public key (hex):   `0x6c13ff8e37d91b80fe3b03f9b92a91a1ef7db741434cf12cc44d5ed29257ab09`\n  >  \n  >   Account ID:         `0x6c13ff8e37d91b80fe3b03f9b92a91a1ef7db741434cf12cc44d5ed29257ab09`\n  >  \n  >   SS58 Address:       `4EWQyBRoucH4Wjd4JtGoSEYYCw4bbkonjoFy9hNUX5fbmMEt`\n   \n  ```\n  $ touch uploads/165.227.171.127/keystore/696d6f6e6c13ff8e37d91b80fe3b03f9b92a91a1ef7db741434cf12cc44d5ed29257ab09 && echo \'"envelope truly balance turkey undo casual waste skill average ordinary gun split"\' | tee uploads/165.227.171.127/keystore/696d6f6e6c13ff8e37d91b80fe3b03f9b92a91a1ef7db741434cf12cc44d5ed29257ab09\n  ```\n  **im_online** key file creation command template:  \n  `touch ./uploads/[node_ip]/keystore/696d6f6e+[Account_ID] && echo \'"[seed]"\' | tee ./uploads/[node_ip]/keystore/696d6f6e+[Account_ID]`\n  \n  **spec.json**: `4EWQyBRoucH4Wjd4JtGoSEYYCw4bbkonjoFy9hNUX5fbmMEt` need to insert instead of `%sr25519_im_online_SS58_address%` in the above **palletSession** template.\n\n\n- Creating an **authority_discovery** (prefix *61756469*) key file.\n   ```\n   $ ./subkey --sr25519 -n robonomics generate\n   ```\n   > Secret phrase **boy harsh because omit equip atom apart spring undo explain walnut crystal** is account:\n   >\n   > Network ID/version: `substrate`\n   >\n   >   Secret seed:        `0x27838c9ea0524353da3717862ef0ecef123f40e81b73bb5ef377d12b47d1c543`\n   > \n   >   Public key (hex):   `0x4e33ccfd4105d30dfd93c5ef4658e2585a749508ea7c7abe754efc36dd634c07`\n   > \n   >   Account ID:         `0x4e33ccfd4105d30dfd93c5ef4658e2585a749508ea7c7abe754efc36dd634c07`\n   >  \n   >   SS58 Address:       `4DqEyoefRSz746sjaonxJ7KZQz8MUq4cKFA87DfoLzQgWk8t`\n   \n   ```\n   $ touch uploads/165.227.171.127/keystore/617564694e33ccfd4105d30dfd93c5ef4658e2585a749508ea7c7abe754efc36dd634c07 && echo \'"boy harsh because omit equip atom apart spring undo explain walnut crystal"\' | tee uploads/165.227.171.127/keystore/617564694e33ccfd4105d30dfd93c5ef4658e2585a749508ea7c7abe754efc36dd634c07\n   ```\n  **authority_discovery** key file creation command template:  \n  `touch ./uploads/[node_ip]/keystore/61756469+[Account_ID] && echo \'"[seed]"\' | tee ./uploads/[node_ip]/keystore/61756469+[Account_ID]` \n  \n   **spec.json**: `4DqEyoefRSz746sjaonxJ7KZQz8MUq4cKFA87DfoLzQgWk8t` need to insert instead of `%sr25519_authority_discovery_SS58_address%` in the above **palletSession** template.\n\n\n- Creating a **grandpa** (prefix *6772616e*) key file.\n   ```\n   $ ./subkey --ed25519 -n robonomics generate\n   ```\n   > Secret phrase **squeeze nature off vendor comic pause tattoo seek omit spatial regular cattle** is account:\n   > \n   >   Network ID/version: `substrate`\n   >\n   >   Secret seed:        `0xef0a9f51a4da7b789c0a25d39b44428d4da7262cc3fe013d4383b45216e8b83e`\n   >  \n   >   Public key (hex):   `0x7ea1beed13fb66a333b50b1ae417ebfd152bab99b223be2d4d886adb5fa7f009`\n   >  \n   >   Account ID:         `0x7ea1beed13fb66a333b50b1ae417ebfd152bab99b223be2d4d886adb5fa7f009`\n   > \n   >   SS58 Address:       `4EvjwRdgUg6YtdUDjq6Z3PoTKtzH5cgFgwnzArMSbw3RzYTa`\n    \n   ```\n   $ touch uploads/165.227.171.127/keystore/6772616e7ea1beed13fb66a333b50b1ae417ebfd152bab99b223be2d4d886adb5fa7f009 && echo \'"squeeze nature off vendor comic pause tattoo seek omit spatial regular cattle"\' | tee uploads/165.227.171.127/keystore/6772616e7ea1beed13fb66a333b50b1ae417ebfd152bab99b223be2d4d886adb5fa7f009\n   ```\n   **grandpa** key file creation command template:  \n  `touch ./uploads/[node_ip]/keystore/6772616e+[Account_ID] && echo \'"[seed]"\' | tee ./uploads/[node_ip]/keystore/6772616e+[Account_ID]`\n   \n   **spec.json**: `4EvjwRdgUg6YtdUDjq6Z3PoTKtzH5cgFgwnzArMSbw3RzYTa` need to insert instead of `%sr25519_grandpa_SS58_address%` in the above **palletSession** template.\n   \n   \n**Now 4 key files have been created for one node. Need to repeat this actions for the remaining two nodes.**\n\nYou should get the following **uploads** directory structure after creating all the keys:\n```\n./uploads/\n├── 165.227.171.127\n│   ├── keystore\n│   │   ├── 617564694e33ccfd4105d30dfd93c5ef4658e2585a749508ea7c7abe754efc36dd634c07\n│   │   ├── 62616265fa44d96e310cf68350dd855c745794f7c1afa63089ebdb2c96bff3797972bb43\n│   │   ├── 6772616e7ea1beed13fb66a333b50b1ae417ebfd152bab99b223be2d4d886adb5fa7f009\n│   │   └── 696d6f6e6c13ff8e37d91b80fe3b03f9b92a91a1ef7db741434cf12cc44d5ed29257ab09\n│   └── network\n│       └── secret_ed25519\n├── 159.89.25.75\n│   ├── keystore\n│   │   ├── 617564692ac9bd30c0168fa623cfd66abb4327992d900a652bcbb238b740bdde497a565f\n│   │   ├── 626162657cd666bb540c41cb33896a34d7413ffb86fcef1eddddfcd4edb325166df6335d\n│   │   ├── 6772616e084402349bc08ef90c2837e8e3f12ebe8bd4ab86809e9ee5f4f8ca26e73a0518\n│   │   └── 696d6f6e6ed2d507c0283ae869ba6514975bd8765eb8e06abd22afc09e8f36ef3950a116\n│   └── network\n│       └── secret_ed25519\n└── 159.89.30.50\n|   ├── keystore\n|   │   ├── 61756469f20a4e16a0ee79431d6f9a70c38892c7532ad1347c2226d43ef6ffe8966e9b30\n|   │   ├── 62616265e695aa459dbfd42bea7ed3b87970f164f34b6fee4d5a831ffbecd89eb9769b26\n|   │   ├── 6772616eadef59f896ea6b94bcd4519be8cc4b70263fc318cec1a3be14850bbc22117c34\n|   │   └── 696d6f6e2cb4dc8f8a67f477da15045ca40ef3861a2a6b2034ae0c64a179b4431341ea2c\n|   └── network\n|       └── secret_ed25519\n└── spec.json\n```\n\nThe palletSession section should look like this:\n```\n"palletSession": {\n    "keys": [\n        [\n            "4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx",    <-- Validator 1 SS58 Address\n            "4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx",    <-- Validator 1 SS58 Address\n            {\n                "authority_discovery": "4DqEyoefRSz746sjaonxJ7KZQz8MUq4cKFA87DfoLzQgWk8t",\n                "babe": "4HirHF5BVHxkRBtqptFxBSmnAiZir1qQLs6pL9Utmm4eF77C",\n                "grandpa": "4EvjwRdgUg6YtdUDjq6Z3PoTKtzH5cgFgwnzArMSbw3RzYTa",\n                "im_online": "4EWQyBRoucH4Wjd4JtGoSEYYCw4bbkonjoFy9hNUX5fbmMEt"\n            }\n        ],\n        [\n            "4EeMi84pk5P5nQpyupQeCZ1C4NhUFtMF7Xh1MXJLANkZ3BTd",    <-- Validator 2 SS58 Address\n            "4EeMi84pk5P5nQpyupQeCZ1C4NhUFtMF7Xh1MXJLANkZ3BTd",    <-- Validator 2 SS58 Address\n            {\n                "authority_discovery": "4F6daoG2gBXRLvbT4mVRajExZdZBHH7APmX3wDuLYJyzxHSS",\n                "babe": "4C7vBVHUYKqApCywqGsuap6XhjZ3gdYnW4YYP2mMyvYctLqT",\n                "grandpa": "4G3Ai6BGUjqtCoM2aTvWyR19gQ8WZiNnh1KFM47RyiYTwkE6",\n                "im_online": "4FHA7gzKfSLvd8jP85JUCWV6RyeRLm331KHcjnynGx7TWm7D"\n            }\n        ],\n        [\n            "4FPRYfSVqwaX39vXZ78tT3DPBT9FmFXvdQDD7y5UQKncJGu1",    <-- Validator 3 SS58 Address                        \n            "4FPRYfSVqwaX39vXZ78tT3DPBT9FmFXvdQDD7y5UQKncJGu1",    <-- Validator 3 SS58 Address\n            {\n                "authority_discovery": "4CqzJFkdSZg52PfV6Fd4gJ3vPLmRu1HGuPvNivjJ8dDWaz1a",\n                "babe": "4EComk8TsrT399xT6MPhGnhbZEif6U6cny8DiyZ3zezo9b5f",\n                "grandpa": "4Cqi4rG3CzWRZairhZX4isT8qG2jyz9fGDXJMrP6uBYkrft5",\n                "im_online": "4C7V6R59cZVbabExqgWvHVE1vj1E1cV42SZr8d8zZD3gmsqk"\n            }\n        ]\n    ]\n},\n```\n\n### palletStaking\n**palletStaking** must be filled in as follows:\n```\n"palletStaking": {\n    "historyDepth": 84,\n    "validatorCount": 10,\n    "minimumValidatorCount": 2,\n    "invulnerables": [\n        "4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx",     <-- Validator 1 SS58 Address\n        "4EeMi84pk5P5nQpyupQeCZ1C4NhUFtMF7Xh1MXJLANkZ3BTd",     <-- Validator 2 SS58 Address\n        "4FPRYfSVqwaX39vXZ78tT3DPBT9FmFXvdQDD7y5UQKncJGu1"      <-- Validator 3 SS58 Address\n    ],\n    "forceEra": "NotForcing",\n    "slashRewardFraction": 100000000,\n    "canceledPayout": 0,\n    "stakers": [\n        [\n            "4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx",  <-- Validator 1 SS58 Address\n            "4HirHF5BVHxkRBtqptFxBSmnAiZir1qQLs6pL9Utmm4eF77C",  <-- Validator 1 babe address\n            1000000,\n            "Validator"\n        ],\n        [\n            "4EeMi84pk5P5nQpyupQeCZ1C4NhUFtMF7Xh1MXJLANkZ3BTd",  <-- Validator 2 SS58 Address\n            "4C7vBVHUYKqApCywqGsuap6XhjZ3gdYnW4YYP2mMyvYctLqT",  <-- Validator 2 babe address\n            1000000,\n            "Validator"\n        ],\n        [\n            "4FPRYfSVqwaX39vXZ78tT3DPBT9FmFXvdQDD7y5UQKncJGu1",   <-- Validator 3 SS58 Address\n            "4EComk8TsrT399xT6MPhGnhbZEif6U6cny8DiyZ3zezo9b5f",   <-- Validator 3 babe address\n            1000000,\n            "Validator"\n        ]\n    ]\n},\n```\nThe example specified in which fields what values should be substituted.\n\n### palletSudo\nIn the rest of the **spec.json** file, you need to change only the contents of **palletSudo**, substituting the previously generated **sudo** address there:\n```\n            "palletBabe": {\n                "authorities": []\n            },\n            "palletGrandpa": {\n                "authorities": []  \n            },\n            "palletImOnline": {\n                "keys": []\n            },\n            "palletAuthorityDiscovery": {\n                "keys": []\n            },\n            "palletTreasury": {},\n            "palletElectionsPhragmen": {\n                "members": []\n            },\n            "palletCollectiveInstance1": {\n                "phantom": null,\n                "members": []\n            },\n            "palletSudo": {\n                "key": "4Dy6bzrvoApwjLaAjfrtvtX3tthCw6fnCU1Ym5KNyRGt3kKb"   <-- sudo address\n            }\n        }\n    }\n}\n```\n\n## systemd unit file\nNow create systemd unit file:\n```\n$ touch ./uploads/robonomics.service\n```\n\nAnd fill it like this:\n```\n[Unit]\nDescription=robonomics\nAfter=network.target\n\n[Service]\nUser=root\nGroup=root\nType=users\nWorkingDirectory=/root\nRestart=on-failure\nExecStart=/usr/bin/robonomics  --chain /etc/substrate/spec.json --name ${HOSTNAME} --validator\n\n[Install]\nWantedBy=multi-user.target\n```\nAs you can see from the "ExecStart" line, the **robonomics** binary is stored in the **/usr/bin/** directory, and the **spec.json** file is stored in the **/etc/substrate/** directory.\n\n## Uploading files\nThe following one-line command uploads all files to the required directories on the servers. It is important that there are no other folders in the **uploads** directory, except for the folders with the ip-addresses of the nodes:\n```\n$ \\\nfor IP in `ls -l ./uploads/ | grep \'^d\' | awk \'{print $9}\'`; do \\\n    ssh root@"$IP" "mkdir -p /root/.local/share/robonomics/chains/dev" && \\\n    scp -r ./uploads/$IP/* root@$IP:/root/.local/share/robonomics/chains/dev/ && \\\n    scp ./uploads/robonomics.service root@$IP:/etc/systemd/system/ && \\\n    scp ./robonomics root@$IP:/usr/bin/ && \\\n    ssh root@$IP "mkdir -p /etc/substrate" && \\\n    scp ./uploads/spec.json root@$IP:/etc/substrate/ \\\n; done\n```\n\n## Network launch\nNow connect to all nodes, enable and start the **robonomics.service** unit:\n```\n$  \\\nfor IP in `ls -l ./uploads/ | grep \'^d\' | awk \'{print $9}\'`; do \\\n   ssh root@$IP "systemctl enable robonomics.service && systemctl start robonomics.service" \\\n; done\n```\nAfter starting the service on all three nodes, you can view the node logs using **journalctl**. \nTo do this, you can connect to any existing server via ssh and run the following command:\n```\n$ journalctl -u robonomics.service -f\n```\n![Robonomics Chart](../images/robonomics-test-network-manual/result-journalctl.jpg "Robonomics Network journalctl stdout")\n'}},{node:{id:"a8dc5a4baecb2ac1567ced959bbd0feb",title:"Robonomics + Prometheus + Grafana",path:"/docs/es/robonomics-prometheus-grafana/",content:"\n**The following instruction is provided by [Hubo Bubo](https://github.com/hubobubo)**\n\n**The original article is located [here](https://github.com/hubobubo/robonomics/wiki/Robonomics-(XRT)-metrics-using-Prometheus-and-Grafana)**\n\n## Introduction\nTo better monitor and maintain Robonomics node(s) it's good to setup a monitoring based on Prometheus Server and Grafana. This doc will show how to configure each one of it to fully monitor your node.\n\n##  Prerequisites\n* [Server Setup with Ubuntu 18.04](https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-18-04) \n* [Robonomics parachain collator installed](https://blog.aira.life/installing-and-running-the-robonomics-validator-in-the-polkadot-network-487ad4c1a567)\n* Make sure you have robonomics.service working on your machine and port 9615 is reachable \n\n## Step 1 — Creating Service Users\n\nFor security purposes, we’ll begin by creating two new user accounts, prometheus and node_exporter. Create these two users, and use the _--no-create-home_ and _--shell /bin/false_ options so that these users can’t log into the server.\n```\nsudo useradd --no-create-home --shell /bin/false prometheus\nsudo useradd --no-create-home --shell /bin/false node_exporter\n```\n\nBefore we download the Prometheus binaries, create the necessary directories for storing Prometheus’ files and data. Following standard Linux conventions, we’ll create a directory in _/etc_ for Prometheus’ configuration files and a directory in _/var/lib_ for its data.\n```\nsudo mkdir /etc/prometheus\nsudo mkdir /var/lib/prometheus\n```\nNow, set the user and group ownership on the new directories to the prometheus user.\n```\nsudo chown prometheus:prometheus /etc/prometheus\nsudo chown prometheus:prometheus /var/lib/prometheus\n```\n## Step 2 — Downloading Prometheus\n\nFirst, download and unpack the current stable version of Prometheus into your home directory. You can find the latest binaries on the [Prometheus download page.](https://prometheus.io/download/)\n\n```\nwget https://github.com/prometheus/prometheus/releases/download/v2.21.0/prometheus-2.21.0.linux-amd64.tar.gz\n\n```\nNow, unpack the downloaded archive.\n\n```\ntar xvf prometheus-2.21.0.linux-amd64.tar.gz\n\n```\nThis will create a directory called prometheus-2.21.0.linux-amd64 containing two binary files (prometheus and promtool), _consoles_ and _console_libraries_ directories containing the web interface files, a license, a notice, and several example files.\n\nCopy the two binaries to the _/usr/local/bin_ directory.\n\n```\nsudo cp prometheus-2.21.0.linux-amd64/prometheus /usr/local/bin/\nsudo cp prometheus-2.21.0.linux-amd64/promtool /usr/local/bin/\n\n```\nSet the user and group ownership on the binaries to the prometheus user created in Step 1.\n\n```\nsudo chown prometheus:prometheus /usr/local/bin/prometheus\nsudo chown prometheus:prometheus /usr/local/bin/promtool\n\n```\nCopy the consoles and _console_libraries_ directories to _/etc/prometheus_.\n\n```\nsudo cp -r prometheus-2.21.0.linux-amd64/consoles /etc/prometheus\nsudo cp -r prometheus-2.21.0.linux-amd64/console_libraries /etc/prometheus\n\n```\nSet the user and group ownership on the directories to the prometheus user. Using the -R flag will ensure that ownership is set on the files inside the directory as well.\n\n```\nsudo chown -R prometheus:prometheus /etc/prometheus/consoles\nsudo chown -R prometheus:prometheus /etc/prometheus/console_libraries\n\n```\nNow that Prometheus is installed, we’ll create its configuration and service files in preparation of its first run.\n\n## Step 3 — Configuring Prometheus\n\nIn the _/etc/prometheus_ directory, use nano or your favorite text editor to create a configuration file named _prometheus.yml_.\n\n```\nsudo nano /etc/prometheus/prometheus.yml\n\n```\nIn the global settings, define the default interval for scraping metrics. Note that Prometheus will apply these settings to every exporter unless an individual exporter’s own settings override the globals.\n\n```\nglobal:\n  scrape_interval: 15s\n\n```\nThis scrape_interval value tells Prometheus to collect metrics from its exporters every 15 seconds, which is long enough for most exporters.\nNow, add Prometheus itself to the list of exporters to scrape from with the following scrape_configs directive:\n\n```\n...\nscrape_configs:\n  - job_name: 'prometheus'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9090']\n```\nPrometheus uses the _job_name_ to label exporters in queries and on graphs, so be sure to pick something descriptive here.\n\nAnd, as Prometheus exports important data about itself that you can use for monitoring performance and debugging, we’ve overridden the global scrape_interval directive from 15 seconds to 5 seconds for more frequent updates.\n\nLastly, Prometheus uses the _static_configs_ and _targets_ directives to determine where exporters are running. Since this particular exporter is running on the same server as Prometheus itself, we can use localhost instead of an IP address along with the default port, 9090.\n\nYour configuration file should now look like this:\n\n```\nglobal:\n  scrape_interval: 15s\n\nscrape_configs:\n  - job_name: 'prometheus'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9090']\n```\nSave the file and exit your text editor.\n\nNow, set the user and group ownership on the configuration file to the prometheus user created in Step 1.\n\n```\nsudo chown prometheus:prometheus /etc/prometheus/prometheus.yml\n\n```\nWith the configuration complete, we’re ready to test Prometheus by running it for the first time.\n\n## Step 4 — Running Prometheus\n\nStart up Prometheus as the _prometheus_ user, providing the path to both the configuration file and the data directory.\n\n```\nsudo -u prometheus /usr/local/bin/prometheus \\\n    --config.file /etc/prometheus/prometheus.yml \\\n    --storage.tsdb.path /var/lib/prometheus/ \\\n    --web.console.templates=/etc/prometheus/consoles \\\n    --web.console.libraries=/etc/prometheus/console_libraries\n```\n\nThe output contains information about Prometheus’ loading progress, configuration file, and related services. It also confirms that Prometheus is listening on port _9090_.\n\n```\n_log output_\nSep 14 17:55:53 robonomics systemd[1]: Started Prometheus.\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.347Z caller=main.go:310 msg=\"No time or size retention was set so using the default time retention\" duration=15d\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.350Z caller=main.go:346 msg=\"Starting Prometheus\" version=\"(version=2.21.0, branch=HEAD, revision=e83ef207b6c2398919b69cd87d2693cfc2fb4127)\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:347 build_context=\"(go=go1.15.2, user=root@a4d9bea8479e, date=20200911-11:35:02)\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:348 host_details=\"(Linux 4.15.0-112-generic #113-Ubuntu SMP Thu Jul 9 23:41:39 UTC 2020 x86_64 robonomics (none))\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:349 fd_limits=\"(soft=1024, hard=4096)\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:350 vm_limits=\"(soft=unlimited, hard=unlimited)\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.357Z caller=main.go:701 msg=\"Starting TSDB ...\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.368Z caller=web.go:523 component=web msg=\"Start listening for connections\" address=0.0.0.0:9090\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.372Z caller=head.go:644 component=tsdb msg=\"Replaying on-disk memory mappable chunks if any\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:658 component=tsdb msg=\"On-disk memory mappable chunks replay completed\" duration=12.659µs\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:664 component=tsdb msg=\"Replaying WAL, this may take a while\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.380Z caller=head.go:716 component=tsdb msg=\"WAL segment loaded\" segment=0 maxSegment=1\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:716 component=tsdb msg=\"WAL segment loaded\" segment=1 maxSegment=1\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:719 component=tsdb msg=\"WAL replay completed\" checkpoint_replay_duration=48.125µs wal_replay_duration=8.253748ms total_replay_duration=8.343335ms\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.383Z caller=main.go:721 fs_type=EXT4_SUPER_MAGIC\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:724 msg=\"TSDB started\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:850 msg=\"Loading configuration file\" filename=/etc/prometheus/prometheus.yml\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:881 msg=\"Completed loading of configuration file\" filename=/etc/prometheus/prometheus.yml totalDuration=908.135µs remote_storage=6.693µs web_handler=819ns query_engine=1.383µs scrape=400.232µs scrape_sd=41.679µs notify=1.1µs notify_sd=1.847µs rules=1.522µs\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:673 msg=\"Server is ready to receive web requests.\"\n```\nIf you get an error message, double-check that you’ve used YAML syntax in your configuration file and then follow the on-screen instructions to resolve the problem.\n\nNow, halt Prometheus by pressing _CTRL+C_, and then open a new _systemd_ service file.\n\n```\nsudo nano /etc/systemd/system/prometheus.service\n\n```\nThe service file tells _systemd_ to run Prometheus as the prometheus user, with the configuration file located in the _/etc/prometheus/prometheus.yml_ directory and to store its data in the _/var/lib/prometheus_ directory.Copy the following content into the file:\n\n```\n[Unit]\nDescription=Prometheus\nWants=network-online.target\nAfter=network-online.target\n\n[Service]\nUser=prometheus\nGroup=prometheus\nType=simple\nExecStart=/usr/local/bin/prometheus \\\n    --config.file /etc/prometheus/prometheus.yml \\\n    --storage.tsdb.path /var/lib/prometheus/ \\\n    --web.console.templates=/etc/prometheus/consoles \\\n    --web.console.libraries=/etc/prometheus/console_libraries\n\n[Install]\nWantedBy=multi-user.target\n```\n\nFinally, save the file and close your text editor. To use the newly created service, reload systemd.\n\n```\nsudo systemctl daemon-reload\n\n```\nYou can now start Prometheus using the following command:\n\n```\nsudo systemctl start prometheus\n\n```\nTo make sure Prometheus is running, check the service’s status.\n\n```\nsudo systemctl status prometheus\n\n```\nThe output tells you Prometheus’ status, main process identifier (PID), memory use, and more.\n\nIf the service’s status isn’t active, follow the on-screen instructions and re-trace the preceding steps to resolve the problem before continuing the tutorial.\n\n```\n* prometheus.service - Prometheus\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\n   Active: active (running) since Mon 2020-09-14 17:59:48 CEST; 24h ago\n Main PID: 29650 (prometheus)\n    Tasks: 9 (limit: 4915)\n   CGroup: /system.slice/prometheus.service\n           `-29650 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\n```\n\nWhen you’re ready to move on, press _Q_ to quit the status command. Lastly, enable the service to start on boot.\n\n```\nsudo systemctl enable prometheus\n\n```\n\nNow that Prometheus is up and running, we can install an additional exporter to generate metrics about our server’s resources.\n\n## Step 5 — Downloading Node Exporter\n\nTo expand Prometheus beyond metrics about itself only, we’ll install an additional exporter called Node Exporter. Node Exporter provides detailed information about the system, including CPU, disk, and memory usage. Download the current stable version of Node Exporter into your home directory. You can find the latest binaries on [Prometheus download page.](https://prometheus.io/download/)\n\n```\nwget https://github.com/prometheus/node_exporter/releases/download/v1.0.1/node_exporter-1.0.1.linux-amd64.tar.gz\n\n```\nNow, unpack the downloaded archive.\n\n```\ntar xvf node_exporter-1.0.1.linux-amd64.tar.gz\n\n```\nThis will create a directory called _node_exporter-1.0.1.linux-amd64_ containing a binary file named _node_exporter_, a license, and a notice.\n\nCopy the binary to the _/usr/local/bin_ directory and set the user and group ownership to the node_exporter user that you created in Step 1.\n\n```\nsudo cp node_exporter-1.0.1.linux-amd64/node_exporter /usr/local/bin\nsudo chown node_exporter:node_exporter /usr/local/bin/node_exporter\n\n```\nNow that you’ve installed Node Exporter, let’s test it out by running it before creating a service file for it so that it starts on boot.\n\n## Step 6 — Running Node Exporter\n\nThe steps for running Node Exporter are similar to those for running Prometheus itself. Start by creating the Systemd service file for Node Exporter.\n\n```\nsudo nano /etc/systemd/system/node_exporter.service\n\n```\nCopy the following content into the service file:\n\n```\n[Unit]\nDescription=Node Exporter\nWants=network-online.target\nAfter=network-online.target\n\n[Service]\nUser=node_exporter\nGroup=node_exporter\nType=simple\nExecStart=/usr/local/bin/node_exporter --collector.systemd\n\n[Install]\nWantedBy=multi-user.target\n```\n\nSave the file and close your text editor. Finally, reload systemd to use the newly created service.\n\n```\nsudo systemctl daemon-reload\n\n```\nYou can now run Node Exporter using the following command:\n\n```\nsudo systemctl start node_exporter\n\n```\nVerify that Node Exporter’s running correctly with the status command.\n\n```\nsudo systemctl status node_exporter\n\n```\nLike before, this output tells you Node Exporter’s status, main process identifier (PID), memory usage, and more. If the service’s status isn’t active, follow the on-screen messages and re-trace the preceding steps to resolve the problem before continuing.\n\n```\n_Output_\n* node_exporter.service - Node Exporter\n   Loaded: loaded (/etc/systemd/system/node_exporter.service; enabled; vendor preset: enabled)\n   Active: active (running) since Mon 2020-09-14 17:58:25 CEST; 1 day 1h ago\n Main PID: 29612 (node_exporter)\n    Tasks: 7 (limit: 4915)\n   CGroup: /system.slice/node_exporter.service\n           `-29612 /usr/local/bin/node_exporter --collector.systemd\n```\nLastly, enable Node Exporter to start on boot.\n\n```\nsudo systemctl enable node_exporter\n\n```\nWith Node Exporter fully configured and running as expected, we’ll tell Prometheus to start scraping the new metrics.\n\n## Step 7 — Configuring Prometheus to Scrape Node Exporter\n\nBecause Prometheus only scrapes exporters which are defined in the scrape_configs portion of its configuration file, we’ll need to add an entry for Node Exporter, just like we did for Prometheus itself. Open the configuration file.\n\n```\nsudo nano /etc/prometheus/prometheus.yml\n\n```\nAt the end of the scrape_configs block, add a new entry called node_exporter.\n\n```\n...\n  - job_name: 'node_exporter'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9100']\n```\nBecause this exporter is also running on the same server as Prometheus itself, we can use localhost instead of an IP address again along with Node Exporter’s default port, 9100. Your whole configuration file should look like this:\n\n```\nglobal:\n  scrape_interval: 15s\n\nscrape_configs:\n  - job_name: 'prometheus'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9090']\n  - job_name: 'node_exporter'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9100']\n```\nSave the file and exit your text editor when you’re ready to continue. Finally, restart Prometheus to put the changes into effect.\n\n```\nsudo systemctl restart prometheus\n\n```\nOnce again, verify that everything is running correctly with the status command.\n\n```\nsudo systemctl status prometheus\n\n```\nIf the service’s status isn’t set to active, follow the on screen instructions and re-trace your previous steps before moving on.\n\n```\nOutput\n* prometheus.service - Prometheus\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\n   Active: active (running) since Tue 2020-09-15 19:06:56 CEST; 2s ago\n Main PID: 19725 (prometheus)\n    Tasks: 8 (limit: 4915)\n   CGroup: /system.slice/prometheus.service\n           `-19725 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\n```\n\nWe now have Prometheus and Node Exporter installed, configured, and running.\n\n## Step 8 - Adding Robonomic build in node_exporter\n\nAfter successfully installed Prometheus and node_exporter we will have to use build in prometheus exporter in every substrate project. To make this happen we have to add additional entry to _/etc/prometheus/prometheus.yml_. \nOpen the configuration file.\n\n```\nsudo nano /etc/prometheus/prometheus.yml\n\n```\nAt the end of the scrape_configs block, add a new entry called robonomic_exporter.\n\n``` \n  - job_name: 'robonomics_exporter'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9615']\n```\nSave the file and exit your text editor. Your whole configuration file should look like this:\n\n```\nglobal:\n  scrape_interval: 15s\n\nscrape_configs:\n  - job_name: 'prometheus'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9090']\n  - job_name: 'node_exporter'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9100']\n  - job_name: 'robonomics_exporter'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9615']\n```\n\nFinally, restart Prometheus to put the changes into effect.\n\n```\nsudo systemctl restart prometheus\n\n```\nOnce again, verify that everything is running correctly with the status command.\n\n```\nsudo systemctl status prometheus\n\n```\nWe now have _Prometheus_ and _Node Exporter_ as well as _Robonomic Exporter_ installed, configured, and running. Now move on to Grafana\n\n## Step 9 - Setting up Grafana\n\nThe last step is to connect Prometheus as a Data Source in Grafana. For purpose of this tutorial we will use free cloud-based grafana which allow to have up to 5 dashboards as well as dedicated [Robonomics dashboard](https://grafana.com/grafana/dashboards/13015). Simply go to [grafana.com](https://grafana.com/) create new account and login to your newly created grafana instance.\n\nAt the beginning we must add to Grafana new _**Data Source**_ which in our case will be Prometheus server.\nGo to Data Source:\n\n>![DataSource](../images/prometheus-grafana/grafana-6-2020-09-15-19-18-50-Window.png)\n\nThen click **_Add data source_**\n\n>![DataSource](../images/prometheus-grafana/grafana-7-2020-09-15-19-18-50-Window.png)\n\nNext select _**Prometheus**_\n\n>![DataSource](../images/prometheus-grafana/grafana-8-2020-09-15-19-18-50-Window.png)\n\nIn new screen put your **_Prometheus server IP adress with 9090 port_**\n\n> ![DataSource](../images/prometheus-grafana/grafana-9-2020-09-15-19-18-50-Window.png)\n\nAfter that _**Save & Test**_ if you did all steps you should be green and ready to go for importing dashboard. On the main site click to **+** and then **Import** as shown on the pic below:\n\n> ![Import dashboard](../images/prometheus-grafana/grafana-1-2020-09-15-19-18-50-Window.png)\n\nThen you should see Import page:\n\n> ![Import page](../images/prometheus-grafana/grafana-2-2020-09-15-19-18-50-Window.png)\n\nIn the _Grafana.com dashboard url or id_ write _**13015**_ (as this is ID of the Robonomic dashboard)\n\n> ![Import Robonomic dashboard](../images/prometheus-grafana/grafana-3-2020-09-15-19-18-50-Window.png)\n\nAfter loading external dashboard you will get this screen:\n\n> ![XRT 13015 dashboard import](../images/prometheus-grafana/grafana-4-2020-09-15-19-18-50-Window.png)\n\nThe last step is to choose previously created **_Data Source_** and click _**Import**_\n\n> ![Prometheus as a DataSource](../images/prometheus-grafana/grafana-5-2020-09-15-19-18-50-Window.png)\n\nTHAT'S IT ! At this point you should see imported dashboard. \n\n\n## References\n\n* [How To Install Prometheus on Ubuntu 16.04](https://www.digitalocean.com/community/tutorials/how-to-install-prometheus-on-ubuntu-16-04)\n* [Build A Monitoring Dashboard by Prometheus + Grafana](https://medium.com/htc-research-engineering-blog/build-a-monitoring-dashboard-by-prometheus-grafana-741a7d949ec2)\n* [Grafana support for Prometheus](https://prometheus.io/docs/visualization/grafana/)\n* [Monitoring Linux host metrics with the node exporter](https://prometheus.io/docs/guides/node-exporter/)\n* [Querying Prometheus](https://prometheus.io/docs/prometheus/latest/querying/basics/)\n* [Visualizing Node Metrics](https://substrate.dev/docs/en/tutorials/visualize-node-metrics/)\n* [Substrate Prometheus Exporter](https://github.com/paritytech/substrate/tree/master/utils/prometheus)\n* [polkadot-dashboard](https://github.com/w3f/polkadot-dashboard)\n* [Polkadot node metric](https://grafana.com/grafana/dashboards/12425)\n* [Node Exporter for Prometheus Dashboard](https://grafana.com/grafana/dashboards/11074)\n* [Grafana ROBONOMICS (XRT) Metrics](https://grafana.com/grafana/dashboards/13015)\n\n"}},{node:{id:"0a8a7dd2b2330548e64893f1339833cd",title:"Robonomics Liability",path:"/docs/es/robonomics-liability/",content:'\nThe package is responsible for receiving `New Liability` events (`listener` node) and playing topics from `objective` field (`executor` node).\nThe launch file also include `ipfs_channel` node and `signer` node.\n\n## ROS Parameters\n\n### ~web3_http_provider\n\nWeb3 HTTP provider address. The type is `string`, defaults to `http://127.0.0.1:8545`\n\n### ~web3_ws_provider\n\nWeb3 WebSocket provider address. The type is `string`, defaults to `ws://127.0.0.1:8546`\n\n### ~ipfs_http_provider\n\nIPFS HTTP provider address. The type is `string`, defaults to `http://127.0.0.1:5001`\n\n### ~ipfs_swarm_connect_addresses\n\nIPFS nodes to connect to. The type is `string`, defaults to `""`\n\n### ~ipfs_public_providers\n\nA public IPFS node to pin result files. The type is `string`, defaults to `""`\n\n### ~factory_contract\n\nThe name of the liability factory. The type is `string`, defaults to `factory.5.robonomics.eth`\n\n### ~lighthouse_contract\n\nThe name of a lighthouse you are working on. The type is `string`, defaults to `airalab.lighthouse.5.robonomics.eth`\n\n### ~enable_executor\n\nEnable or disable executor node. If it\'s `false`, no topics from objective would be published. The type is `boolean`, defaults to `true`\n\n### ~master_check_interval\n\nPeriod (in seconds) to check master for new topic publications. It\'s necessary for the Recorder, which records all the topics a CPS publishes. The type is `double`, defaults to `0.1`\n\n### ~recording_topics\n\nList of topics name separated by comma. It allows you to specify which topics would be recorded. The type is `string`, defaults to `""`\n\n### ~ens_contract\n\nThe checksumed address of ENS registry. The type is `string`, defaults to `""`\n\n### ~keyfile\n\nPath to keyfile. The type is `string`, defaults to `""`. **Required parameter**\n\n### ~keyfile_password_file\n\nPath to a file with password for the keyfile. The type is `string`, defaults to `""`. **Required parameter**\n\n## Subscribed topics\n\n### /liability/infochan/eth/signing/demand (robonomics_msgs/Demand)\n\n[robonomics_msgs/Demand](/docs/market-messages#demand) message to sign and send further to IPFS channel\n\n### /liability/infochan/eth/signing/offer (robonomics_msgs/Offer)\n\n[robonomics_msgs/Offer](/docs/market-messages#offer) message to sign and send further to IPFS channel\n\n### /liability/infochan/eth/signing/result (robonomics_msgs/Result)\n\n[robonomics_msgs/Result](/docs/market-messages#result) message to sign and send further to IPFS channel\n\n\n## Published topics\n\n### /liability/infochan/incoming/demand (robonomics_msgs/Demand)\n\nContains a [robonomics_msgs/Demand](/docs/market-messages#demand) message which was read from IPFS channel\n\n### /liability/infochan/incoming/offer (robonomics_msgs/Offer)\n\nContains a [robonomics_msgs/Offer](/docs/market-messages#offer) message which was read from IPFS channel\n\n### /liability/infochan/incoming/result (robonomics_msgs/Result)\n\nContains a [robonomics_msgs/Result](/docs/market-messages#result) message which was read from IPFS channel\n\n### /liability/incoming (robonomics_liability/Liability)\n\nContains all the information about the last created [robonomics_liability/Liability](/docs/robonomics-liability-messages#robonomics_liabilityliabilitymsg)\n\n### /liability/ready (robonomics_liability/Liability)\n\nSignals when a [robonomics_liability/Liability](/docs/robonomics-liability-messages#robonomics_liabilityliabilitymsg)is ready for execution\n\n### /liability/complete (robonomics_liability/Liability)\n\nSignals when a [robonomics_liability/Liability](/docs/robonomics-liability-messages#robonomics_liabilityliabilitymsg) has done its job\n\n### /liability/finalized (std_msgs/String)\n\nSignals when a liability has been finalized\n\n## Services\n\n### /liability/start (robonomics_liability/StartLiability)\n\nThe service tells executor to play topics from the objective. It\'s required to pass a liability address ([robonomics_liability/StartLiability](/docs/robonomics-liability-messages#robonomics_liabilitystartliabilitysrv)), which you can get from `/liability/ready` topic\n\n### /liability/finish (robonomics_liability/FinishLiability)\n\nCPS should call the service after performing the task. The input is [robonomics_liability/FinishLiability](/docs/robonomics-liability-messages#robonomics_liabilityfinishiabilitysrv)\n\n### /liability/restart (robonomics_liability/StartLiability)\n\nThe service allows to restart a liability after the system shutdown. The input is [robonomics_liability/StartLiability](/docs/robonomics-liability-messages#robonomics_liabilitystartliabilitysrv)\n\n### /liability/resume (robonomics_liability/StartLiability)\n\nThe service allows to resume a liability from the last timestamp available in the persistence store. The input is [robonomics_liability/StartLiability](/docs/robonomics-liability-messages#robonomics_liabilitystartliabilitysrv)\n\n### /liability/read (robonomics_liability/ReadLiability)\n\nThe service returns all the data about a liability by its address. The input is [robonomics_liability/ReadLiability](/docs/robonomics-liability-messages#robonomics_liabilityreadliabilitysrv)\n'}},{node:{id:"d341a6eaaddf80a84022d3fce7629933",title:"Robonomics Liability Messages",path:"/docs/es/robonomics-liability-messages/",content:"\n## robonomics_liability/Liability.msg\n\n| Field        \t| Type                                                                         \t| Description                                    \t|\n|--------------\t|------------------------------------------------------------------------------\t|------------------------------------------------\t|\n| address      \t| [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) \t| The Liability’s address                        \t|\n| model        \t| [ipfs_commom/Multihash](/docs/ipfs-common-messages#ipfs_commonmultihashmsg)         \t| CPS behavioral model Identifier                \t|\n| objective    \t| [ipfs_commom/Multihash](/docs/ipfs-common-messages#ipfs_commonmultihashmsg)         \t| CPS behavioral model parameters in rosbag file \t|\n| result       \t| [ipfs_commom/Multihash](/docs/ipfs-common-messages#ipfs_commonmultihashmsg)         \t| Liability result hash                          \t|\n| promisee     \t| [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) \t| The promisee address                           \t|\n| promisor     \t| [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) \t| The promisor address (usually CPS)             \t|\n| lighthouse   \t| [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) \t| The address of lighthouse your CPS works on    \t|\n| token        \t| [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) \t| Operational token address                      \t|\n| cost         \t| [ethereum_commom/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg) \t| CPS behavioral model implementation cost       \t|\n| validator    \t| [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) \t| Observing network address                      \t|\n| validatorFee \t| [ethereum_commom/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg) \t| Observing network commission                   \t|\n\n## robonomics_liability/StartLiability.srv\n\n**Request**\n\n| Field     | Type              | Description                                           |\n|---------  |-----------------  |-----------------------------------------------------  |\n| address   | std_msgs/String   | The address of Liability you are willing to execute   |\n\n**Response**\n\n| Field     | Type              | Description                               |\n|---------  |-----------------  |------------------------------------------ |\n| success   | std_msgs/Bool     | Weather or not the Liability was started  |\n| msg       | std_msgs/String   | Status of launch                          |\n\n## robonomics_liability/FinishLiability.srv\n\n**Request**\n\n| Field     | Type              | Description                           |\n|---------  |-----------------  |------------------------------------   |\n| address   | std_msgs/String   | The address of Liability to finish    |\n| success   | std_msgs/Bool     | The status of execution               |\n\n**Response**\n\nThe response is empty\n\n## robonomics_liability/ReadLiability.srv\n\n**Request**\n\n| Field     | Type                                                                          | Description                   |\n|---------  |------------------------------------------------------------------------------ |----------------------------   |\n| address   | [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg)  | The address of a liability    |\n\n**Response**\n\n| Field         | Type                                                                  | Description           |\n|-----------    |---------------------------------------------------------------------  |---------------------  |\n| read          | std_msgs/Bool                                                         | Status of execution   |\n| liability     | [robonomics_liability/Liability](#robonomics_liabilityliabilitymsg)   | Liability             |\n"}},{node:{id:"f1ff8c019012bfb2612ca6f8fd3c6cc9",title:"Robonomics-js",path:"/docs/es/robonomics-js/",content:"\n[Robonomics-js](https://github.com/airalab/robonomics-js) is a simple Javascript library for working with Robonomics Network.\n\n## Installation\n\n```\nnpm install robonomics-js --save\n```\n\nor\n\n```\nyarn add robonomics-js\n```\n\n### Dependencies \n\n* [Web3](https://github.com/ethereum/web3.js/) version 1.2.4\n* [Ipfs](https://github.com/ipfs/js-ipfs) version 0.34.0\n\n\n## Usage \n\nCreates a Robonomics instance\n\n```JavaScript\nconst options = {...};\nconst robonomics = new Robonomics(options);\n```\n\n### options\n\nThe object of properties:\n\n```\noptions.web3\n```\n\nAn instance of [web3.js](https://github.com/ethereum/web3.js/):\n\n```JavaScript\n// metamask\nconst options = {\n  web3: new Web3(window.ethereum),\n  ...\n};\n\n// infura\nconst options = {\n  web3: new Web3(\n    new Web3.providers.WebsocketProvider(\n      \"wss://mainnet.infura.io/ws/v3/0b2f2a5026264b57b6d698b480332e89\"\n    )\n  ),\n  ...\n};\n```\n\n```\noptions.messageProvider\n```\n\nThis is an instance of MessageProviderIpfs which uses a [js-ipfs](https://github.com/ipfs/js-ipfs) node with pubsub support\n\n```JavaScript\nconst ipfs = new Ipfs({\n  repo: 'robonomics-example',\n  relay: {\n    enabled: true,\n    hop: {\n      enabled: true\n    }\n  },\n  EXPERIMENTAL: {\n    pubsub: true\n  },\n  config: {\n    Addresses: {\n      Swarm: [\n        '/dns4/ws-star.discovery.libp2p.io/tcp/443/wss/p2p-websocket-star',\n        '/dns4/1.wsstar.aira.life/tcp/443/wss/p2p-websocket-star/',\n        '/dns4/2.wsstar.aira.life/tcp/443/wss/p2p-websocket-star/',\n        '/dns4/3.wsstar.aira.life/tcp/443/wss/p2p-websocket-star/'\n      ]\n    },\n    Bootstrap: [\n      '/dns4/ams-1.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLer265NRgSp2LA3dPaeykiS1J6DifTC88f5uVQKNAd',\n      '/dns4/lon-1.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLMeWqB7YGVLJN3pNLQpmmEk35v6wYtsMGLzSr5QBU3',\n      '/dns4/nyc-1.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLueR4xBeUbY9WZ9xGUUxunbKWcrNFTDAadQJmocnWm',\n      '/dns4/nyc-2.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLV4Bbm51jM9C4gDYZQ9Cy3U6aXMJDAbzgu2fzaDs64',\n      '/dns4/node0.preload.ipfs.io/tcp/443/wss/ipfs/QmZMxNdpMkewiVZLMRxaNxUeZpDUb34pWjZ1kZvsd16Zic',\n      '/dns4/node1.preload.ipfs.io/tcp/443/wss/ipfs/Qmbut9Ywz9YEDrz8ySBSgWyJk41Uvm2QJPhwDJzJyGFsD6',\n      '/dns4/1.pubsub.aira.life/tcp/443/wss/ipfs/QmdfQmbmXt6sqjZyowxPUsmvBsgSGQjm4VXrV7WGy62dv8',\n      '/dns4/2.pubsub.aira.life/tcp/443/wss/ipfs/QmPTFt7GJ2MfDuVYwJJTULr6EnsQtGVp8ahYn9NSyoxmd9',\n      '/dns4/3.pubsub.aira.life/tcp/443/wss/ipfs/QmWZSKTEQQ985mnNzMqhGCrwQ1aTA6sxVsorsycQz9cQrw'\n    ]\n  }\n})\n\nconst options = {\n  messageProvider: new MessageProviderIpfs(ipfs),\n  ...\n};\n```\n\n```\noptions.account\n```\n\nThis is an account object which will be used to sign messages. It's necessary to specify either account address (that one must be unlocked) or a private key (the address will be recovered from the given private key).\n\nOption `isSignPrefix` tells whether or not a prefix must be appended. Default is `true`.\n\n```JavaScript\nconst options = {\n  account: {\n    address: '0x0000000000000000000000000000000000000000',\n    privateKey: '0x0000000000000000000000000000000000000000000000000000',\n    isSignPrefix: true\n  },\n  ...\n};\n```\n\n```\noptions.ens\n```\n\nThis is a `ens` contract object. This one is not required. If it's necessary you may specify `address` of the contract if the network is not set to mainnet. `suffix` may be `sid` for sidechain or `eth` for mainnet. `eth` is default. `version` is the version of Robonomics Network. Default is the latest deployed version.\n\n```JavaScript\nconst options = {\n  ens: {\n    address: '0x314159265dD8dbb310642f98f50C066173C1259b',\n    suffix: 'eth',\n    version: 5\n  },\n  ...\n};\n```\n\n```\noptions.lighthouse\n```\n\nENS name of a lighthouse, not required. Default is `airalab.lighthouse.5.robonomics.eth`. It's possible to specify only the first part of the name, like `airalab`.\n\n```JavaScript\nconst options = {\n  lighthouse: 'airalab.lighthouse.5.robonomics.eth',\n  ...\n};\n```\n\nIt's necessary to wait until full initialization\n\n```JavaScript\nconst options = {...};\nconst robonomics = new Robonomics(options);\nrobonomics.ready().then(() => {\n  console.log('Robonomics instance ready')\n})\n```\n\n## API\n\n### Messages\n\n#### Demand \n\nThe message specification\n\n```JavaScript\nconst demand = {\n  // REQUIRED\n  model: \"QmSt69qQqGka1qwRRHbdmAWk4nCbsV1mqJwd8cWbEyhf1M\",      // ipfs hash of the model \n  objective: \"QmSt69qQqGka1qwRRHbdmAWk4nCbsV1mqJwd8cWbEyhf2M\",  // ipfs hash of the objective\n  token: robonomics.xrt.address,                                // payment token address\n  cost: 1,                                                      // cost\n  deadline: 9999999,                                            // until which block demand is valid\n\n  // NOT REQUIRED \n  lighthouse: \"0x0000000000000000000000000000000000000000\",     // lighthouse address, by default the initialization address\n  validator: \"0x0000000000000000000000000000000000000000\",      // validator address if necessary\n  validatorFee: 0,                                              // validator fee \n  nonce: 1                                                      // index number \n};\n```\n\n`robonomics.sendDemand`\n\nSigning and broadcasting the demand message. A liability is returned as promise\n\n```JavaScript\nrobonomics.sendDemand(demand).then(liability => {\n  console.log(liability.address);\n});\n```\n\n`robonomics.onDemand`\n\nListens to demand messages with a defined model. If model is `null` returns any demand message.\n\n```JavaScript\nrobonomics.onDemand(model, message => {\n  console.log(message);\n});\n```\n\n#### Offer \n\nThe message specification\n\n```JavaScript\nconst offer = {\n  // REQUIRED \n  model: \"QmSt69qQqGka1qwRRHbdmAWk4nCbsV1mqJwd8cWbEyhf1M\",      // ipfs hash of the model \n  objective: \"QmSt69qQqGka1qwRRHbdmAWk4nCbsV1mqJwd8cWbEyhf2M\",  // ipfs hash of the objective\n  token: robonomics.xrt.address,                                // payment token address\n  cost: 1,                                                      // cost \n  deadline: 9999999,                                            // until which block demand is valid\n\n  // NOT REQUIRED\n  lighthouse: \"0x0000000000000000000000000000000000000000\",     // lighthouse address, by default the initialization address\n  lighthouseFee: 0,                                             // lighthouse fee\n  validator: \"0x0000000000000000000000000000000000000000\",      // validator address if necessary\n  nonce: 1                                                      // index number \n};\n```\n\n`robonomics.sendOffer`\n\nSigns and broadcasts an offer message. A liability is returned as promise\n\n```JavaScript\nrobonomics.sendOffer(offer).then(liability => {\n  console.log(liability.address);\n});\n```\n\n`robonomics.onOffer`\n\nListens to offer messages with a defined model. If model is `null` returns any offer message\n\n```JavaScript\nrobonomics.onOffer(model, message => {\n  console.log(message);\n});\n```\n\n#### Result \n\nThe message specification\n\n```JavaScript\nconst result = {\n  // REQUIRED \n  liability: \"0x0000000000000000000000000000000000000000\",  // liability contract address\n  success: true,                                            // status of the task\n  result: \"QmWXk8D1Fh5XFJvBodcWbwgyw9htjc6FJg8qi1YYEoPnrg\"  // ipfs hash of the rosbag log file\n};\n```\n\n`robonomics.sendResult`\n\nSigns and broadcasts a result message\n\n```JavaScript\nrobonomics.sendResult(result).then(() => {\n  console.log(\"ok\");\n});\n```\n\n`robonomics.onResult`\n\nListens to result messages. These results may be not valid. Valid results are stored in a liability contract\n\n```JavaScript\nrobonomics.onResult(result => {\n  console.log(result);\n});\n```\n\n### Smart Contracts \n\n#### Liability \n\n`liability.getInfo`\n\nReturn a property object of the contract\n\n```JavaScript\nliability.getInfo().then(data => {\n  console.log(data);\n  /*\n  {\n    model,\n    objective,\n    result,\n    token,\n    cost,\n    lighthouseFee,\n    validatorFee,\n    demandHash,\n    offerHash,\n    promisor,\n    promisee,\n    lighthouse,\n    validator,\n    isSuccess,\n    isFinalized\n  }\n  */\n});\n```\n\n`liability.onResult`\n\nWaits until a liability is finished. Returns a result\n\n```JavaScript\nliability.onResult().then(result => {\n  console.log(result);\n});\n```\n\n#### Lighthouse \n\n`robonomics.lighthouse.getInfo`\n\nReturns a property object of the contract\n\n```JavaScript\nrobonomics.lighthouse.getInfo().then(data => {\n  console.log(data);\n  /*\n  {\n    minimalStake,\n    timeoutInBlocks,\n    keepAliveBlock,\n    marker,\n    quota\n  }\n  */\n});\n```\n\n`robonomics.lighthouse.getProviders`\n\nReturns a list of providers on the lighthouse\n\n```JavaScript\nrobonomics.lighthouse.getProviders().then(list => {\n  console.log(list);\n});\n```\n\n##### Creation of a new lighthouse\n\n```JavaScript\nconst minimalFreeze = 1000      // Wn\nconst timeout = 25              // blocks\nconst name = 'mylighthouse'     // lighthouse name\nrobonomics.factory.methods.createLighthouse(minimalFreeze, timeout, name).send({ from: robonomics.account.address })\n    .then((tx) => console.log(tx))\n\nrobonomics.factory.onLighthouse((lighthouse) => {\n    console.log(lighthouse.name)\n})\n```\n\n##### Become a provider \n\nPreliminarily you must call `approve` for the tokens `XRT`\n\n```JavaScript\nconst name = \"mylighthouse\";    // lighthouse name\nconst stake = 1000;             // Wn\nrobonomics.lighthouse.methods\n  .refill(stake)\n  .send({ from: robonomics.account.address })\n  .then(tx => console.log(tx));\n```\n\n#### Token \n\n`robonomics.xrt.getInfo`\n\nReturns property object of the token\n\n```JavaScript\nrobonomics.xrt.getInfo().then(data => {\n  console.log(data);\n  /*\n  {\n    name,\n    totalSupply,\n    decimals,\n    symbol\n  }\n  */\n});\n```\n\n##### Check balance \n\n```JavaScript\nrobonomics.xrt.methods\n  .balanceOf(robonomics.account.address)\n  .call()\n  .then(balance => console.log(balance));\n```\n\n##### Check allowance \n\n```JavaScript\nrobonomics.xrt.methods\n  .allowance(robonomics.account.address, robonomics.factory.address)\n  .call()\n  .then(allowance => console.log(allowance));\n```\n\n##### Approve \n\n```JavaScript\nrobonomics.xrt.methods\n  .approve(robonomics.lighthouse.address, 100)\n  .send({\n    from: robonomics.account.address\n  })\n  .then(tx => console.log(tx));\n```\n\n## Links \n\n- [Website](https://robonomics.network/)\n- [Minimal template of dApp](https://github.com/airalab/vue-dapp-robonomics-template)\n- [dApp example](https://codesandbox.io/s/robonomics-vue-template-ewuiw)\n"}},{node:{id:"81ef4bd537aa1a5b897398c17b87e970",title:"How Robonomics Network Works",path:"/docs/es/robonomics-how-it-works/",content:'\nIn this section we will discuss the Robonomics Network scenario.\n\nThere are few main parts in the Robonomics network:\n\n- IPFS for the messages exchanging\n- the Ethereum blockchain for storing new liability contracts\n- a provider that is responsible for matching messages\n- an agent\n\nLet\'s have a look at the following diagram that describes the scenario without any additional details:\n\n![The main scenario of Robonomics Network](../images/robonomics_network_scenario.jpg "The main scenario of Robonomics Network")\n\nThere are three types of [messages](/docs/market-messages) in IPFS: Demand, Offer, Result.\n\n**Below there is the specification for a Demand message:**\n\n| Field         | Type                      | Description                                       | Example                                           |\n|-------------- |-------------------------  |------------------------------------------------   |------------------------------------------------   |\n| model         | [ipfs_common/Multihash](/docs/robonomics-liability-messages#ipfs_commonmultihashmsg)     | CPS behavioral model Identifier                   | QmfXHZ2YkNC5vRjp1oAaRoDHD8H3zZznfhBPasTu348eWC    |\n| objective     | [ipfs_common/Multihash](/docs/robonomics-liability-messages#ipfs_commonmultihashmsg)     | CPS behavioral model parameters in rosbag file    | QmUo3vvSXZPQaQWjb3cH3qQo1hc8vAUqNnqbdVABbSLb6r    |\n| token         | ethereum_common/Address   | Operational token address                         | 0xbD949595eE52346c225a19724084cE517B2cB735        |\n| cost          | ethereum_common/UInt256   | CPS behavioral model implementation cost          | 1                                                 |\n| lighthouse    | ethereum_common/Address   | Lighthouse address                                | 0xa1b60ED40E5A68184b3ce4f7bEf31521A57eD2dB1       |\n| validator     | ethereum_common/Address   | Observing network address                         | 0x0000000000000000000000000000000000000000        |\n| validatorFee  | ethereum_common/UInt256   | Observing network commission                      | 0                                                 |\n| deadline      | ethereum_common/UInt256   | Deadline block number                             | 6393332                                           |\n| sender        | ethereum_common/Address   | Message sender address                            | 0x0000000000000000000000000000000000000000        |\n| signature     | std_msgs/UInt8[]          | Sender’s digital signature                        | 0x23bc…c617                                       |\n\n\x3c!--\n=============== ============================================================== ================================================ ================================================\n     Field                                   Type                                                Description                                        Example\n=============== ============================================================== ================================================ ================================================\n  model          :ref:`ipfs_common/Multihash <IPFS-Common-Multihash.msg>`       CPS behavioral model Identifier                  QmfXHZ2YkNC5vRjp1oAaRoDHD8H3zZznfhBPasTu348eWC\n  objective      :ref:`ipfs_common/Multihash <IPFS-Common-Multihash.msg>`       CPS behavioral model parameters in rosbag file   QmUo3vvSXZPQaQWjb3cH3qQo1hc8vAUqNnqbdVABbSLb6r\n  token          :ref:`ethereum_common/Address <Ethereum-common-Address.msg>`   Operational token address                        0xbD949595eE52346c225a19724084cE517B2cB735\n  cost           :ref:`ethereum_common/UInt256 <Ethereum-common-UInt256.msg>`   CPS behavioral model implementation cost         1\n  lighthouse     :ref:`ethereum_common/Address <Ethereum-common-Address.msg>`   Lighthouse address                               0xa1b60ED40E5A68184b3ce4f7bEf31521A57eD2dB1\n  validator      :ref:`ethereum_common/Address <Ethereum-common-Address.msg>`   Observing network address                        0x0000000000000000000000000000000000000000\n  validatorFee   :ref:`ethereum_common/UInt256 <Ethereum-common-UInt256.msg>`   Observing network commission                     0\n  deadline       :ref:`ethereum_common/UInt256 <Ethereum-common-UInt256.msg>`   Deadline block number                            6393332\n  sender         :ref:`ethereum_common/Address <Ethereum-common-Address.msg>`   Message sender address                           0x0000000000000000000000000000000000000000\n  signature      std_msgs/UInt8[]                                               Sender\'s digital signature                       0x23bc...c617\n=============== ============================================================== ================================================ ================================================\n--\x3e\n\nAn Offer message has the same fields but instead of `validatorFee` there is a `lighthouseFee` field. This field determines the amount of fee for a lighthouse.\n\nNow let\'s have a look at the following diagram and walk step by step from the moment of publishing messages to a liability finalization.\n\n![Robonomics Network detailed scenario](../images/robonomics_network_detailed_scenario.jpg "Robonomics Network detailed scenario")\n\nA liability contract is created only if the following fields match: `model`, `objective`, `token`, `cost`. A provider of Robonomics Network watches every message and finds those ones that have a match.\nAfter the match is found the provider calls `createLiability(demand, offer)` method from the contract factory where `demand` and `offer` are serialized.\n\nBelow is the package diagram for the Robonomics communication stack:\n\n![Robonomics communication stack](../images/robonomics_network_communication_stack.jpg "Robonomics communication stack")\n\nThe factory deserializes arguments and recovers *promisee* and *promisor* addresses from signatures.\n\nNext step is token transfer. The factory transfers **cost** tokens from the *promisee* address and **validatorFee** and **lighthouseFee** from the *promisor* address to the new liability address.\n\n> - **You should approve sufficient amount of tokens for the factory.**\n> - **It\'s not required to approve tokens from the *promisor* address if fees are null.**\n\nNow the factory emits a NewLiability event with the liability address. An agent gets the address, reads fields, perform a task and at the same time writes a log file in rosbag format.\n\nWhen the work is done the agent sends a Result message with the following fields: hash of the rosbag file, a success flag, a signature. If the **validator** field is not null it means that only validator is able to finalize the liability.\n\nAfter the successful liability finalization the agent gets **cost** tokens. Otherwise, the *promisee* gets tokens back.'}},{node:{id:"42125ccdcfeece681864a23ddcd8392e",title:"Robonomics DApp Overview",path:"/docs/es/robonomics-dapp-overview/",content:"\nYou can operate with Robonomics Network using the interface of [Robonomics Network Dapp (decentralized application)](https://dapp.robonomics.network/#/). It is available in browsers with [Metamask extension](https://metamask.io). On the first page you will see the statistics of the network:\n\n![Robonomics DApp's first page](../images/robonomics_dapp_first_page.jpg \"Robonomics DApp's first page\")\n\nLet's have a look at the bottom table \"Robonomics Telemetry\".\n\nEvery time an instance of AIRA is launched it broadcasts a piece of information about itself. Usually it takes some time for the Dapp to receive data from an instance of AIRA.\n\nHave a brief look at the page [\"AIRA installation\"](/docs/aira-installation) to understand where `IPNS` and `Address Eth` came from.\n\n## IPNS\n\nYou can treat it as a unique identifier of your instance in IPFS network. Under that name AIRA publishes metadata about itself.\n\n## Address Eth\n\nBy default AIRA generates new Ethereum address for you (it's [possible](/docs/aira-faq#how-to-change-ethereum-address-of-aira) to generate new one).\n\nIt's mainly used to sign all the outcoming messages.\n\n## Lighthouse\n\nIn Robonomics Network an agent must choose a lighthouse to work on. By default it's `airalab.lighthouse.5.robonomics.eth`.\n\nYou can choose existing one or create your own on [Lighthouses](https://dapp.robonomics.network/#/lighthouse) page.\n\n## Peers\n\nThe amount of IPFS pubsub [peers](/docs/aira-faq#how-to-check-the-quantity-of-ipfs-peers).\n\n## Date\n\nThe date and time of last update\n\n## Network\n\nRobonomics Network officially works in Ethereum Mainnet.\nThere is also [Sidechain](https://github.com/airalab/airalab-sidechain) which is mostly for testing purpose.\n\n\n"}},{node:{id:"c245ef75f4c1a3cc90373a13cbde180c",title:"Contracts deployment",path:"/docs/es/robonomics-contracts-deployment/",content:"\nRobonomics network works on top of the existing Ethereum network. The protocol is implemented by smart contracts. A source code is on [Github](https://github.com/airalab/robonomics_contracts). Airalab team deploys new version of contracts and supports a current one. \n\nIn this lesson we are going to learn more about these contracts. To do this we will deploy our test copy. Also we are going to use these contracts in the future lessons. \n\nYou need a client running Ethereum node. You can use either one of existing network (e.g. Mainnet, Ropsten, Kovan) or your local one. For testing purpose we suggest to use this [docker container](https://github.com/f-o-a-m/cliquebait) \n\n    $ docker run --rm -d -p 9545:8545 -p 9546:8546 foamspace/cliquebait:latest\n\nNext step is obtain a copy of robonomics contracts source code:\n\n    $ git clone --recursive https://github.com/airalab/robonomics_contracts\n\nA file truffle.js contains available networks for migration. We will work with development network. When you are in `robonomics_contracts` directory install dependencies and run a migration:\n\n    npm install // to install dependencies\n    truffle migrate --network development\n\nIt's time to learn how to create a new lighthouse. For more information about Robonomics network and Lighthouse in particular read [white paper](http://static.robonomics.network/docs/book-the-economy-of-robots-1-2017/robonomics.network-book-the-economy-of-robots-1-2017-en.pdf). Briefly lighthouse o distributes the running time of providers. Every lighthouse serves its own broadcast channel. Ask and Bid messages come into this channel. XRT tokens are used as a payment. \n\nWhen XRT contracts was deployed some tokens were issued on our account. Let's check the balance:\n\n    $ truffle --network development console\n    > xrt = XRT.at(XRT.address)\n    > xrt.balanceOf(web3.eth.accounts[0])\n\nAnd that's how we create a lighthouse:\n\n    > factory = LiabilityFactory.at(LiabilityFactory.address)\n    > tx = factory.createLighthouse(1000, 10, \"test\")\n    > tx.then(x => {laddress = x.logs[0].args.lighthouse})\n    > l = LighthouseLib.at(laddress)\n\nInstead of deploying a lighthouse contract every time we need a new one, we ask a factory to do this job. A `l` variable contains lighthouse instance. The lighthouse should be able to spend our tokens. Let's make an approve and check everything went well:\n\n    > xrt.approve(l.address,1000)\n    > xrt.allowance(web3.eth.accounts[0],l.address)\n\nAnd a very important step is become a worker:\n\n    > l.refill(1000)\n\nEach worker has to put a stake. In this case it's 1000 Wn.\n\nBelow is a table of our addresses:\n\n| Contract          | Address                                       | ENS name                          |\n|------------------ |--------------------------------------------   |---------------------------------- |\n| ENSRegistry       | 0x80c77a7de64a15450bb8cf45ece4fbb7bae6fb49    |                                   |\n| XRT               | 0x673583a369eb3a830a5571208cf6eb7ce83987f8    | xrt.3.robonomics.eth              |\n| LiabilityFactory  | 0x1b3190e00c1903266862af1f31714d4b81ef59b2    | factory.3.robonomics.eth          |\n| Lighthouse        | 0xd2b78c032b6c8851a8b6cbf950caa02a77618d8e    | test.lighthouse.3.robonomics.eth  |\n"}},{node:{id:"ca800a47d24dee3755fff98b1ce9d173",title:"Become a Provider",path:"/docs/es/robonomics-become-a-provider/",content:'\nThis page describes how to create a lighthouse and become a provider in the Robonomics network.\n\n## Prepare an address\n\nFirst of all, an Ethereum address is required. You must have access to a private key of the address. In case you don\'t have one, below are steps to create an address via [Parity](https://www.parity.io/ethereum/).\n\n```\n$ sudo snap install parity\n$ parity.ethkey generate random\nsecret:  15abe71557c07b69537bbe4352ed10a057be89037c69d4b35556112519911539\npublic: 38b800bfd90d486c78c646da79bb94b9d038aca8aad221062ce1b148df7764bfef02f6b3cf931786b6997540b798ea226ae60bd201c222d8f702e408a1a5cbff\naddress: c531fa8f141493df3da264a864bdcbec19695b4c\n```\n\nThe `secret` field is a private key, you\'ll need it to run the provider client. Save it to a file:\n\n```\n$ echo \'0x15abe71557c07b69537bbe4352ed10a057be89037c69d4b35556112519911539\' > private.key\n```\n\nThe next step is to deposit some ethers and XRT tokens to the address which is held in the `address` field.\n\n## Create a lighthouse\n\nGo to the lighthouse [dapp](https://dapp.robonomics.network/#/lighthouse) and fill in a name in the right side:\n\n![The Right Side](../images/become_a_provider_1.jpg "The Right Side")\n\nClick on the `Create lighthouse and connect to the network` button and sign a transaction. After a while you should see:\n\n![Success of Creating a Lighthouse](../images/become_a_provider_2.jpg "Success of Creating a Lighthouse")\n\nNow it\'s time to put a stake. Select the new lighthouse and click `Connect to the network`:\n\n![Selecting the Lighthouse](../images/become_a_provider_3.jpg "Selecting the Lighthouse")\n\nOn this page in the `Provider` section click the `Approve` button, sign a transaction. When it\'s mined click the `Refill` button and do the same.\n\n## Install the client\n\nNow you need to install [robonomics-tools](https://github.com/airalab/robonomics-tools) at least 0.4.2 version. You can build from the source or do the following steps:\n\n**Make sure you have Nix and Stack installed:**\n    \n```\n$ curl -sSL https://get.haskellstack.org/ | sh\n$ curl https://nixos.org/nix/install | sh\n```\n\n* Setup Airalab binary cache at [https://aira.cachix.org](https://aira.cachix.org/)\n* Import Airalab channel:\n\n```\n$ nix-channel --add http://aira.life/channels/aira-unstable/ aira\n$ nix-channel --update\n```\n* Install from the binary cache:\n\n```\n$ nix-env -iA aira.robonomics-tools\n```\n* Run the client:\n\n```\n$ xrtd --lighthouse mobilerobotics.lighthouse.5.robonomics.eth --private $(cat private.key)\n```\n\n**Get familiar with the `xrtd` options via `xrtd --help`.**\n\n## Test the provider\n\nTo test your provider go again to the lighthouse [dapp](https://dapp.robonomics.network/#/lighthouse/) and connect to the just created lighthouse.\n\nAt the bottom you should see the `TEST LIGHTHOUSE` section.\n\nClick on the `Demand` button and then on the `Offer` one. You should see something similar to:\n\n![Demand and Offer messages](../images/provider_mobilerobotics_demand_offer.jpg "Demand and Offer messages")\n\nDon\'t forget to sign every message with the MetaMask extension.\n\nFinally you should see a new liability contract created:\n\n![Liability is created](../images/provider_mobilerobotics_liability.jpg "Liability is created")\n'}},{node:{id:"fcff9004e72379cce0e3fd45feebad6a",title:"Robonomics IO Overview",path:"/docs/es/rio-overview/",content:"\nThe [crate](https://crates.robonomics.network/robonomics_io/index.html) provides a convenient way to interact with blockchain and includes a set of tools. The latest release can be found [here](https://github.com/airalab/robonomics/releases)\n\n```\n% ./robonomics io\nrobonomics-io 0.21.0\nRobonomics Framework I/O operations\n\nUSAGE:\n    robonomics io [FLAGS] [OPTIONS] <SUBCOMMAND>\n\nFLAGS:\n        --dev        Specify the development chain\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nOPTIONS:\n    -d, --base-path <PATH>        Specify custom base path\n        --chain <CHAIN_SPEC>      Specify the chain specification (one of dev, local, or staging)\n    -l, --log <LOG_PATTERN>...    Sets a custom logging filter. Syntax is <target>=<level>, e.g. -lsync=debug\n\nSUBCOMMANDS:\n    help     Prints this message or the help of the given subcommand(s)\n    read     Read information from device\n    write    Write information into device\n```\n\n## The Pipeline Philosophy \n\nThe tool is designed in order to be included in a pipeline chain of processes. From Unix user experience everyone is familiar with commands like:\n\n```\nps aux | grep robonomics\n```\n\nIt means standard output produced by the `ps` program becomes standard input for the `grep` program. \n\nThe `robonomics io` consists of several subcommands with reading, writing abilities or both. It treats everything as a virtual or physical device ([everything is a file](https://en.wikipedia.org/wiki/Everything_is_a_file))\n\n## Read Overview\n\nIn general `read` means it reads data from a device or a network and prints it in `stdout`.\n\nHow to use it for:\n\n* [ipfs](/docs/rio-ipfs)\n* [launch](/docs/rio-launch)\n\n```\n% ./robonomics io read\nrobonomics-io-read 0.4.0\nRead information from device\n\nUSAGE:\n    robonomics io read <SUBCOMMAND>\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nSUBCOMMANDS:\n    help      Prints this message or the help of the given subcommand(s)\n    ipfs      Download data from IPFS storage\n    launch    Robot launch request events\n    pubsub    Subscribe for broadcasing data\n    sds011    Nova SDS011 particle sensor\n```\n\n## Write Overview\n\nUsually it writes data to blockchain or publishes to pubsub channel. \n\nHow to use it for:\n\n* [datalog](/docs/rio-datalog)\n* [ipfs](/docs/rio-ipfs)\n* [launch](/docs/rio-launch)\n\n```\n% ./robonomics io write\nrobonomics-io-write 0.4.0\nWrite information into device\n\nUSAGE:\n    robonomics io write <SUBCOMMAND>\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nSUBCOMMANDS:\n    datalog    Data blockchainization subsystem command\n    help       Prints this message or the help of the given subcommand(s)\n    ipfs       Upload data into IPFS storage\n    launch     CPS launch subsystem command\n    pubsub     Broadcast data into PubSub topic\n```\n\n## Local Testnet\n\nFor testing purpose it's possible to run the development environment:\n\n```\n% ./robonomics --dev --rpc-cors all\n```\n\n`--rpc-cors all` allows the [Dapp](https://parachain.robonomics.network/) to be connected to local node. After launching the node, go to the dapp, click on Robonomics icon in the upper left corner, choose Development and put node's local address\n\n![Robonomics Dapp Connect to Local Node](../images/robonomics-dapp-connect-local.jpg \"Robonomics Dapp Connect to Local Node\")\n\nFinally click Switch and you should be connected to the local node. Check out Accounts tab. There you can create new accounts and transfer tokens.\n\n"}},{node:{id:"b4f301149650664e555414a7e5d7ad81",title:"Robonomics IO Launch",path:"/docs/es/rio-launch/",content:'\nA simple way to turn on and off an IoT device or a robot. Basically sending "ON" will result in `true` state for a device, anything else will result in `false`.\n\nFor the examples the development network is used. Check [this](/docs/robonomics-test-network-manual/) out to set it up for yourself.\n\n## Requirements\n\n* `robonomics` [executable](https://github.com/airalab/robonomics/releases)\n* Accounts on parachain\n\nYou can find instructions on how to create an account [here](/docs/create-account-in-dapp)\n\n## Usage\n\nTo see the result of transaction first of all run `read` part:\n\n```\n% ./robonomics io read launch\n```\n\nNow let\'s turn a robot on:\n\n```\n% echo "ON" | ./robonomics io write launch -r 5CiPPseXPECbkjWCa6MnjNokrgYjMqmKndv2rSnekmSK2DjL -s 0xb046fc3c322e91e14a61ad4f08a3809ee0de7092e73aa9b3c2b642a0f476d4d6\n```\n\nThen you should see in the first terminal window:\n\n```\n% ./robonomics io read launch\n5H3iRnX16DH2sb2RLxMM8UhDZTvJjP84EhhKXv3sCiEDq6bH >> 5CiPPseXPECbkjWCa6MnjNokrgYjMqmKndv2rSnekmSK2DjL : true\n```\n\nLet\'s describe all the accounts and options above.\n\n* `-r 5CiPPseXPECbkjWCa6MnjNokrgYjMqmKndv2rSnekmSK2DjL` means robot\'s address\n* `-s 0xb046fc3c322e91e14a61ad4f08a3809ee0de7092e73aa9b3c2b642a0f476d4d6` private key of the account to launch from (must have tokens for a transaction)\n* `5H3iRnX16DH2sb2RLxMM8UhDZTvJjP84EhhKXv3sCiEDq6bH` address that launches a robot\n* `true` turn it on\n\nIf we pass anything else but "ON" the state becomes `false`\n\n## Remote\nIf your local node is configured differently from defaults or you have a remote node, it\'s possible to specify it with `--remote` option\n\n```\n% echo "ON" | ./robonomics io write launch -r 5CiPPseXPECbkjWCa6MnjNokrgYjMqmKndv2rSnekmSK2DjL -s 0xb046fc3c322e91e14a61ad4f08a3809ee0de7092e73aa9b3c2b642a0f476d4d6 --remote https://ipfs.infura.io:5001/\n```\n\nand\n\n```\n% ./robonomics io read launch --remote https://ipfs.infura.io:5001/\n```\n'}},{node:{id:"b2d18eb9a2e4122d6867c1acc0fec826",title:"Robonomics IO IPFS",path:"/docs/es/rio-ipfs/",content:'\nIt serves downloading and uploading files from/to IPFS network\n\n## Requirements\n\n* `robonomics` [executable](https://github.com/airalab/robonomics/releases)\n* Running [IPFS](https://ipfs.io/#install) daemon \n\n## Write\n\n```\n% echo "Hello Robonomics" | ./robonomics io write ipfs\nQmQAcvgXmcZEjXGibXGFcqdsvvrnWp3BguuubWhzSBZMXy\n```\n\n## Read\n\n```\n% echo QmQAcvgXmcZEjXGibXGFcqdsvvrnWp3BguuubWhzSBZMXy | ./robonomics io read ipfs\nHello Robonomics\n```\n\n## Remote IPFS node\n\nIf your local node is configured differently from defaults or you have a remote node, it\'s possible to specify it with `--remote` option\n\n```\n% echo "Hello Robonomics" | ./robonomics io write ipfs --remote https://ipfs.infura.io:5001/\nQmQAcvgXmcZEjXGibXGFcqdsvvrnWp3BguuubWhzSBZMXy\n```\n\nThe same applies for `read`\n\n'}},{node:{id:"fa9c40d99ac8caccf671b4522f448c54",title:"Robonomics IO Datalog",path:"/docs/es/rio-datalog/",content:'\nDatalog module allows you to store any string on blockchain\n\nhttps://www.youtube.com/watch?v=rs67AMyd-gE\n\nFor the examples the development network is used. Check [this](/docs/robonomics-test-network-manual/) out to set it up for yourself.\n\n## Requirements\n\n* `robonomics` [executable](https://github.com/airalab/robonomics/releases)\n* Account on parachain\n\nYou can find instructions on how to create an account [here](/docs/create-account-in-dapp)\n\n## Write\n\nAssuming local node is running:\n\n```\n% echo "Hello Robonomics" | ./robonomics io write datalog -s 0xb046fc3c322e91e14a61ad4f08a3809ee0de7092e73aa9b3c2b642a0f476d4d6\n```\n\nwhere `0xb046fc3c322e91e14a61ad4f08a3809ee0de7092e73aa9b3c2b642a0f476d4d6` is a private key for the account with tokens.\nIn this example the public key is 5H3iRnX16DH2sb2RLxMM8UhDZTvJjP84EhhKXv3sCiEDq6bH. Let\'s go to the [Dapp](https://parachain.robonomics.network/)\nand see what happened.\n\nIn the Dapp go to Developer -> Chain state. In the "selected state query" list choose datalog and below choose your account. Click plus button on the right and you should see the following:\n\n![Robonomics Chain State Datalog](../images/robonomics-dapp-chain-state-datalog.jpg "Robonomics Chain State Datalog")\n\n## Remote\nIf your local node is configured differently from defaults or you have a remote node, it\'s possible to specify it with `--remote` option\n\n```\n% echo "Hello Robonomics" | ./robonomics io write datalog -s 0xb046fc3c322e91e14a61ad4f08a3809ee0de7092e73aa9b3c2b642a0f476d4d6 --remote https://ipfs.infura.io:5001/\n```\n'}},{node:{id:"1a5abeb66a29f3ab582304099ae8911e",title:"R&D Based on Robonomics Network",path:"/docs/es/r-and-d-based-on-robonomics-network/",content:'\nFor over 4 years, the Robonomics project participants completed 13 R&D projects in the process of writing the current version of the Robonomics platform, including:\n\n### Launching a drone under the control of a decentralized computer.\n2016 - Successful field test of 3DR X8 drone compatibility with Drone Employee software.\nBelow you can observe a workflow in which a person sends a Drone transaction through the Ethereum Blockchain.\n\nhttps://www.youtube.com/watch?v=V_3rcP2Duv0&t=1s\n\n### Management of a fleet of drones in a decentralized network.\n[Distributed Sky](https://airmarket.io/wp-content/uploads/2018/09/Distributed-Sky-Whitepaper-v3.0.pdf) is the backbone of the Unmanned aircraft system traffic management (UTM). It uses a global network of computers to process and store identities, traffic and other sensitive information, and uses cryptography to make the UTM process secure and scalable.\nBelow is the video of Drone Passport agent in action.\n\nhttps://www.youtube.com/watch?v=yxGTOkGkBJ8\n\n### Tokenization of data from IoT devices.\n\nThe 4th industrial revolution is flying the flag of CPSs’ total integration into mass production and rendering services. Machines do not engage in empty talk, they are honest in their work and can be an independent party supplying information, based on algorithmic analysis of which the network itself can emit new units of any value.\nValues based on the labor of machines will be much more interesting for the new generation than other values, the emission of which is built on any other principle. More information available [here](https://blog.aira.life/tokenization-and-the-4th-industrial-revolution-3208022be747)\n\n### Digital markets for robots.\n\n### Industrial zone management with capital.\n[The article](https://ieeexplore.ieee.org/abstract/document/8525391) presents the architecture of communication protocol for modern industrial processes and business based on cyber-physical systems - Industry 4.0. The main attention is paid to one of the key trends of this concept - to economical autonomous agents i.e. to robots or smart things, which are able to make decisions independently about their economic actions. Agents begin to fully participate in business processes, so it is important to automate the processes and ensure formal and secure communication between multiple heterogeneous agents, taking into account the economic component of the industry. The article shows how to organize economic interaction between agents using a peer-to-peer network based on decentralized Blockchain technology and smart contracts. More information about Industry 4.0 may be found in a video below.\n\nhttps://www.youtube.com/watch?v=yuxOF_z70us\n\n### Drones, sensors, and blockchain for monitoring the quality of water on the Volga.\nAs part of [this river project](https://github.com/airalab/drone_on_volga), the drone offers its services through a web application allowing any user to request the service. Typically, the mission generates parameters such as drone position, travel speed, measured water quality parameters, and other minor requirements.\nThe Robonomics network is used to communicate with the robot. With its help, the robot can offer its services, and citizens or government officials can order them by making a cryptocurrency payment through the website. The Robonomics network is built on the Ethereum blockchain platform and the IPFS protocol, which record the hash of sensor measurements in the public blockchain and thus protect historical data from possible falsification.\nFascinating video about experiments with water drone is below.\n\nhttps://www.youtube.com/watch?v=Mtqm5y6Bolo\n\n### Civilian observatory networks.\nIn August 2018 Airalab with support of Smart Distribution (Libelium distributor in Russia) [set up a measuring network in a living district in Tolyatti, Russia](https://www.libelium.com/libeliumworld/success-stories/preventing-asthsma-sensor-network-air-quality-pm10-dust-in-play-area/).\nThe aim was to create the basis for the implementation of an air quality monitoring network in areas of special vulnerability (schools, playgrounds, nursing homes, hospitals, etc.) that can provide local authorities with information to take measures to protect their citizens.\nAn example of using a sensor is shown in a video below. Also, source code may be found [here](https://github.com/airalab/sensors-connectivity).\n\nhttps://www.youtube.com/watch?v=shqey3tmNUk\n\n### Robot artist Gaka-chu.\nModern technologies make human life more comfortable and more fun, freeing up time for reflection and experimentation.\nIt was a series of reflections on the static nature of the industry that led the development team to the idea of ​​conducting an experiment showing the autonomous transformation of production for a specific type of product.\nSuch an experiment became a [robot artist](https://github.com/airalab/robot_painter/) - a small, clumsy KUKA manipulator living in a large world of serious industrial robots. And his name is Gaka-chu. Why? Because of the love of drawing: "gaka" in Japanese is "artist". And "chu" was added for an inexplicable love for Pokemons.\n\nhttps://youtu.be/xSD_lsrAA0I\n\n### Issuance of green certificates based on the data from renewable energy sources.\nThe conceptual goal of [DAO IPCI](https://ipci.io/ru/) is to provide a common space, common environment, tools and ecosystem that is universal, reliable, easy to use, allowing a variety of stakeholders, including businesses and people, to record quantitative impacts and quantitative commitments, invest in negative impact mitigation projects, offset the carbon footprint, acquire and trade mitigation results, join existing programs or launch new ones. Source code is provided [here](https://github.com/DAO-IPCI/DAO-IPCI).\n\nhttps://www.youtube.com/watch?v=q9plB0TjUnw&list=PLLepqB9oh7WvUVzbeaiwQojrip2tLPA6P\n\n### Roadspace negotiation for autonomous cars.\nOur goal was to develop a [decentralized system](https://github.com/khssnv/mobi_grand_challenge) for road space negotiation where autonomous vehicles can pay for routes and right of way. We believe a market-based approach can be used to alleviate a traffic congestion problem.\n\nhttps://youtu.be/JFQTknMZOYg\n\n### Blockchain in the tasks of the chemical industry.\nOriginally the following task was set: developing a [quality control system](https://github.com/Vourhey/chemistry-quality-control) for the production of a certain chemical product. Why is monitoring the quality so important here? The main active substance of this chemical product is chlorine dioxide. It is hazardous to health in high concentrations. And if the concentration is below normal, then this chemical product is useless.\nAnd what does Blockchain have to do with it? Blockchain helps building trust to the manufacturing company. The consumer knows that no one can change the information in the Blockchain. That means that the manufacturing company can not forge the results of the audit.\n\n### Control of equipment maintenance process by supply chain participants based on IoT data.\n\n### Robot as a service in service robotics.\nRobonomics is the ready-to-work and open-source platform which you can use to connect your robot as a service for end-users, they call it [‘Robot-as-a-Service’](https://blog.aira.life/how-can-you-hire-a-robot-176ba29da565). Robonomics support Web3 technologies that implement the exchange of technical and economic information between humans and machines. Robonomics is a purely technical and open source project.\n\nhttps://www.youtube.com/watch?v=IEgvXcj3nSo'}},{node:{id:"acf573ae9783f464eb74aeeadbbfbd64",title:"Playground Overview",path:"/docs/es/playground-overview/",content:"\nRobonomics allows to use robots as autonomous agents that receive commands from a human or another robot and do some useful work, storing a report of their actions in Blockchain. The interaction between the robot and the Robonomics platform is quite simple with a [Robonomics IO](/docs/rio-overview).\n## What Robots You Can Control\nThe playground section contains examples of connecting different robots to Robonomics which everyone can try to repeat step by step. In this section you can try to control:\n* [an Unmanned Aerial Vehicle](/docs/iris-drone/)\n* [a Mars Rover](/docs/connect-mars-curiosity-rover-under-robonomics-parachain-control/)\n* [a Manipulator](/docs/kuka/)\n* [an industrial Baxter Robot](/docs/baxter2/)\n\nSince all robots are available as simulation models, you don't need any special hardware. So you can try to connect the robot to Robonomics Network right now.\n## How Do You Control the Robot\nAll of our Demos are launched in a local network, however you can connect a robot to the live networks in the same way.\n\nAll Demos in this section follow a similar scenario. You [create an account](/docs/create-account-in-dapp/) for the robot and send him some units for paying transactions. Then the user sends an `ON/OFF` transaction to the robot's address, the robot receives it and starts working. After the job is done the telemetry is saved in IPFS and the file hash is sent to datalog. So at any time you can see how the robot performed its work.\n## Connect Your Own Robot\nIn addition you can create your own control package for any ROS-compatitable device with [this](/docs/connect-any-ros-compatitable-robot-under-robonomics-parachain-control-1/) instruction.\n\n"}},{node:{id:"34476dbf1a4ed87df72a1262ab4f9d5e",title:"Market messages",path:"/docs/es/market-messages/",content:"\nMarket messages is used for exchange **Demand** and **Offer** information. It also used for delivery **Result** messages with liability execution reports.\n\n> This is spec for Robonomics `Generation 5`.\n\n- Currently for message delivery is used [IPFS PubSub](https://ipfs.io/blog/25-pubsub/) broadcaster.\n- IPFS PubSub **topic** is set according to *Lighthouse [ENS](https://ens.domains/) name*.\n\n## Messages content\n\nRobonomics market message use [JSON](https://www.json.org/) data format.\n\n\n### Demand\n\n| Field | ROS Type | Description |\n|-------------- |-------------------------  |------------------------------------------------ |\n| model | [ipfs_common/Multihash](/docs/ipfs-common-messages#ipfs_commonmultihashmsg) | CPS behavioral model identifier |\n| objective | [ipfs_common/Multihash](/docs/ipfs-common-messages#ipfs_commonmultihashmsg) | CPS behavioral model parameters in rosbag file |\n| token | [ethereum_common/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) | Operational token address |\n| cost | [ethereum_common/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg) | CPS behavioral model execution cost |\n| lighthouse | [ethereum_common/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) | Lighthouse contract address |\n| validator | [ethereum_common/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) | Observing network address |\n| validatorFee  | [ethereum_common/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg) | Observing network fee |\n| deadline | [ethereum_common/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg) | Deadline block number |\n| nonce | [ethereum_common/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg) | Robonomics message counter |\n| sender | [ethereum_common/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) | Message sender address |\n| signature | std_msgs/UInt8[] | Sender’s Ethereum signature |\n\n### Offer\n\n| Field             | ROS Type                  | Description                                       |\n|---------------    |-------------------------  |------------------------------------------------   |\n| model             | [ipfs_commom/Multihash](/docs/ipfs-common-messages#ipfs_commonmultihashmsg)     | CPS behavioral model identifier                   |\n| objective         | [ipfs_commom/Multihash](/docs/ipfs-common-messages#ipfs_commonmultihashmsg)     | CPS behavioral model parameters in rosbag file    |\n| token             | [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg)   | Operational token address                         |\n| cost              | [ethereum_commom/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg)   | CPS behavioral model execution cost               |\n| validator         | [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg)   | Observing network address                         |\n| lighthouse        | [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg)   | Lighthouse contract address                       |\n| lighthouseFee     | [ethereum_commom/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg)   | Liability creation fee                            |\n| deadline          | [ethereum_commom/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg)   | Deadline block number                             |\n| nonce             | [ethereum_commom/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg)   | Robonomics message counter                        |\n| sender            | [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg)   | Message sender address                            |\n| signature         | std_msgs/UInt8[]          | Sender’s Ethereum signature                       |\n\n### Result\n\n| Field         | ROS Type                  | Description                       |\n|-----------    |-------------------------  |---------------------------------- |\n| liability     | [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg)   | Liability contract address        |\n| result        | [ipfs_commom/Multihash](/docs/ipfs-common-messages#ipfs_commonmultihashmsg)     | Liability result multihash        |\n| success       | std_msgs/Bool             | Is liability executed successful  |\n| signature     | std_msgs/UInt8[]          | Sender’s Ethereum signature       |\n\n## Messages signing\n\nBefore signing the messages is packed using [abi.encodePacked](https://solidity.readthedocs.io/en/latest/abi-spec.html#non-standard-packed-mode\n) solidity finction and hashed by Keccak_256.\n\n```\n   demandHash = keccak256(abi.encodePacked(\n        _model\n      , _objective\n      , _token\n      , _cost\n      , _lighthouse\n      , _validator\n      , _validator_fee\n      , _deadline\n      , IFactory(factory).nonceOf(_sender)\n      , _sender\n      ));\n```\n\n**`nonce` parameter is counted by factory smart contract and incremented for each created liability smart contract.**\n\nMessage hash are signed using Ethereum ``secp256k1`` [signature](https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign).\n"}},{node:{id:"65a7879062175f4faae1d80dd6bcb90e",title:"Control Kuka manipulator with robonomics",path:"/docs/es/kuka/",content:"\nVideo with an example of work can be found here:\n\n[https://youtu.be/Fhf9LIt6zXQ](https://youtu.be/Fhf9LIt6zXQ)\n***\n## Requirements\n* ROS melodic, Gazebo (installation instraction [here](http://wiki.ros.org/melodic/Installation/Ubuntu))\n* Some extra packages\n```bash\nsudo apt-get install ros-melodic-gazebo-ros-control ros-melodic-effort-controllers ros-melodic-joint-state-controller\n```\n* IPFS 0.4.22 (download from [here](https://www.npackd.org/p/ipfs/0.4.22) and install)\n```bash\ntar -xvzf go-ipfs_v0.4.22_linux-386.tar.gz\ncd go-ipfs/\nsudo bash install.sh\nipfs init\n```\n* pip\n```bash\nsudo apt install python-pip\n```\n* ipfshttpclient\n```bash\npip install ipfshttpclient\n```\n* Robonomics node (binary file) (download latest release [here](https://github.com/airalab/robonomics/releases))\n* IPFS browser extension (not necessary)\n***\n## Installation\nInstall Kuka manipulator and control packages\n```bash\ncd catkin_ws/src/\ngit clone https://github.com/orsalmon/kuka_manipulator_gazebo\ngit clone https://github.com/LoSk-p/kuka_controller\ncd ..\ncatkin_make\necho \"source /home/$USER/catkin_ws/devel/setup.bash\" >> ~/.bashrc\n```\n***\n## Running gazebo model\n```bash\nroslaunch manipulator_gazebo manipulator_empty_world.launch\n```\nIn a new window\n```bash\nrosrun manipulator_gazebo move_arm_server\n```\n![model](../images/kuka-demo/gazebo.jpg)\n***\n## Running robonomics\nGo to the folder with robonomics file ad create a local robonomics network:\n```bash\n./robonomics --dev --rpc-cors all\n```\n\n![robonomics](../images/kuka-demo/robonomics.jpg)\n\n**Important!** Before next launches it is necessary to remove a directory `db` with\n\n```\nrm -rf /home/$USER/.local/share/robonomics/chains/dev/db\n```\n\nGo to https://parachain.robonomics.network and switch to local node\n\n![local](../images/kuka-demo/local.jpg)\n\nThen go to Accounts and create KUKA and WORK accounts. Save account's addresses and keys, you will need them later\n\n![acc](../images/kuka-demo/create_account.jpg)\n\n![accs](../images/kuka-demo/accounts.jpg)\n***\n## Running ipfs\nRun ipfs daemon:\n```bash\nipfs daemon\n```\n***\n## Running control package\nIn kuka_control package path you need to edit move_arm_client.py. \n```bash\ncd src/\nnano move_arm_client.py\n```\nChange kuka_address, kuka_key and work_address to you addresses and key, then change robonomics_path to your path to file robonomics.\n\n![code](../images/kuka-demo/code.jpg)\n\nNow you can run control script:\n```bash\npython move_arm_client.py\n```\n![control](../images/kuka-demo/control.jpg)\n\nThen in a new window send a transaction to make Kuka move:\n```bash\necho \"ON\" | ./robonomics io write launch -r <KUKA_ADDRESS> -s <WORK_KEY>\n```\nWhere <KUKA_ADDRESS> and <WORK_KEY> are address and key from your accounts:\n\n![transaction](../images/kuka-demo/transaction.jpg)\n\nIn the window with kuka_control package you will see:\n\n![done](../images/kuka-demo/done.jpg)\n\nThen go Developer/Chain state on the Robonomics portal, select datalog in query and add KUKA datalog with button '+':\n\n![datalog](../images/kuka-demo/datalog.jpg)\n\nNow you can find Kuka's telemetry using this hash in IPFS Companion:\n\n![ipfs](../images/kuka-demo/ipfs.jpg)\n\n![telemetry](../images/kuka-demo/telemetry.jpg)\n\n## Troubleshooting\n\nIf `catkin_make` doesn't work with the message that it can't find MoveArm.h, try to remove last four lines in CMakeLists.txt in kuka_manipulator_gazebo package:\n```\ninclude_directories(include ${catkin_INCLUDE_DIRS})\n\nadd_executable(move_arm_server src/move_arm_server.cpp)\ntarget_link_libraries(move_arm_server ${catkin_LIBRARIES})\nadd_dependencies(move_arm_server beginner_tutorials_gencpp)\n```\nDo `catkin_make` without these lines, then returm them and do `catkin_make` again.\n\n\n\n\n"}},{node:{id:"39a3cb11b7ee382066ce4aa3ad1b6a2b",title:"Drone control with robonomics",path:"/docs/es/iris-drone/",content:'\n**Drone starts moving after transcation and store file with the coordinates in IPFS. The control script is based on the [GAAS demo script](https://github.com/generalized-intelligence/GAAS)**  \n\nhttps://youtu.be/4CwtGAX1OwM\n\n## Requirements\n* dependencies for control:\n``` sh\nsudo apt install -y \\\n\tpython3-pip \\\n\tninja-build \\\n\texiftool \\\n\tpython-argparse \\\n\tpython-empy \\\n\tpython-toml \\\n\tpython-numpy \\\n\tpython-yaml \\\n\tpython-dev \\\n\tpython-pip \\\n\tninja-build \\\n\tprotobuf-compiler \\\n\tlibeigen3-dev \\\n\tgenromfs\n```\n```sh \npip3 install \\\n\tpandas \\\n\tjinja2 \\\n\tpyserial \\\n\tcerberus \\\n\tpyulog \\\n\tnumpy \\\n\ttoml \\\n\tpyquaternion\n```\n* ROS Melodic + Gazebo [installation tutorial](http://wiki.ros.org/melodic/Installation)\n* extra packages: \n``` bash \nsudo apt-get install ros-melodic-gazebo-ros-control ros-melodic-effort-controllers ros-melodic-joint-state-controller\nsudo apt-get install python-jinja2\nsudo apt-get install python-catkin-pkg\nsudo apt-get install python3-catkin-pkg-modules\n```\n* IPFS verson 0.4.22\n```bash\nwget https://dist.ipfs.io/go-ipfs/v0.4.22/go-ipfs_v0.4.22_linux-amd64.tar.gz\ntar -xvzf go-ipfs_v0.4.22_linux-amd64.tar.gz\ncd go-ipfs\nsudo bash install.sh\nipfs init\n```\n* ipfshttpclient\n```sh\npip3 install ipfshttpclient\n```\n* Robonomics node (binary file) (download latest release [here](https://github.com/airalab/robonomics/releases))\n## Environment Setup\n```bash \nsudo apt-get install ros-melodic-mavros ros-melodic-mavros-extras\nwget https://raw.githubusercontent.com/mavlink/mavros/master/mavros/scripts/install_geographiclib_datasets.sh\nsudo ./install_geographiclib_datasets.sh\ncd ~/catkin_ws/src\ngit clone https://github.com/PX4/Firmware.git\ncd Firmware\ngit checkout v1.9.0\nbash ./Tools/setup/ubuntu.sh\n```\n```bash\ncd ~/catkin_ws/src\ngit clone https://github.com/generalized-intelligence/GAAS.git\ncp -r ~/catkin_ws/src/GAAS/simulator/models/* ~/catkin_ws/src/Firmware/Tools/sitl_gazebo/models/\ncp -r ~/catkin_ws/src/GAAS/simulator/worlds/* ~/catkin_ws/src/Firmware/Tools/sitl_gazebo/worlds/\ncp -r ~/catkin_ws/src/GAAS/simulator/posix-config/* ~/catkin_ws/src/Firmware/posix-configs/SITL/init/ekf2/\n```\n\nModifying your `.bashrc` file, adding the following lines to the bottom:  \n\n`source ~/catkin_ws/devel/setup.bash `  \n`source ~/catkin_ws/src/Firmware/Tools/setup_gazebo.bash ~/catkin_ws/src/Firmware/ ~/catkin_ws/src/Firmware/build posix_sitl_default `   \n`export GAZEBO_MODEL_PATH=:~/catkin_ws/src/simulator/models`  \n`export ROS_PACKAGE_PATH=$ROS_PACKAGE_PATH:~/catkin_ws/src/Firmware`  \n`export ROS_PACKAGE_PATH=$ROS_PACKAGE_PATH:~/catkin_ws/src/Firmware/Tools/sitl_gazebo`  \n`export GAZEBO_MODEL_PATH=:~/catkin_ws/src/simulator/models:~/catkin_ws/src/GAAS/simulator/models`  \n\n  \n## Control Package Installation\nIn a new Terminal:\n```bash\ncd catkin_ws/src\ngit clone https://github.com/tubleronchik/robonomics_drone_sim.git\ncd ..\ncatkin build\n```\n## Robonomics Network\nTo create a local robonomics network go to the folder with the robonomic binary file and run:  \n`./robonomics --dev --rpc-cors all`  \n\nAdd robonomic\'s path to `config.py`\n\n![IPFS](../images/iris-drone-demo/IPFS.jpg)\n\nGo to the [Robonomics Portal](https://parachain.robonomics.network) and switch to local node.\n![localNode](../images/iris-drone-demo/localNode.jpg)\n\nGo to **Accounts** and create **DRONE** and **EMPLOYER** accounts. Save the account names and keys and path to **robonomics** to `~/catkin_ws/src/drone_sim/src/config.py`. Transfer some money into the accounts.\n\n![accounts](../images/iris-drone-demo/addingAcc.jpg)\n\n## Running Simulation\nRun IPFS daemon\n```bash\ncd go-ipfs\nipfs daemon\n```\nIn another terminal launch the simulation:\n```bash\nroslaunch px4 mavros_posix_sitl.launch\ncd ~/catkin_ws/src/robonomics_drone_sim/src\npython3 takeoff.py\n```\nWaiting till "Waiting for payment" \n\n![launch](../images/iris-drone-demo/launch.jpg)\n\nTo send a transaction run in another window:\n`echo "ON" | ./robonomics io write launch -r <drone_addres> -s <employer_key>` - where **<drone_address>** and **<employer_key>** should be replaced with the strings from `config.py` accordingly.\n\nAfter data was pushed to IPFS, go to the **Chain State** in [Robonomics Portal](https://parachain.robonomics.network). Select **datalog** in query and add DRONE datalog using `+` button.\n\n![datalog](../images/iris-drone-demo/datalog.jpg)\n\nYou can find drone\'s telemetry running `https://gateway.ipfs.io/ipfs/<hash>` inserting the hash from above.\n\n![output](../images/iris-drone-demo/output.jpg)\n\nIt\'s important to remove `db` derictory before next launches using  \n` rm -rf ~/.local/share/robonomics/chains/dev/db`\n'}},{node:{id:"ccf722d51a19b02425c149e5d13c1d07",title:"IPFS Common",path:"/docs/es/ipfs-common/",content:'\nThe package handle IPFS connections, provides useful services for working with IPFS Network. \nIt\'s included in `robonomics_liability` launch file\n\n## ROS Parameters\n\n### ~lighthouse_contract\n\nThe name of a lighthouse you are working on. The type is `string`, defaults to `airalab.lighthouse.5.robonomics.eth`\n\n### ~ipfs_http_provider\n\nIPFS HTTP provider address. The type is `string`, defaults to `http://127.0.0.1:5001`\n\n### ~ipfs_public_providers\n\nA public IPFS node to pin result files. The type is `string`, defaults to `""`\n\n### ~ipfs_file_providers\n\nA list of public nodes to pin result files. The type is `list of strings`, defaults to `[ipfs_public_providers]`\n\n### ~ipfs_swarm_connect_addresses\n\nIPFS nodes to connect to. The type is `string`, defaults to `""`\n\n### ~ipfs_swarm_connect_to\n\nA list of IPFS nodes to connect to. The type is `list of strings`, defaults to `[ipfs_swarm_connect_addresses]`\n\n## Subscribed topics'}},{node:{id:"23f5dc4e60e2a57bd6fc99d65bb5c9eb",title:"IPFS Common Messages",path:"/docs/es/ipfs-common-messages/",content:"\n## ipfs_common/Filepath.msg\n\n| Field         | Type                  | Description           |\n|------------   |-------------------    |--------------------   |\n| filepath      | std_msgs/String       | A path to a file      |\n\n## ipfs_common/Multihash.msg\n\n| Field         | Type              | Description                               |\n|-----------    |-----------------  |------------------------------------------ |\n| multihash     | std_msgs/String   | A wrapper for model and objective fields  |\n\n## ipfs_common/IpfsDownloadFile.srv\n\n**Request**\n\n| Field         | Type                                                  | Description               |\n|-------------- |---------------------------------------------------    |------------------------   |\n| ipfs_address  | [ipfs_common/Multihash](#ipfs_commonmultihashmsg)     | IPFS hash of a file       |\n| file          | [ipfs_common/Filepath](#ipfs_commonfilepathmsg)       | Where to save the file    |\n\n**Response**\n\n| Field         | Type              | Description           |\n|-----------    |-----------------  |---------------------  |\n| success       | std_msgs/Bool     | Status of execution   |\n| error_msg     | std_msgs/String   | Error message         |\n\n## ipfs_common/IpfsUploadFile.srv\n\n**Request**\n\n| Field     | Type                                              | Description                               |\n|-------    |-------------------------------------------------  |---------------------------------------    |\n| file      | [ipfs_common/Filepath](#ipfs_commonfilepathmsg)   | Path to a file to be uploaded to IPFS     |\n\n**Response**\n\n| Field         | Type                                                  | Description                   |\n|-------------- |---------------------------------------------------    |----------------------------   |\n| success       | std_msgs/Bool                                         | Status of execution           |\n| error_msg     | std_msgs/String                                       | Error message                 |\n| ipfs_address  | [ipfs_common/Multihash](#ipfs_commonmultihashmsg)     | IPFS hash of uploaded file    |\n"}},{node:{id:"b35c34fd1b2448efc33573e17cccfe83",title:"IoT Sensors Connectivity",path:"/docs/es/iot-sensors-connectivity/",content:"\nRobonomics Network allows you to communicate with any sensor you wish and get data from the sensor all around the world. This data can be transferred to different destinations.\n\nOn this page you'll find step-by-step instructions to connect an ESP board to the connectivity server provided by AiraLab.\n\n## Requirements\n\n* ESP8266/ESP32 like board with WiFi\n\n## 1. Get the software\n\n### On Windows\n\nInstall [WSL](https://docs.microsoft.com/en-us/windows/wsl/install-win10).\n\nInstall Ubuntu via Windows Store:\n\n![Windows Store](../images/windows_store.jpg \"Windows Store\")\n\nand clone the [package](https://github.com/airalab/sensors-connectivity)\n\n```\ngit clone https://github.com/airalab/sensors-connectivity\n```\n\nThe next step is to install python and dependencies:\n\n```\nsudo apt update && sudo apt install python3-pip\ncd sensors-connectivity\npip3 install -r requirements.txt\n```\n\n### On Ubuntu\n\n```\nsudo apt update && sudo apt install python3-pip git\ngit clone https://github.com/airalab/sensors-connectivity\ncd sensors-connectivity\npip3 install -r requirements.txt\n```\n\n> You can ignore such warnings:\n>\n> ```\n> The script ... is installed in '...' which is not on PATH.\n> Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.\n> ```\n\n### On NixOS\n\n```\ngit clone https://github.com/airalab/sensors-connectivity\ncd sensors-connectivity\nnix build -f release.nix\nsource result/setup.bash\n```\n"}},{node:{id:"c793a529194bc3d18d4ec28793c480fb",title:"IoT Firmware Upload",path:"/docs/es/iot-firmware-upload/",content:"\nThere are few firmwares for ESP like boards:\n\n* [Ping](https://github.com/airalab/sensors-connectivity/tree/master/boards/esp/ping)\n* [TCP](https://github.com/airalab/sensors-connectivity/tree/master/boards/esp/tcp)\n* [Mobile GPS](https://github.com/airalab/sensors-connectivity/tree/master/boards/esp/mobile_gps)\n\nThere is a script to upload a firmware for each one, called `flash_firmware.py`. It's located in the root of the repository\n\n> **Requirements**\n> In order to install all dependencies run in the root of the repository folder:\n>\n> ```\n> pip install -r requirements.txt\n> ```\n>\n> Python3 is required!\n\nUsually in order to upload a firmware to your board follow these steps:\n\n1. Assemble the board and connect it to PC\n2. Edit a `config.yaml` in a corresponding folder (e.g. `boards/esp/tcp/config.yaml`)\n3. Run `python flash_firmware.py -s PATH_TO_FOLDER -c PATH_TO_CONFIG` where `PATH_TO_FOLDER` is a path to the desired firmware (e.g. `boards/esp/ping`) and `PATH_TO_CONFIG` is a path to the configuration file (e.g. `boards/esp/ping/config.yaml`)\n\n"}},{node:{id:"134170379c560c22dfe0da7a9f4d601e",title:"Interactuar con AIRA",path:"/docs/es/interact-with-aira/",content:'\nEn este punto, debe estar familiarizado con una [DApp](/docs/get-weather-on-fuji-mountain/) y cómo iniciar [la imagen AIRA](/docs/aira-installation-on-vb/). Ahora está listo para hacer cosas más complicadas como instalar un paquete e interactuar con él a través de DApp.\n\n> **Importante:**\n> asegúrese de haber cubierto las lecciones anteriores antes de continuar.\n\n\n> **Consejo:**\n> durante la lección, escribirás algunos comandos en la terminal. La imagen AIRA no es compatible con el portapapeles, por lo que, para facilitar la vida, eche un vistazo a [Connect via SSH](/docs/aira-connecting-via-ssh/) e inicie sesión a través de SSH en la VM\n\nVideo tutorial:\n\nhttps://www.youtube.com/embed/QM06l07_wuA\n\n## Instalación del Paquete\n\nDespués de iniciar AIRA e iniciar sesión con su terminal, haga lo siguiente:\n\n```\nsu liability && cd\ngit clone https://github.com/vourhey/hello_aira\ncd hello_aira\nnix build -f release.nix\nsource result/setup.bash\nrosrun hello_aira hello_aira\n```\n\nEjecute uno por uno los comandos anteriores. Después del último, debería ver un enlace a DApp generado específicamente para su instancia.\n\n![Terminal con AIRA](../images/aira_hello_terminal.jpg "Terminal con AIRA")\n\nHaga clic en el enlace, debería mostrarse la DApp.\n\n## DApp \n\nConecte [MetaMask](http://metamask.io/) si se le solicita y haga clic en el botón.\n\n![Solicitar conexión en Robonomics Dapp](../images/aira_hello_dapp.jpg "Solicitar conexión en Robonomics Dapp")\n\nFirme el mensaje como de costumbre y espere el resultado.\n\n![Espere el resultado de la solicitud](../images/aira_hello_dapp_2.jpg "Espere el resultado de la solicitud")\n\nMientras tanto, echa un vistazo a la terminal. Deberías ver el saludo.\n\n![Saludo de AIRA en la terminal](../images/aira_hello_terminal_2.jpg "Saludo de AIRA en la terminal")\n\nAl final aparecerá el saludo en la DApp.\n\n![Saludo de la DApp de Robonomics para AIRA](../images/aira_hello_dapp_3.jpg "Saludo de la DApp de Robonomics para AIRA")\n\n## Solución de Problemas\n\n### Usted haga click en “Request Current Values” pero no ve el saludo\n\nProbablemente acaba de lanzar AIRA e IPFS no ha terminado de inicializarse. Espere un minuto y vuelva a intentarlo.\n\n### Si ves el Hash de respuesta pero los datos no aparecen\n\nLo más probable es que el problema provenga de la conexión IPFS. Haga clic en hash y verá el resultado. No es necesario descargar el archivo.\n\n## Tarea para el Hogar (Opcional)\n\nSi está familiarizado con [Python](https://www.python.org/), cambie el texto mostrado por algo diferente y complete la lección con su versión de `hello_aira`\n\n- Haz una bifurcación del [repositorio](https://github.com/vourhey/hello_aira)\n- El texto de salida se encuentra [aquí](https://github.com/Vourhey/hello_aira/blob/master/scripts/hello_aira#L45)\n'}},{node:{id:"3f4e86f7e342d09f48dccf5d8bbdc8ca",title:"Passing dynamic parameters",path:"/docs/es/hardware-passing-dynamic-parameters/",content:'\nIn [previous](/docs/connect-simple-cps/) example we discussed how to create a simple CPS with Arduino. Our first CPS is able to do only one task: to blink a led. We suggest you to get through the first lesson. Now let\'s expand the example and teach our board to blink blue or red led depending on objective parameter.\n\n> The source code of this lesson is [here](https://github.com/airalab/robonomics_tutorials/tree/master/arduino_with_args).\n\n\n## Arduino\n\nThe only difference in Arduino source code is instead of subscribing to one topic now we subscribe to `/blink_red` and `/blink_blue` topics\n\n```c\n  #include <ros.h>\n  #include <std_msgs/Empty.h>\n\n  ros::NodeHandle nh;\n\n  void blink(int led, int mil) {\n\n    digitalWrite(led, HIGH);\n    delay(mil);\n    digitalWrite(led, LOW);\n    delay(mil);\n\n  }\n\n  void blinkRedCb(const std_msgs::Empty& msg) {\n    blink(13, 500);\n    blink(13, 500);\n    blink(13, 500);\n  }\n\n  void blinkBlueCb(const std_msgs::Empty& msg) {\n    blink(12, 500);\n    blink(12, 500);\n    blink(12, 500);\n  }\n\n  ros::Subscriber<std_msgs::Empty> subRed("blink_red", &blinkRedCb);\n  ros::Subscriber<std_msgs::Empty> subBlue("blink_blue", &blinkBlueCb);\n\n  void setup()\n  {\n    pinMode(13, OUTPUT);\n    pinMode(12, OUTPUT);\n\n    nh.initNode();\n    nh.subscribe(subRed);\n    nh.subscribe(subBlue);\n  }\n\n  void loop()\n  {\n    nh.spinOnce();\n    delay(1);\n  }\n```\n\n\x3c!-- Here is the diagram of all connections:\n\n.. image:: ../img/6.png\n  :alt: Arduino schema\n  :align: center --\x3e\n\n\n## ROS\n\nWe can pass arguments via objective which points to rosbag file. Have a look at `blink.py` script. The main difference is `blink()` method:\n\n```python\ndef blink(self, data):\n  if data.data == "blue":\n      rospy.loginfo("Blinking blue...")\n      self.blink_blue.publish(Empty())\n\n  if data.data == "red":\n      rospy.loginfo("Blinking red...")\n      self.blink_red.publish(Empty())\n\n  rospy.wait_for_service(\'/liability/finish\')\n  fin = rospy.ServiceProxy(\'/liability/finish\', FinishLiability)\n  fin(FinishLiabilityRequest(address=self.liability, success=True))\n  rospy.loginfo("Finished")\n```\n\nNow `/blink` topic has a `String` type. You can find prepared rosbags in `rosbag` folder.\n\n## AIRA\n\nConnect to AIRA client via SSH as described [here](/docs/aira-connecting-via-ssh/). Do not forget to add `COM1` port in settings. Run the following command:\n\n```\n$ rosrun arduino_with_args blink.py\n```\n\nAlso we need to add rosbag files to IPFS:\n\n```\n$ ipfs add rosbag/blink_blue.bag\n$ ipfs add rosbag/blink_red.bag\n```\n\n**Before the next step you should approve XRT tokens on the Factory.**\n\nThe last step is to build Dapp and launch. Take a look at the previous [lesson](/docs/connect-simple-cps/). To make Arduino blink the blue led send blue demand and blue offer messages. For the red one send corresponding messages.\n\nThat\'s it! Now you are able to pass dynamic parameters to your cyber-physical system agent!'}},{node:{id:"9a3670eb9c42666458e7899b9ed4ee7d",title:"Connect an Air Pollution Sensor",path:"/docs/es/hardware-connect-sensor/",content:"\nIn this lesson you are going to learn how to connect your sensor to the network and make it publish data. You will see how it is easy to become a member of a global sensor network!\n\nSource code is located [here](https://github.com/airalab/robonomics_tutorials/tree/master/sensor_city).\n\nIn this section we are not going to create a liability contract. Instead we will teach Arduino with sensors to publish the data by a request. All measurements will be published as a Result message.\n\n## Arduino\n\nLet's begin with an Arduino circuit. You need the following components:\n\n* Arduino Uno\n* Optical Dust Sensor Sharp GP2Y1010AU0F\n* Gas Sensor MQ-2\n* Gas Sensor MQ-7\n* Resistor 150 Ohm\n* Capacitor 220 uF\n* Wires\n\nConnect all parts as described below:\n\n\x3c!-- .. image:: ../img/7.png\n  :alt: Arduino schema\n  :align: center --\x3e\n\nA firmware for Arduino Uno is in `sensor_city/scetches` folder. In order to upload it to the board use [Arduino IDE](https://www.arduino.cc/en/Main/Software).\n\n\x3c!-- .. image:: ../img/8.png\n   :alt: Arduino IDE\n   :align: center\n --\x3e\n\n## Aira\n\nThe following steps are performed in Aira client. You can download the latest image from [this page](https://github.com/airalab/aira/releases). It's convenient to [connect via SSH](/docs/aira-connecting-via-ssh/).\n\nAfter you have imported the image to VirtualBox, connect Arduino via USB to your PC and enable serial port forwarding. You should check `Enable Serial Port` and assign `/dev/ttyACM0` in `Path/Address`. Inside the virtual machine `/dev/ttyS0` refers to your external Arduino.\n\n\x3c!-- .. image:: ../img/9.png\n   :alt: Set a port\n   :align: center --\x3e\n\nFinally launch the image and run these command:\n\n```\n$ roslaunch sensor_city publish_data.launch\n```\n\n**Check out the source code to learn how it works under the hood!**\n\nNow Aira patiently waits for a signal to publish the measurements. Go to [Dapp](https://dev.aira.life/smart-city/#/) and click on `Broadcast signal`. You should see the data!"}},{node:{id:"e390cc4cb37a25af354af247113244df",title:"Glossary",path:"/docs/es/glossary/",content:'\n## Agent\n\nIn terms of Robonomics Network agent is a program module that uses IPFS or blockchain or both interfaces of the network and does some actual work.\nUsually it\'s represented as a ROS package and it may connect (but not necessarily) a real cyber-physical system to the Robonomics Network.\n\n## Cyber-physical system\n\nIt is a combination of a physical mechanism that is usually called a robot and a program algorithm that controls the behavior of the mechanism.\n\n## Dapp\n\nIt is a short form for Decentralized application. Usually it is a single page web based application that helps to interact with an agent.\n\n## IPFS\n\nAccording to the official [documentation](https://docs.ipfs.io/introduction/) "IPFS is a distributed system for storing and accessing files, websites, applications, and data".\nFor more detail how it works go to the official website.\n\n## Lighthouse\n\nA lighthouse is an autonomous workflow that allows us to distribute the running time of providers that serve a single broadcast channel.\n\nFor more information read [Robonomics Whitepaper](https://static.robonomics.network/docs/whitepaper/Robonomics-whitepaper-en.pdf) section 5.2.\n\n## Sidechain\n\nEthereum based blockchain network with Proof-of-Authority consensus owned by Airalab.\n\n'}},{node:{id:"45c592eaab45cdb592f9b7e8e3add9c8",title:"Getting Started",path:"/docs/es/",content:'\n## What is Robonomics\n\nRobonomics platform provides tools for working with the robot economy network. Robonomics allow designers of smart cities and industry 4.0 zones to build trust among the [autonomous robots services](/docs/glossary#cyber-physical-system), provide [direct user access via dapp](/docs/glossary#dapp) for ordering products from autonomous factories and services of urban sensor networks. This in turn will allow us to put in place a decentralized system that globally monitors the activities of cyber physical systems.\n\nFind more in [Robonomics whitepaper](https://github.com/airalab/robonomics_specs/blob/master/pdf/whitepaper_en.pdf)\n\nThe following chart describes what place Robonomics takes in the scenario:\n\n![Robonomics Chart](../images/robonomics_network_basic_scheme.jpg "Robonomics Network scenario")\n\n## What the documentation contains\n\n### Robonomics Network quick start\nStart with quick example of what Robonomics is able to do within 5 minutes: [DEMO "Get Weather on Fuji Mountain"](/docs/get-weather-on-fuji-mountain).\n\n### I\'m interested in using Robonomics services\n\nTake a look at the [Robonomics Dapp](https://dapp.robonomics.network/#/). Get familiar with the statistic, average miner reward etc.\nTry out existing [services](https://dapp.robonomics.network/#/services)\n\n### I\'m a Dapp developer\n\n- [Robonomics-js on GitHub](https://github.com/airalab/robonomics-js) - simple Javascript SDK for Robonomics Network dApp developers.\n- [dApp template](https://github.com/airalab/vue-dapp-robonomics-template) - uses Vue.js\n- [Wiki documentation](/docs/robonomics-js/)\n\n### I\'m a robotics engineer\n\nCheck out [cases](/docs/iot-sensors-connectivity/) section and start developing by [examples](/docs/agent-development-examples).\n\n'}},{node:{id:"6f1a6922f41a3337c743c3ed44c3f870",title:'DEMO "Obtenga el clima en la montaña de Fuji"',path:"/docs/es/get-weather-on-fuji-mountain/",content:'\n**Comencemos con un ejemplo rápido de lo que Robonomics es capaz de hacer en 5 minutos. Requisitos: [extensión Metamask](https://metamask.io/)**\n\nPara obtener el clima del sensor en la montaña Fuji, abra la página del [Fuji Weather sensor](https://dapp.robonomics.network/#/sensors/airalab/QmbQT8cj9TJKfYVaidfShnrEX1g14yTC9bdG1XbcRX73wY/0x4D8a26e1f055c0b28D71cf1deA05f0f595a6975d/) en Robonomics dApp y siga las instrucciones a continuación.\n\nAquí hay un video tutorial:\n\nhttps://www.youtube.com/embed/t098NlMELk4\n\n## 1. Abra la DAPP\n\nEn caso de que no tenga la extensión MetaMask, verá la imagen a continuación. Vaya al enlace proporcionado arriba e instale uno.\n\n!["Robonomics dApp si no hay MetaMask instalado"](../images/sensor-demo/sensor-demo-1.png "Robonomics dApp si no hay MetaMask instalado")\n\n## 2. Permitir la conexión a la Extension\n!["Conexión a Robonomics dApp a través de Metamask"](../images/sensor-demo/sensor-demo-2.png "Conexión a Robonomics dApp a través de Metamask")\n\n## 3. Presione “Request Current Values” (Solicitar Valores Actuales)\n!["Request sensor\'s data in Robonomics network via dApp"](../images/sensor-demo/sensor-demo-3.png "Request sensor\'s data in Robonomics network via dApp")\n\n## 4. Firme el Mensaje, no se necesita ningun token ni Ether\n!["Firme el Mensaje en la red de Robonomics a través de dApp"](../images/sensor-demo/sensor-demo-4.png "Firme el Mensaje en la red de Robonomics a través de dApp")\n\n## 5. Espere hasta que el agente agarre los datos y los envie\n!["Espere hasta que el agente en la red Robonomics a través de dApp"](../images/sensor-demo/sensor-demo-5.png "Espere hasta que el agente en la red Robonomics a través de dApp")\n\n## 6. Espere hasta que la DAPP descargue el archivo final de IPFS\n!["Espere el archivo IPFS con resultados en la red Robonomics a través de dApp"](../images/sensor-demo/sensor-demo-6.png "Espere el archivo IPFS con resultados en la red Robonomics a través de dApp")\n\n## 7. Ahora si, ya puede ver los datos del tiempo en la Montaña Fuji\n!["Los resultados de la red de sensores en Robonomics a través de dApp"](../images/sensor-demo/sensor-demo-7.png "Los resultados de la red de sensores en Robonomics a través de dApp")\n\n¡Acaba de transmitir un mensaje de demanda y obtuvo un resultado de un agente autónomo! El archivo de resultados se almacena en IPFS, el mensaje de resultado se firma con la clave privada del agente.'}},{node:{id:"be4c0d5977a0e3ed65555c7edea3087c",title:"Gaka-Chu setup and software Installation",path:"/docs/es/gaka-chu/",content:"\nhttps://www.youtube.com/watch?v=GxlYxaykqTU\n\n**In this article we will go through some installation and launching steps to set up a robot-painter. Requirements:**\n- KUKA KR6 R900 sixx with KRC4 and a SmartPad;\n- Intel NUC with [ROS melodic](http://wiki.ros.org/melodic/Installation/Ubuntu) installed;\n- Table, paint, brush, water.\n\n## Software installation on KRC4\nEKI interface is required on both, KRC4 and NUC. Detailed information on how to set it up on KRC4 is presented [here](https://github.com/AlexeiOvcharov/kuka_experimental/tree/a915bf4e932990379c84164713e7ae11a24a2a13/kuka_eki_hw_interface/krl). Launch it on robot's controller.\n\n## Software installation on NUC\nCreate a catkin workspace:\n```\nmkdir -p ~/catkin_ws/src\ncd ~/catkin_ws/\ncatkin build\n```\nDownload ROS packages. All the scripts are stored [here](https://github.com/airalab/robot_painter/tree/test_branch). Clone the repository:\n```\ncd src\ngit clone --branch test_branch https://github.com/airalab/robot_painter\ncd robot_painter\nrm -rf scenes\nmv * ../\ncd ..\nrmdir robot_painter\n```\nYou may need some header files and libraries to make it all work correctly. Download them:\n```\ncd ~\ngit clone https://github.com/PaTara43/kuka_moveit_webots\ncd kuka_moveit_webots\nsudo mv -r headers/* usr/include/c++/7/\nsudo mv libs/* usr/local/lib/\ncd ~\nsvn checkout https://github.com/PX4/Matrix/trunk/matrix\nmv matrix -r /usr/include/c++/7/\nsudo apt-get install ros-melodic-brics-actuator\ncd ~/catkin_ws\ncatkin build\n```\nAdd source command to `.bashrc` file:\n```\necho “source ~/catkin_ws/devel/setup.bash” >> ~/.bashrc\nsource ~/.bashrc\n```\nUp to now. you should be able to launch the scripts. If something goes wrong, try some [troubleshooting](https://github.com/airalab/robot_painter/issues)\n\n## Filling in constants\nFirst of all, the robot needs to know canvas location and orientation as well as the paint tin position. All of this is specified in `fake_painter_enviroment_tf/src/tf_broadcaster.cpp`. Let's take a look into it.\n```\n// Plane constants\nconst double A = -0.0641;\nconst double B = 0.0214;\nconst double C = 0.9977;\nconst double D = -0.2198;\n\n// Canvas transform\nconst double px = 0.52;\nconst double py = -0.24;\nconst double qx = -0.011;\nconst double qy = -0.032;\nconst double qz = 0.0;\nconst double qw = 0.999;\n```\nThese are the plane equation constants which specify canvas position in 3-D space. They are to be obtained during a calibration process described below. Next goes the paint.\n```\ncolorTransform.transform.translation.x = 0.5;\ncolorTransform.transform.translation.y = 0.2;\ncolorTransform.transform.translation.z = 0.258;\n```\nThese are paint tin coordinates. They also may be specified while calibrating. Canvas size is specified in\n```\ncanvas.width = 0.5;\ncanvas.height = 0.4;\n```\nSeveral more important constants are stored in `local_task_planner/src/Drawing.cpp`:\n```\nconst double COLOR_BOTLE_HEIGHT = 0.06;\nconst double COLOR_HEIGHT = 0.045;\nconst double HEIGHT_OFFSET = COLOR_BOTLE_HEIGHT - COLOR_HEIGHT + 0.02;\nconst double BRUSH_HEIGHT = 0.01;\nconst double BRUSH_WIDTH = 0.01;\n```\nTheir names say it all, so fill them in according to the situation.\n\n## Calibrating Gaka-Chu\nThe calibration process itself is pretty simple.\n\n1) Start EKI interface on the KRC4:\n\nLog in in 'AUT' mode, turn on drivers and launch the script `eki_hw_interface`\n\n2) Start EKI interface on the NUC\n```\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\n```\nIt should output endless logs.\n\n3) Start RViz\n```\nroslaunch kuka_moveit_config demo.launch\n```\nYou should see the following:\n\n![KUKA in RViz](../images/kuka-real/kuka_rviz.png \"KUKA in RViz\")\n\nTry moving the end effector and clicking 'Plan and Execute'. The robot should move. On SmartPad go to **Display -> Actual position** and observe end effector's coordinate. Place a canvas horizontally to the robot base. Plug a brush into the brush holder and carefully move it till it barely touches the canvas. At this position, save end effector's coordinates. Repeat 12-15 times. Also, save the coordinates of the canvas center and paint tin.\nWhen you have a set of coordinates, use [these](https://github.com/nakata5321/Matlab_scripts_gaka-chu) Matlab scripts to resolve the missing constants and quaternion. Paste them. Rebuild your workspace with\n```\ncd ~/catkin_workspace\nrm -rf build logs devel\ncatkin build\n```\n\n## Testing Gaka-Chu calibration\nWhen calibrated, Gaka-Chu needs to be tested by drawing the borders of canvas. To make him do so execute each in new terminal:\n```\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\nroslaunch kuka_moveit_config demo.launch\nrosrun fake_painter_enviroment_tf tf_broadcaster\nrosrun local_task_planner draw_workspace\n```\nAfter this, you should see a canvas contour in RViz:\n\n![KUKA in RViz canvas](../images/kuka-real/kuka_rviz_canvas.png \"KUKA in RViz canvas\")\n\nIn terminal press \"S\" to perform testing. Robot's end effector should move right above the borders of the canvas and the brush should gently touch the canvas during the entire movement. If not so, try recalibrating. If the canvas model is rotated wrong, you can rotate it by changing quaternion in Matlab.\n\n## Making art\nYou need 6 basic modules to make it all work:\n- EKI interface;\n- MOVEit + RViz;\n- Environment frames broadcasting;\n- Picture converter service;\n- Trajectories drawing module;\n- Starting trigger.\n\nLet's launch them one by one.\n\n### Eki interface\nOn KRC4 launch `eki_hw_interface`, on NUC in a new terminal do:\n```\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\n```\n\n### RViz and MOVEit\nYou need a planner and a simulation. Launch them with\n```\nroslaunch kuka_moveit_config demo.launch\n```\n\n### Environment\nTell the robot where the paint tin and the canvas are. Note that it is not necessary to launch `draw workspace` node, the `tf_broadcaster` shares the canvas size. It just doesn't show it in RViz.\n```\nrosrun fake_painter_enviroment_tf tf_broadcaster\n```\n\n### Pictures processor\nAll incoming pictures need to be processed. Launch the service.\n```\nrosrun picture_preprocessing TextConverter.py\n```\nWhen it receives the call, it processes a picture with a HP filter and creates a rosbag file with trajectories.\n\n### Trajectories drawer\nThe mainest script here is the trajectories drawer itself. It waits for the picture, calls TextConverter service and draws the painting.\n```\nrosrun local_task_planner trajectory_drawing\n```\n\n## Send the robot a picture to draw\nThe robot listens to a specific ROS-topic where you need to pass the path to a desired picture. The picture should be square (width equals height) and made of lines. Send the path:\n```\nrostopic pub /run std_msgs/String \"data: '<path_to_picture>'\"\n```\nAfter that. Two windows pop up showing the contours and the tracks. Close them and see Gaka-Chu drawing. Watch out for safety and alwasy be ready to press emergency stop button.\nWhen Gaka-Chu finishes his art, you can send another path to picture and painter repeats the whole process.\n"}},{node:{id:"c53a8b64e574b08e488e9fcc668609b7",title:"Connect an Amazon FreeRTOS Device to Robonomics by MQTT",path:"/docs/es/freertos-mqtt/",content:"\nHere's the demonstration of how a microcontroller running [Amazon Web Services FreeRTOS](https://aws.amazon.com/freertos/) may be connected to Robonomics Network via MQTT. Please check [this repository](http://github.com/khssnv/freertos_mqtt_robonomics_example) for the project source code.\n\nWe use [ESP32 DevKitC](https://devices.amazonaws.com/detail/a3G0L00000AANtjUAH/ESP32-WROOM-32-DevKitC/) with FreeRTOS distribution and MQTT implementation provided by [Espressif IoT Development Framework](https://github.com/espressif/esp-idf) while Espressif is a vendor of the microcontroller used.\n\nAlso there is a [PMS-3003](http://www.plantower.com/en/content/?107.html) sensor for demonstration purposes. Sensor measures presence of particulated matter in the air and one may use it to estimate air quality.\n\nAir quality is not a topic of the article, you may find more about it at WHO's website: [Ambient (outdoor) air pollution](https://www.who.int/news-room/fact-sheets/detail/ambient-(outdoor)-air-quality-and-health). A goal of the system is to publish sensor measurements to Airalab's Robonomics network.\n\n## Hardware setup\n\nWe connect PMS3003 TXD PIN5 to ESP32 DevKitC IO17 to transfer measurements by UART.\nAlso both devices require power and common ground.\n\n![Wiring Diagram](../images/freertos-mqtt/wiring.png)\n\n## Data Flow\n\nIn order to deliver sensor measurements to Robonomics network, on a firmware level our goal is to get data from a sensor by embedded communication protocol it supports (UART in our case) and pass it to AIRA instance by MQTT / TCP.\n\n![Sending](../images/freertos-mqtt/send.svg)\n\nIn our example we use AIRA cloud deployment available by public IP address and domain name assigned.\nOn AIRA instance we setup `mosquitto` MQTT broker and subscribe to `/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4` topic to get messages from MQTT.\n\nThen we pass messages to `robonomics io` writer by pipe.\n\n![Receiving](../images/freertos-mqtt/recv.svg)\n\nNow data available in Robonomics Network and we can be read it with `robonomics io` again.\n\n## Firmware\n\nWe use [ESP-MQTT sample application with TCP transport](https://github.com/espressif/esp-idf/tree/master/examples/protocols/mqtt/tcp) as a basis.\n\nWe only modify `main/app_main.c` for UART connection to the sensor, SNTP time synchronization and periodic MQTT publisher routine.\n\nIf you are trying to repeat the project, and it's your first ESP IDF based project, at first please follow [Espressif's ESP-IDF Programming guide](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/index.html#installation-step-by-step) introduction in order to familiarize with firmware operations like configuration, build and upload with `idf.py` tool.\n\n### Wi-Fi Configuration\n\nIn order to communicate with AIRA instance deployed in cloud, our microcontroller requires Internet connection.\nWe use ESP32's Wi-Fi for it.\nEspressif provides utilities to configure on-board Wi-Fi.\nIn our example we use development environment with Ubuntu 20.04 GNU/Linux.\nTo configure Wi-Fi we go to project folder and run SDK configuration tool.\n\n```console\ncd freertos_mqtt_robonomics_example/firmware\nidf.py menuconfig\n```\n\nThen we set Wi-Fi access point SSID and password in `Example Connection Configuration` section.\n\n![Menuconfig Wi-Fi](../images/freertos-mqtt/menuconfig-wi-fi.png)\n\n### MQTT Endpoint Configuration\n\nThere are two things to configure for MQTT.\nThe first is a MQTT broker address.\nIt is configurable with SDK configuration tool.\n\n```console\ncd freertos_mqtt_robonomics_example/firmware\nidf.py menuconfig\n```\n\nSet `Broker URL` in `Example Configuration` section.\n\n![Menuconfig MQTT](../images/freertos-mqtt/menuconfig-mqtt.png)\n\nThe second thing is a MQTT topic.\nWe set it in the firmware with the project name prefix followed with our ESP32 MAC address.\nIt gives us `/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4` for our particular microchip.\n\n## From MQTT to Robonomics\n\nAt first let's check we receive data by MQTT.\nWe can subscribe to our Mosquitto MQTT broker topic device publish to.\n\n```console\n$ nix-shell -p mosquitto --run \"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\"\nts=1615651809, PM1=2, PM2.5=6, PM10=3\n```\n\nHere we bring `mosquitto` package into our environment to use `mosquitto_sub` utility.\nThen we subscribe to the topic set in the firmware.\nWe got our measurements that means AIRA receives data by MQTT correctly.\nNow let's pipe these messages to Robonomics Network.\n\n```console\nnix-shell -p mosquitto --run \"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\" | robonomics io write pubsub --bootnodes=/ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\n```\n\nHere we use `robonomics` utility to publish messages in pubsub channel `/freertos_mqtt_robonomics_example`.\nWe specify `bootnodes` to ensure at least one connection established.\n\nNow we are read these messages from the same pubsub channel.\n\n```console\n$ robonomics io read pubsub --listen /ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\n2021-03-27 15:15:51  Generated random peer id: 12D3KooWB2nym5E6c3aPpnPKK5wB9Z6n9eZzcXSpyUBozxhi6dam\n2021-03-27 15:15:51  Subscribed to topic: _robonomics_pubsub_peer_discovery\n2021-03-27 15:15:51  Subscribed to topic: /freertos_mqtt_robonomics_example\n2021-03-27 15:15:56  New peer connected: PeerId(\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\")\n2021-03-27 15:15:56  GRAFT: Mesh link added for peer: PeerId(\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\") in topic: TopicHash { hash: \"_robonomics_pubsub_peer_discovery\" }\nts=1616843855, PM1=3, PM2.5=4, PM10=3\n```\n\n## Original Resources Used\n\n* ESP32 DevKitC pinout from GoJimmy's blog https://gojimmypi.blogspot.com/2017/03/jtag-debugging-for-esp32.html\n* PSM3003 data structure and decoder from OpenAirProject https://github.com/openairproject/sensor-esp32\n\n**Thank you all!**\n"}},{node:{id:"fbcf843d0741767d4b926086c1624fa7",title:"Ethereum Common",path:"/docs/es/ethereum-common/",content:'\nThe packages contains two launch files: `erc20.launch` and `signer.launch`. The last one is included in [Robonomics Liability](/docs/robonomics-liability).\n\nBelow is the description for `erc20` node which contains utils for convenient work with Ethereum accounts and XRT token.\n\n## ROS Parameters\n\n###  ~web3_http_provider\n\nWeb3 HTTP provider address. The type is `string`, defaults to `http://127.0.0.1:8545`\n\n### ~erc20_token\n\nERC20 token to work with. Type is `string`, defaults to `xrt.5.robonomics.eth`\n\n### ~factory_contract\n\nThe name of the liability factory. The type is `string`, defaults to `factory.5.robonomics.eth`\n\n### ~ens_contract\n\nThe checksumed address of ENS registry. The type is `string`, defaults to `""`\n\n### ~keyfile\n\nPath to keyfile. The type is `string`, defaults to `""`. **Required parameter**\n\n### ~keyfile_password_file\n\nPath to a file with password for the keyfile. The type is `string`, defaults to `""`. **Required parameter**\n\n## Published topics\n\n### /eth/event/transfer (ethereum_common/TransferEvent)\n\nThe event [ethereum_common/TransferEvent](/docs/ethereum-common-messages#ethereum_commontransfereventmsg) is emitted after the transfer of tokens was made\n\n### /eth/event/approval (ethereum_common/ApprovalEvent)\n\nThe event [ethereum_common/ApprovalEvent](/docs/ethereum-common-messages#ethereum_commonapprovaleventmsg) is emitted after the approval of tokens was made\n\n## Services\n\n### /eth/accounts (ethereum_common/Accounts)\n\nList of available Ethereum accounts. See [ethereum_common/Accounts](/docs/ethereum-common-messages#ethereum_commonaccountssrv)\n\n### /eth/account_eth_balance (ethereum_common/AccountBalance)\n\nReturns the balance of the given address in Wei. See [ethereum_common/AccountBalance](/docs/ethereum-common-messages#ethereum_commonaccountbalancesrv)\n\n### /eth/eth_balance (ethereum_common/Balance)\n\nReturns the balance of the default address. See :ref:`Ethereum-common-Balance.srv`\n\n### /eth/current_block (ethereum_common/BlockNumber)\n\nReturns current block number. See :ref:`Ethereum-common-BlockNumber.srv`\n\n### /eth/transfer (ethereum_common/Transfer)\n\nTransfers tokens from the default account to a given one. See :ref:`Ethereum-common-Transfer.srv`\n\n### /eth/transfer_from (ethereum_common/TransferFrom)\n\nTransfers tokens from a given account to another one. See :ref:`Ethereum-common-TransferFrom.srv`\n\n### /eth/approve (ethereum_common/Approve)\n\nApproves tokens from the default account to a given one. See :ref:`Ethereum-common-Approve.srv`\n\n### /eth/account_xrt_balance (ethereum_common/AccountBalance)\n\nReturns the XRT balance of a given account. See :ref:`Ethereum-common-AccountBalance.srv`\n\n### /eth/xrt_balance (ethereum_common/Balance)\n\nReturn the XRT balance of the default account. See :ref:`Ethereum-common-Balance.srv`\n\n### /eth/account_xrt_allowance (ethereum_common/AccountToAddressAllowance)\n\nReturns how much one account is allowed to spend from another account. See :ref:`Ethereum-common-AccountToAddressAllowance.srv`\n\n### /eth/xrt_allowance (ethereum_common/Allowance)\n\nReturns how much the Factory is allowed to spend from the default account. See :ref:`Ethereum-common-Allowance.srv`'}},{node:{id:"65474c4ebc14e3809b294ff690e1df72",title:"Ethereum Common Messages",path:"/docs/es/ethereum-common-messages/",content:"\n## ethereum_common/Address.msg\n\n| Field   \t| Type            \t| Description                    \t|\n|---------\t|-----------------\t|--------------------------------\t|\n| address \t| std_msgs/String \t| Address in Ethereum blockchain \t|\n\n## ethereum_common/UInt256.msg\n\n| Field   \t| Type            \t| Description                \t|\n|---------\t|-----------------\t|----------------------------\t|\n| uint256 \t| std_msgs/String \t| A wrapper for big integers \t|\n\n## ethereum_common/TransferEvent.msg\n\n| Field      \t| Type                                                  \t| Description      \t|\n|------------\t|-------------------------------------------------------\t|------------------\t|\n| args_from  \t| [ethereum_common/Address](#ethereum_commonaddressmsg) \t| Sender address   \t|\n| args_to    \t| [ethereum_common/Address](#ethereum_commonaddressmsg) \t| Receiver address \t|\n| args_value \t| [ethereum_common/UInt256](#ethereum_commonuint256msg) \t| Amount of tokens \t|\n\n## ethereum_common/ApprovalEvent.msg\n\n| Field        \t| Type                                                  \t| Description      \t|\n|--------------\t|-------------------------------------------------------\t|------------------\t|\n| args_owner   \t| [ethereum_common/Address](#ethereum_commonaddressmsg) \t| Owner address    \t|\n| args_spender \t| [ethereum_common/Address](#ethereum_commonaddressmsg) \t| Spender address  \t|\n| args_value   \t| [ethereum_common/UInt256](#ethereum_commonuint256msg) \t| Amount of tokens \t|\n\n## ethereum_common/AccountBalance.srv\n\n**Request**\n\n| Field   \t| Type                                                  \t| Description      \t|\n|---------\t|-------------------------------------------------------\t|------------------\t|\n| account \t| [ethereum_common/Address](#ethereum_commonaddressmsg) \t| Ethereum address \t|\n\n**Response**\n\n| Field   \t| Type                                                  \t| Description    \t|\n|---------\t|-------------------------------------------------------\t|----------------\t|\n| balance \t| [ethereum_common/UInt256](#ethereum_commonuint256msg) \t| Balance in Wei \t|\n\n## ethereum_common/AccountToAddressAllowance.srv\n\n**Request**\n\n| Field   \t| Type                                                  \t| Description      \t|\n|---------\t|-------------------------------------------------------\t|------------------\t|\n| account \t| [ethereum_common/Address](#ethereum_commonaddressmsg) \t| Ethereum address \t|\n| to      \t| [ethereum_common/Address](#ethereum_commonaddressmsg) \t| Ethereum address \t|\n\n**Response**\n\n| Field  \t| Type                                                  \t| Description   \t|\n|--------\t|-------------------------------------------------------\t|---------------\t|\n| amount \t| [ethereum_common/UInt256](#ethereum_commonuint256msg) \t| Balance in Wn \t|\n\n## ethereum_common/Accounts.srv\n\n**Request**\n\nRequest is empty\n\n**Response**\n\n| Field     | Type                                                      | Description                   |\n|---------- |-------------------------------------------------------    |----------------------------   |\n| accounts  | [ethereum_common/Address[]](#ethereum_commonaddressmsg)     | List of available accounts    |\n\n## ethereum_common/Allowance.srv\n\n**Request**\n\nRequest is empty\n\n**Response**\n\n| Field     | Type                                                      | Description                                       |\n|--------   |-------------------------------------------------------    |-----------------------------------------------    |\n| amount    | [ethereum_common/UInt256](#ethereum_commonuint256msg)     | Amount of XRT the Factory is allowed to spend     |\n\n## ethereum_common/Approve.srv\n\n**Request**\n\n| Field     | Type                                                      | Description                   |\n|---------  |-------------------------------------------------------    |-----------------------------  |\n| spender   | [ethereum_common/Address](#ethereum_commonaddressmsg)     | Who is allowed to spend       |\n| value     | [ethereum_common/UInt256](#ethereum_commonuint256msg)     | How much tokens are allowed   |\n\n**Response**\n\n| Field     | Type                  | Description       |\n|--------   |--------------------   |------------------ |\n| txhash    | std_msgs/Uint8[32]    | Transaction hash  |\n\n## ethereum_common/Balance.srv\n\n**Request**\n\nRequest is empty\n\n**Response**\n\n| Field     | Type                                                      | Description                       |\n|---------  |-------------------------------------------------------    |--------------------------------   |\n| balance   | [ethereum_common/UInt256](#ethereum_commonuint256msg)     | The balance of default account    |\n\n## ethereum_common/BlockNumber.srv\n\n**Request**\n\nRequest is empty\n\n**Response**\n\n| Field     | Type              | Description           |\n|--------   |-----------------  |---------------------- |\n| number    | std_msgs/Uint64   | Current block number  |\n\n## ethereum_common/Transfer.srv\n\n**Request**\n\n| Field     | Type                                                      | Description           |\n|-------    |-------------------------------------------------------    |---------------------- |\n| to        | [ethereum_common/Address](#ethereum_commonaddressmsg)     | Ethereum address      |\n| value     | [ethereum_common/UInt256](#ethereum_commonuint256msg)     | The amount of tokens  |\n\n**Response**\n\n| Field     | Type                  | Description       |\n|--------   |--------------------   |------------------ |\n| txhash    | std_msgs/Uint8[32]    | Transaction hash  |\n\n## ethereum_common/TransferFrom.srv\n\n**Request**\n\n| Field     | Type                                                      | Description           |\n|-------    |-------------------------------------------------------    |---------------------- |\n| owner     | [ethereum_common/Address](#ethereum_commonaddressmsg)     | Owner's address       |\n| to        | [ethereum_common/Address](#ethereum_commonaddressmsg)     | Another account       |\n| value     | [ethereum_common/UInt256](#ethereum_commonuint256msg)     | The amount of tokens  |\n\n**Response**\n\n| Field     | Type                  | Description       |\n|--------   |--------------------   |------------------ |\n| txhash    | std_msgs/Uint8[32]    | Transaction hash  |\n"}},{node:{id:"660ecba2847e6181e891dfd115884f16",title:"How to edit WIKI",path:"/docs/es/edit-wiki/",content:'\n**Robonomics WIKI is open source. Any corrections are welcome: fixing errors, typos, some unclear or outdated information, translation into any language. You\'ll need a [GitHub](https://github.com/) account.**\n\n## Edit existing doc\n\n1. Choose page\n2. Click button "Edit page" marked with the Github logo on the page you want to edit\n3. Clicking on the button will take you to the .md file.\n4. Please, follow common rules for editing [Markdown files](https://en.wikipedia.org/wiki/Markdown), bearing in mind a few features of the WIKI stack:\n\n### Frontmatter\nDocs in Robonomics WIKI contain frontmatter block. It must be at the top of the Markdown file, and must take the form of valid YAML set between triple-dashed lines. Between the triple-dashed lines, you can set or edit folowing options:\n\n```YAML\n---\ntitle: How to contribute # Title for the page, you do not need to duplicate it in text\ncontributors: [positivecrash] # Main contributors (who actively curates this page). GitHub nickname required, without any additional symbols\ntranslated: true # "true" if it has been translated in current language (see locale folder name of doc)\n---\n```\n\n### Images\n1. Upload image in folder `/docs/images/url-of-your-doc`\n* If image needs to be localized, insert all of them in one folder\n* Use locale appendix in name of images if it\'s localized, e.g. `image_en.jpg`\n* Make sure your image is web optimised and at the same time it looks good\n2. Insert images standart way for Markdown files.\n\n### YouTube videos\nYou can embed any YouTube video in doc by inserting share link as separate paragraph without any additional quotes or tags, e.g.: `https://youtu.be/kQaSwNYHJQ8`\n\n### Asciinema\nRobonomics WIKI has support for Asciinema. To insert Asciinema, please, follow these instructions:\n* Import component after frontmatter block `import Asciinema from \'~/components/Asciinema.vue\'`\n* Insert as separate paragraph `<Asciinema vid="WCFcx8C6M8e52UKDNei1xZloU"/>`, where is vid is ID of specific asciicast\n\n> You can get the widget script for a specific asciicast by clicking on “Embed” link on asciicast page.\n> It looks like this:\n> `<script src="https://asciinema.org/a/14.js" id="asciicast-14" async><\/script>`\n[Asciinema docs](https://asciinema.org/docs/embedding)\n\nIn the example above vid is 14.\n\n## Add new doc\n\nIf you need to add new page in docs of Robonomics WIKI, please, follow these steps:\n\n1. Find the folder with the locale that matches the language of the article you are adding, e.g. `/docs/en/`\n2. Create .md file, using in name latin characters and follow common rules for [url structure](https://developers.google.com/search/docs/advanced/guidelines/url-structure)\n3. Edit file as described above\n4. Duplicate file to other locale folders, even if you do not plan to translate them. Do not forget mark in frontmatter not translated pages as `translated: false`\n5. Add doc in menu:\n* Open file `/data/sidebar_docs.yaml`\n* Decide where to place your doc\n* If you want to create new section, provide title with locale appendix, using only locales your section is translated\n* Add doc with link. The link must be only one, and must not contain locale characters. Correct is `/docs/url-of-your-doc`, not correct is `/docs/en/url-of-your-doc`\n* Use valid YAML for `/data/sidebar_docs.yaml` and rely on the existing file structure\n\n## Submit Pull Request\n\n[Make pull request](https://docs.github.com/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request) for any content you changed including typos, translations, outdated information or broken links.\n\nDecisions about individual PRs made by Robonomics core team. Special grants in [XRT](https://robonomics.network/community#token) are also possible for extended contribution 🤖💙💛💚💎🍭🎉🔌'}},{node:{id:"7bfa56915f3c32408e86ff863a095656",title:"Cross-chain Message",path:"/docs/es/cross-chain-messages/",content:"\nXCM (Cross-chain Message) allows sending messages between parachains. You can send launchXcm transaction to run/stop your robot or datalogXcm transaction to save data to blockchain.\n\nhttps://www.youtube.com/watch?v=a6XrqoaYhK8&feature=emb_logo\n\n## Create Account\n\nLets try to send message from Earth to Mars.\nGo to [parachain.robonomics.network](https://parachain.robonomics.network/#/explorer) and choose `Airalab Rococo` testnet:\n\n![testnets](../images/cross-chain/testnet.jpg)\n\nIn `Network/Parachains` you will see two parachains with their id:\n\n![ids](../images/cross-chain/Parachains_id.jpg)\n\nThen go to Earth parachain and [create](https://wiki.robonomics.network/docs/create-account-in-dapp/) two accounts (for example `ROBOT` and `EMPLOYER`). In a new tab go to Mars parachain.\n\n## LaunchXcm\n\nIn Earth parachain go to `Developer/Extrinsics` and choose your `EMPLOYER` account and launchXcm. Then write Mars parachain id (2000) and choose the `ROBOT` account:\n\n![launch](../images/cross-chain/launch.jpg)\n\nNow press `Submit Transaction`.\n\nTo see your transaction in Mars parachain go to `Network/Explorer` and look at Recent Events.\n\n![recent_launch](../images/cross-chain/recent_launch.jpg)\n\n## DatalogXcm\n\nIn Earth parachain go to `Developer/Extrinsics` and choose your `ROBOT` account and datalogXcm. Write Mars parachain id (2000) and the message:\n\n![datalog](../images/cross-chain/datalog.jpg)\n\nNow press `Submit Transaction`.\n\nYou can see your transaction in Recent Events in Mars parachain:\n\n![recent_datalog](../images/cross-chain/recent_datalog.jpg)\n\n\n"}},{node:{id:"e1b763c02a7968fa73fa077bbacdacc8",title:"Create digital identity run by Ethereum",path:"/docs/es/create-digital-identity-run-by-ethereum/",content:'\nOne of the Robonomics services is [Digital Passport Registration](https://dapp.robonomics.network/#/passport/) for arbitrary data. The service allows you to create a digital identity saving the hashes of the data to the public blockchain and assigning a unique address.\n\nYou may find "Digital passport registration" service in [Robonomics DApp](https://dapp.robonomics.network/) in the "Services" section or just follow this [direct link](https://dapp.robonomics.network/#/passport/).\n\n\n## Video walkthrough\n\nThe following video shows a progress of Robonomics Whitepaper registration:\n\nhttps://www.youtube.com/embed/E8R6VbZvf9w\n\n## Step-by-step in pictures\n\n### 1. Open the service\n\n![Digital passport registration applying form](../images/case_digital_passport_1.jpg "Digital passport registration applying form")\n\n### 2. Add necessary information and files\n\nPlease note, it is possible to add multiple images.\n\n![Filled Form](../images/case_digital_passport_2.jpg "Filled Form")\n\n### 3. Sign the demand\n\n![Sign the demand for digital passport creation](../images/case_digital_passport_3.jpg "Sign the demand for digital passport creation")\n\n\n### 4. Approve tokens\n\nThe service charges a small fee. But first you must approve the required amount of tokens to be spent from your account.\n\n![Approve Tokens](../images/case_digital_passport_4.jpg "Approve Tokens")\n\n\n### 5. Accept the offer and sign the message again\n\n![Send Order](../images/case_digital_passport_5.jpg "Send Order")\n\n### 6. Have a look at the created passport\n\n![The Digital Identity](../images/case_digital_passport_6.jpg "The Digital Identity") \n\nThe process of registration takes some time. In the end you will see a link to the created identity.\n'}},{node:{id:"b03e427fc99f8ace4b50713de815d64b",title:"Create an Account on Robonomics Portal",path:"/docs/es/create-account-in-dapp/",content:'\n**In order to be able to complete all the playground tutorials below, one should have several accounts on Robonomics portal. These accounts do not contain any personal data, neither they are anyhow valuable (if you play on a local dev network or on a self-owned test one). But still their keys, both public and private, are necessary for launching any demo.**\n\n## 1. Choose your network and navigate to Robonomics portal\nGlobally, there are 3 different ways to work with Robonomics:\n- Launch your own local network with [robonomics binary](https://github.com/airalab/robonomics/releases/) by `./robonomics --dev`. This method is used in all playground tutorials. (_tip: to avoid failures on next launches clean chain data by `rm -rf /home/$USER/.local/share/robonomics/chains/dev/db` after each session_)\n- Launch your own test network following [this](/docs/robonomics-test-network-manual/) manual\n- Connect to an existing network on a portal (more information on this below)\n\nRegardless of method chosen, go to [parachain.robonomics.network](https://parachain.robonomics.network) and draw your attention to the top-left corner:\n\n![Portal top-left](../images/creating-an-account/portal-top-left.jpg "Portal top-left")\n\nPress on the current network icon and choose you network:\n- **Development -> Local Node** if you have launched local network\n- **Custom Endpoint -> insert endpoint** if you have created a test network on a remote server\n- **Live Networks** or **Test Networks** if you are operating in a public one\nDon\'t forget to press `Switch` button to confirm network choice. In all the playgrounds we will use local networks.\n\n![Choosing local network](../images/creating-an-account/choosing-local-node.jpg "Choosing local network")\n\n## 2. Create accounts\nNow that you have chosen your network, go to **Accounts -> Accounts** and press `Add account` button\n\n![Accounts page](../images/creating-an-account/accounts-page.jpg "Accounts page")\n\nYou should see the following panel:\n\n![Add account panel](../images/creating-an-account/add-account-panel.jpg "Add account panel")\n\n- *Name* is just you account\'s name in this exact browser. It makes no sense but convenience.\n- *Seed*. Each transaction must be signed by account\'s unique seed. It has two forms: *Mnemonic* (human-readable) and *Raw* (a sequence of digits and letters). Change *Mnemonic* to *Raw* and copy the seed. **It\'s very important to store it somewhere securely** since secret seeds are used for transactions in [Robonomics IO](/docs/rio-overview/) module. If you have created an account before, you can insert its secret seed here to restore its balance and history.\n- *Password* is used to sign transactions on a portal (in GUI). Create one and remember it.\n\nClick `Save`, `Create and backup account`. A downloaded JSON-file is another way to restore account\'s data on the portal.\n\n## 3. Manage your accounts\nNow you can fully operate with your fresh-created account. Send and receive tokens, messages, write datalog and more. You can forget this account for this exact browser by clicking three dots in opposite of your account\'s name and choosing *Forget this account*. Feel free to explore all the features of portal. To copy your account\'s address simply click on its icon, address will be copied to clipboard.\n\n## 4. Some notes before proceeding to playground\nMost of the playground demos require "Control" account and one or several "Worker" accounts. Transfer units to both before starting, since "Control" needs to send "ON"/"OFF" transactions and "Worker" publishes datalog. Also, each "ON"/"OFF" transaction requires target address, so don\'t forget to copy it from the portal.\n'}},{node:{id:"df2b7e4e70929da97a4d369a0995ca25",title:"How to contribute",path:"/docs/es/contributing/",content:"\nRobonomics network is an open-source project built by core maintainers from Airalab and contributors. We want to make it easy for anyone to contribute. You may contribute to core, suggest changes, improve documentation or write a blog post. Please, read some rules and suggestions for contributing.\n\n## Main Airalab repositories \n\n- [aira](https://github.com/airalab/aira) - AIRA client for Robonomics network. \n- [robonomics_comm](https://github.com/airalab/robonomics_comm) - Robonomics communication stack\n- [robonomics_contracts](https://github.com/airalab/robonomics_contracts) - smart contracts of Robonomics network\n\n## Bugs and proposals for improvements\n\nIf you find a bug in AIRA client, Robonomics repositories, this documentation or would like to propose an improvement, please, open a new issue in the same repository, that you want to contribute.\n\n### Rules for reporting\n\nWhen opening a new issue, do not forget about a few basic rules for reporting:\n\n1. Choose exact repository, that you want to submit an issue.\n\n2. If you are reporting bug, make sure the bug was not already reported.\n\n3. Be sure to include title and clear description, as much relevant information as possible.\n\n4. Please prefix your issue with one of the following: [BUG], [PROPOSAL], [ QUESTION].\n\n\n## Pull requests\n\nAny Airalab repository or this documentation may be subject to pull requests or changes by contributors where you believe you have something valuable to add or change. Please, do not forget about basic rules for contributors.\n\n### Rules for contributing\n\n1. Pull requests are preferred to issues, if you have some fixes, especially for small changes such as typos.\n\n2. Make sure the PR description clearly describes the problem and the solution. Include the relevant issue number if applicable.\n\n3. Please, do not fix whitespace, format code, or make a purely cosmetic patch.\n\n4. Please, attempt to adhere to the prevailing Markdown style, language, and layout.\n\n\n"}},{node:{id:"2fbe5239d779b137136f6c6c20728097",title:"Connect the simplest CPS",path:"/docs/es/connect-simple-cps/",content:'\nIn this section we will build the simplest real cyber-physical system!\n\nWe will buy a "wink" from Arduino, e.g. make Arduino blink with its onboard led. The lesson is tested on Arduino Uno, but any other board with a led will do the job.\n\n> The source code of this lesson is [here](https://github.com/airalab/robonomics_tutorials/tree/master/arduino_blink).\n\n## Arduino\n\nThe firmware for the board is located in [arduino_blink/misc/arduino/arduino.ino](https://github.com/airalab/robonomics_tutorials/blob/master/arduino_blink/misc/arduino/arduino.ino). Use [Arduino IDE](https://www.arduino.cc/en/Main/Software) to load the code to your Arduino board.\n\nIn the code we subscribe for the ``/blink_led`` topic and set a callback. The type of the topic is ``Empty``, so the board waits until someone publishes to the topic and performs the LED blinking.\n\n```\n  #include <ros.h>\n  #include <std_msgs/Empty.h>\n\n  ros::NodeHandle  nh;\n\n  void blink(int led, int mil) {\n\n    digitalWrite(led, HIGH);\n    delay(mil);\n    digitalWrite(led, LOW);\n    delay(mil);\n\n  }\n\n  void messageCb( const std_msgs::Empty& toggle_msg){\n    blink(LED_BUILTIN, 500);\n    blink(LED_BUILTIN, 500);\n    blink(LED_BUILTIN, 500);\n  }\n\n  ros::Subscriber<std_msgs::Empty> sub("blink_led", &messageCb );\n\n  void setup()\n  {\n    pinMode(LED_BUILTIN, OUTPUT);\n    nh.initNode();\n    nh.subscribe(sub);\n  }\n\n  void loop()\n  {\n    nh.spinOnce();\n    delay(1);\n  }\n```\n\n\n## AIRA client\n\n> You can download the latest release from [here](https://github.com/airalab/aira/releases).\n\nSet up the COM port forwarding. You should forward your `/dev/ttyUSB0` or `/dev/ttyACM0` port (depending on the system) to `COM1`. In the client `/dev/ttyS0` will represent the board. After this launch the virtual machine.\n\n## ROS\n\nWhen new liability is created it goes to `/liability/ready` topic. We have to remember the address and call `/liability/start` service to get the data from objective.\n\n```\n  def newliability(l):\n    self.liability = l.address\n    rospy.loginfo("Got new liability {}".format(self.liability))\n\n    prefix = "/liability/eth_" + self.liability\n    rospy.Subscriber(prefix + \'/blink\', Empty, self.blink)\n\n    rospy.wait_for_service("/liability/start")\n    rospy.ServiceProxy(\'/liability/start\', StartLiability)(StartLiabilityRequest(address=self.liability))\n  rospy.Subscriber("/liability/ready", Liability, newliability)\n```\n\nA message in the `/blink` topic come from the objective field. Have a look at [Basic usage](/docs/aira-basic-usage) page.\n\n## AIRA\n\nConnect to AIRA client via SSH as described [here](/docs/aira-connecting-via-ssh). All tutorials are pre-installed. To launch the ros package run the following command:\n\n```\n$ rosrun arduino_blink blink.py\n```\n\nAlso we need to add a rosbag file to IPFS::\n\n```\n$ ipfs add rosbag/blink.bag\n```\n\n> Before the next step you should approve XRT tokens on the Factory.\n\nOn your host system build and launch an Dapp for the lesson:\n\n```\n$ git clone https://github.com/airalab/robonomics_tutorials/\n$ cd robonomics_tutorials/arduino_blink_dapp\n$ npm i && npm run dev\n```\n\nOpen [http://localhost:8000/](http://localhost:8000/) and press "Demand" then "Offer" buttons. Wait until a new liability is created and you should see the board blinking. Congratulations on the first agent!\n'}},{node:{id:"f13553fe93323ed00030c001baa37097",title:"Connect Sensor To Robonomics Network",path:"/docs/es/connect-sensor-to-robonomics/",content:'\n## Requiremets\n* ESP8266 Node MCU v3\n* particle sensor SDS011\n* micro USB cable\n* connecting wires\n\n## Assembling\n### Connection Diagram\n\n![scheme](../images/sensors-connectivity/schema.jpg)\n\n### Connecting SDS011\n\n* Pin 1 (TX) -> (RX) Pin D1 (GPIO5)\n* Pin 2 (RX) -> (TX) Pin D2 (GPIO4)\n* Pin 3 (GND) -> GND\n* Pin 4 (2.5m) -> unused\n* Pin 5 (5V) -> VU\n* Pin 6 (1m) -> unused\n\nSensor is shipped with a USB adapter and connection wires. You don\'t need USB adapter, so disconnect wires from it.\n\n![disconnect](../images/sensors-connectivity/2_assembly_usb.jpg)\n\nYou may connect it to ESP via connecting wires "Female-Male":\n\n![f-m](../images/sensors-connectivity/3_conn.jpg)\n\nAnd connect them to your ESP according to the connection diagram.\n\nOr you can use wires from USB adapter. Disconnect one wire: push on it with some sharp object and carefully pull the wire:\n\n![extreme_con](../images/sensors-connectivity/4_assembly_wires.jpg)\n\nInsert it to last connector:\n\n![extr](../images/sensors-connectivity/5_wires1.jpg)\n\nThen cut the connector in the middle:\n\n![cut](../images/sensors-connectivity/6_assembly_wires2.jpg)\n\nAnd connect them to ESP according to the diagram:\n\n![esp_con](../images/sensors-connectivity/6_esp_con.jpg)\n\n### Connecting DHT22\n\n\n* Pin 1 => 3V3\n* Pin 2 => Pin D7 (GPIO13)\n* Pin 3 => unused\n* Pin 4 => GND\n\n### Connecting BME280/HTU21D\n\n* VCC -> Pin 3V3\n* GND -> Pin GND\n* SCL -> Pin D4 (GPIO2)\n* SDA -> Pin D3 (GPIO0)\n\n\n## Device Firmware\nDownload `airrohr-flasher` from the [latest release](https://github.com/airalab/sensors-connectivity/releases) for your OS. \nConnect ESP to computer via micro-USB and run flasher. \n\n### For Linux:\nFirstly you need to add the user to `dialout` group:\n```bash\nsudo usermod -a -G dialout $USER\n```\nThen logout and login or restart computer.\n\nNow you can run flasher (don\'t forget to give it permission to execute):\n```bash\nchmod +x airrohr-flasher-linux\n./airrohr-flasher-linux\n```\n\n### For Windows:\nUnpack flasher and run it with double click.\nYou need to install drivers for the USB2serial chipset (Windows 10 should be able to automatically download these):\n\n* Drivers for NodeMCU v3 (CH340): [Windows](http://www.wch.cn/downloads/file/5.html) ([2018/09/04 v3.4 mirror](https://d.inf.re/luftdaten/CH341SER.ZIP))\n\n\n### For MacOS\nDownload flasher and run it.\nYou need to install drivers for the USB2serial chipset: \n* Drivers for NodeMCU v3 (CH340): [MacOS](http://www.wch.cn/downloads/file/178.html) ([2018/09/04 v1.4 mirror](https://d.inf.re/luftdaten/CH341SER_MAC.ZIP))\n\n\nChoose firmware (English or Russian) and press upload. It will take a few minutes.\n\n![flasher](../images/sensors-connectivity/7_flasher.jpg)\n\n\n## Configuration\nReboot your ESP (simply reconnect USB to computer).\nThen connect to airRohr--xxxxxxx Wi-Fi network and in your browser write address 192.168.4.1:\n\n![menu](../images/sensors-connectivity/8_menu1.jpg)\n\nGo to Configuration -> Wi-Fi Settings and add the information about your Wi-Fi network:\n\n![config](../images/sensors-connectivity/9_W-fi.jpg)\n\nThen press "Save configuration and restart" and ESP will be connected to the provided Wi-Fi network.\n\n![save](../images/sensors-connectivity/10_save.jpg)\n\n\nThen find ESP in local network (for that your computer and ESP must be in one network). You can do it using airrohr-flasher. Run it, go to the Discovery tab and press Refresh, then you\'ll be able to see the address.\n\n![addr](../images/sensors-connectivity/11_flaser2.jpg)\n\n\n\nOpen ESP local address in your browser, go to `APIs` tab in  `Configuration` and click `Robonomics`. \n\n![robonomics](../images/sensors-connectivity/12_APIrobonomics.jpg)\n\n> If you want to send data to your own server, enable `Custom API` and write your address and port \n\nThen go to `Sensors` tab, enable GPS and put in your coordinates. Also enable the sensors you connected:\n\n![gps](../images/sensors-connectivity/13_gps.jpg)\n\nThen press `Save configuration and restart`.\n\n\n\n## Results\nGo to [sensors.robonomics.network](https://sensors.robonomics.network/#/), and you will see your sensor on the map.\n\n![map](../images/sensors-connectivity/14_map.jpg)\n'}},{node:{id:"d38ce67f7d8eec299032fcce2468d57c",title:"Connect Mars Curiosity rover under Robonomics parachain control",path:"/docs/es/connect-mars-curiosity-rover-under-robonomics-parachain-control/",content:'\n**Let\'s see how Robonomics Parachain control allows to make Mars Curiosity rover move. Requirements:**\n- Ubuntu 18.04 LTS\n- ROS Melodic + Gazebo + RViz (installation manual [here](http://wiki.ros.org/melodic/Installation))\n- extra packages:\n```shell\nsudo apt-get install ros-melodic-gazebo-ros-control ros-melodic-effort-controllers ros-melodic-joint-state-controller\n```\n- IPFS 0.4.22 (download from [here](https://dist.ipfs.io/go-ipfs/v0.4.22/go-ipfs_v0.4.22_linux-386.tar.gz) and install)\n- Python dependencies:\n```\npip install ipfshttpclient\n```\n- Robonomics node (binary file) (download latest release [here](https://github.com/airalab/robonomics/releases))\n- IPFS browser extension (optional)\n\nHere is the video showing successful launch:\n\nhttps://youtu.be/pl3eIEC_T2o\n\n## 1. Set up a simulation\nDownload Curiosity rover package:\n```\nmkdir -p robonomics_ws/src\ncd robonomics_ws/src\ngit clone https://bitbucket.org/theconstructcore/curiosity_mars_rover/src/master/\ncd ..\n```\nWe need to adjust starting conditions to make our rover spawn smoothly:\n- Go to\n\n`/robonomics_ws/src/master/curiosity_mars_rover_description/worlds` and change line 14 of the file` mars_curiosity.world` to\n`<pose>0 0 9 0 0 0</pose>`.\n\n- Go to\n\n`/robonomics_ws/src/master/curiosity_mars_rover_description/launch` and change line 4 of the file `mars_curiosity_world.launch` to\n`<arg name="paused" default="false"/>`.\n\nDon’t forget to add source command to `~/.bashrc`:\n```\necho "source /home/$USER/robonomics_ws/devel/setup.bash" >> ~/.bashrc\n```\n\n## 2. Download controller package\nIn terminal do the following. This will download a sample script used in the demo:\n```\ncd ~/robonomics_ws/src\ngit clone https://github.com/PaTara43/robonomics_sample_controller\ncd ../..\ncatkin build\n```\n\n## 3. Manage accounts in DAPP\nSince we are testing, let\'s create a local robonomics network node with robonomics binary file:\n```\n./robonomics --dev --rpc-cors all\n```\n**Important!** Before next launches it is necessary to remove a directory `db` with\n\n```\nrm -rf /home/$USER/.local/share/robonomics/chains/dev/db\n```\n\nAfter a successful launch create accounts for the rover and for it\'s employer following [this](/docs/create-account-in-dapp) manual. **Do not forget to save each account\'s seed (RAW SEED) and address! You will need them for transactions**. Add these addresses, seeds and path to robonomics binary file to file `config.config` in `robonomics_ws/src/robonomics_sample_controller/src`. Transfer some money (units) to these accounts:\n\n![Config](../images/curiosity-demo/config.jpg "Config")\n\n![Balances](../images/curiosity-demo/balances.jpg "Balances")\n\n## 4. Start Robonomics\nUp to now the **only thing running** should be the robonomics local node.\nIn a separate terminal launch IPFS:\n```\nipfs init # you only need to do this once\nipfs daemon\n```\nIn another separate terminal launch Curiosity simulation:\n```\nroslaunch curiosity_mars_rover_description main_real_mars.launch\n```\nWait till it stays still and after that in another terminal launch the controller:\n```\nrosrun robonomics_sample_controller sample_controller.py\n```\n\n![Curiosity](../images/curiosity-demo/curiosity.jpg "Curiosity")\n\nNow you can send a transaction triggering the Rover to start moving and collecting data. To do so, you should use the [Robonomics IO](https://wiki.robonomics.network/docs/rio-overview/)  `write` subcommand of robonomics binary file:\n```\necho "ON" | ./robonomics io write launch -r <CURIOSITY ADDRESS> -s <EMPLOYER’S KEY>\n```\nWhere `<CURIOSITY ADDRESS>`  and `<EMPLOYER’S KEY>` are replaced with  previously saved strings accordingly.\nYou should see the log `"Arming..."` and the robot should start moving its camera and arm. Later, when the job is done (there is a log informing user when the program has finished), on the Robonomics portal go to `Developer` -> `Chain state` and add a CURIOSITY datalog using `“+”` button with selected `datalog` as state query:\n\n![Datalog](../images/curiosity-demo/hash_in_chain.jpg "Datalog")\n\nThe IPFS hash of the telemetry has been saved in the blockchain. To see the data simply copy the hash and add it to the local [gateway](https://gateway.ipfs.io/ipfs/QmeYYwD4y4DgVVdAzhT7wW5vrvmbKPQj8wcV2pAzjbj886/docs/getting-started/) address `localhost:8080/ipfs/`:\n\n![Voila](../images/curiosity-demo/datalog.jpg "Voila")\n\n## Troubleshooting\n\nIf due to some reason addresses in IO module and on the portal are displayed unequally (e.g. `5...` and `4...`) and the program outputs "Not my job is paid", fill in configuration file with address of the same type as in IO module.\n'}},{node:{id:"e2b4d15c43faa51ca378bf58724352a4",title:"Connect any ROS-compatitable robot under Robonomics parachain control. Part 2, IPFS",path:"/docs/es/connect-any-ros-compatitable-robot-under-robonomics-parachain-control-2/",content:'\n**In this article we will continue using Robonomics tools to make a drone be controlled by a parachain. This time we will add sending data to IPFS and hash storing in chain options. Below is the instruction and code snippets. Requirements:**\n- [**Part 1 of this tutorial**](/docs/connect-any-ros-compatitable-robot-under-robonomics-parachain-control-1)\n- Ubuntu 18.04 LTS\n- ROS Melodic + Gazebo + RViz (installation manual [here](http://wiki.ros.org/melodic/Installation))\n- IPFS 0.4.22 (download from [here](https://dist.ipfs.io/go-ipfs/v0.4.22/go-ipfs_v0.4.22_linux-386.tar.gz) and install)\n- Robonomics node (binary file) (download latest release [here](https://github.com/airalab/robonomics/releases))\n- Python dependencies:\n```\npip install cv_bridge ipfshttpclient\n```\nThe entire process of coding this part of demo is presented in a video below.\n\nhttps://www.youtube.com/watch?v=dliLb6GHgpo&feature=youtu.be\n\n\n## 1. Add dependencies\nIf we launch a simulation and look at the topic list (see previous tutorial), we will see, that there is one topic containing front camera data and using `sensor_msgs/Image` message type:\n\n![front_camera](../images/drone-demo/front_camera.jpg "front_camera")\n\nLet\'s try to take a picture every 1 second and after the flight publish these photos to IPFS. If you have completed the first tutorial, you don\'t need to download anything else. It\'s the `drone_sample_controller_pictures.py` script.\n## 2. Manage accounts in DAPP\nAs done in a previous tutorial, create a local robonomics network node with robonomics binary file:\n```\n./robonomics --dev\n```\n**Important!** Before next launches it is necessary to remove a directory `db` with\n```\nrm -rf /home/$USER/.local/share/robonomics/chains/dev/db\n```\nAfter a successful launch create accounts following [this](/docs/create-account-in-dapp) manual. **Do not forget to save each account\'s seed and address! You will need them for transactions**. Add these addresses, seeds and path to robonomics binary file to file `config.config` in `robonomics_ws/src/robonomics_sample_controller/src`. Transfer some money (units) to these accounts:\n\n![balances](../images/drone-demo/balances.jpg "balances")\n## 3. Launch\nUp to now the **only thing running** should be the robonomics local node. In a separate terminal launch drone simulation:\n```\nroslaunch sjtu_drone simple.launch\n```\nIn another one launch ipfs daemon:\n```\nifps init # you only need to do this once\nipfs daemon\n```\nRun the script:\n```\nrosrun drone_simulator_controller drone_sample_controller_pictures.py\n```\nNow you can send a transaction triggering the drone to start flying and taking pictures. To do so, you should use the Robonomics IO `write` subcommand of robonomics binary file:\n```\necho "ON" | ./robonomics io write launch -r <DRONE_ADDRESS> -s <EMPLOYER’S_KEY>\n```\nWhere `<DRONE_ADDRESS>`  and `<EMPLOYER’S_KEY>` are replaced with  previously saved strings accordingly.\nYou should see the log `"Taking Off"` and the drone should start flying and taking pictures:\n\n![flying_picturing](../images/drone-demo/flying_picturing.jpg "flying_picturing")\n\nLater, when the job is done, on the Robonomics portal go to `Developer` -> `Chain state` and add a `DRONE` datalog using `“+”` button with selected `datalog` as state query. The IPFS hash of the telemetry has been saved in the blockchain. To see the data simply copy the hash and add it to the local [gateway](https://gateway.ipfs.io/ipfs/QmeYYwD4y4DgVVdAzhT7wW5vrvmbKPQj8wcV2pAzjbj886/docs/getting-started/) address `localhost:8080/ipfs/`:\n\n![Voila](../images/drone-demo/datalog.jpg "Voila")\n'}},{node:{id:"ceb0388566334ca64ac7d42380a7bf37",title:"Connect ROS-compatibale Drone To Robonomics Parachain. Part 1. Launch by Transaction",path:"/docs/es/connect-any-ros-compatitable-robot-under-robonomics-parachain-control-1/",content:'\n**In this article we will show that with the help of Robonomics tools you can control any ROS-compatitable device. We will find a random drone simulation package on the web and adjust it to run with Robonomics.**\n**Requirements:**\n- Ubuntu 18.04 LTS\n- ROS Melodic + Gazebo + RViz (installation manual [here](http://wiki.ros.org/melodic/Installation))\n- Robonomics node (binary file) (download latest release [here](https://github.com/airalab/robonomics/releases))\n\nThe entire process of coding this part of demo is presented in a video below.\n\nhttps://www.youtube.com/watch?v=fDpwhBasQ5o&feature=youtu.be\n\n## 1. Find a simulation\nLet\'s surf the web. Google for `ROS drone simulator`. The first link will mostly likely show you the `tum_simulator` page on [http://wiki.ros.org/tum_simulator](http://wiki.ros.org/tum_simulator)\n\n![tum_simulator](../images/drone-demo/tum_simulator.jpg "tum_simulator")\n\nIt\'s pretty outdated, so we better find a fork for our system. Google for `tum_simulator Ubuntu 18 Gazebo 9 fork`. The first result is a GitHub [repo](https://github.com/tahsinkose/sjtu-drone) with an appropriate package. Dowload it\n```\nmkdir -p drone_simulator_ws/src\ncd drone_simulator_ws/src\ngit clone https://github.com/tahsinkose/sjtu-drone\ncd ..\ncatkin build\n```\nDon’t forget to add source command to `~/.bashrc`:\n```\necho "source /home/$USER/drone_simulator_ws/devel/setup.bash" >> ~/.bashrc\nsource "~/.bashrc"\n```\nNow we can run the simulation to see what do we need to do to take the drone under parachain control.\n```\nroslaunch sjtu_drone simple.launch\n```\n\n## 2. Inspect ROS topics\nWhen the simulation is runnung, in a new tab run the following command to see the list of topics used by the drone:\n```\nrostopic list\n```\nLet\'s take a look at `/cmd_vel`, `/drone/takeoff` and `/drone/land`:\n```\nrostopic info /cmd_vel\nrostopic info /drone/takeoff\nrostopic info /drone/land\n```\n\n![topics_info](../images/drone-demo/topics_info.jpg "topics_info")\n\nAs may be seen, there should be messages of `Twist` and `Empty` types, they are parts of `std_msgs` and `geometry_msgs`, we\'ll use this in the controller. Shut the simulation for a while.\n## 3. Download controller package\nGlobally, the main difference from the casual ROS robot controller is a block of code, which checks all the transactions in the network using [Robonomics IO](https://wiki.robonomics.network/docs/rio-overview/). The package itself is available on GitHub. Download it and build the workspace:\n```\ncd ~/drone_simulator_ws/src\ngit clone https://github.com/PaTara43/drone_simulator_controller\ncd drone_simulator_controller/src\nchmod +x *.py\ncd ~/drone_simulator_ws/src\ncatkin build\n```\n## 4. Manage accounts in DAPP\nSince we are testing, let\'s create a local robonomics network node with robonomics binary file:\n```\n./robonomics --dev\n```\n**Important!** Before next launches it is necessary to remove a directory `db` with\n\n```\nrm -rf /home/$USER/.local/share/robonomics/chains/dev/db\n```\nAfter a successful launch create accounts following [this](/docs/create-account-in-dapp) manual. **Do not forget to save each account\'s seed and address! You will need them for transactions**. Add these addresses, seeds and path to robonomics binary file to file `config.config` in `robonomics_ws/src/robonomics_sample_controller/src`. Transfer some money (units) to these accounts:\n\n![balances](../images/drone-demo/balances.jpg "balances")\n## 5. Launching the drone under parachain control\nUp to now the **only thing running** should be the robonomics local node. In a separate terminal launch drone simulation:\n```\nroslaunch sjtu_drone simple.launch\n```\nRun the script:\n```\nrosrun drone_simulator_controller drone_sample_controller.py\n```\n\n![launched_drone](../images/drone-demo/launched_drone.jpg "launched_drone")\n\nNow you can send a transaction triggering the drone to start flying. To do so, you should use the Robonomics IO `write` subcommand of robonomics binary file:\n```\necho "ON" | ./robonomics io write launch -r <DRONE_ADDRESS> -s <EMPLOYER’S_KEY>\n```\nWhere `<DRONE_ADDRESS>`  and `<EMPLOYER’S_KEY>` are replaced with  previously saved strings accordingly.\nYou should see the log `"Taking Off"` and the drone should start flying:\n\n![flying](../images/drone-demo/flying.jpg "flying")\n\nThat\'s how any ROS-compatitable robot can be controlled by Robonomics parachain control. Proceed to [part 2](/docs/connect-any-ros-compatitable-robot-under-robonomics-parachain-control-2) to learn more\n'}},{node:{id:"29a3a773d0595bfe002851bc426d4dff",title:"Configuration Options Description",path:"/docs/es/configuration-options-description/",content:'\nBasically, you can think of the package as a black box with one input (sensor data) and many outputs.\nFor now only SDS011 sensor is supported, but if you are familiar with Python it\'d be easy to add other sensors as well.\n\nHave a look at [configuration](https://github.com/airalab/sensors-connectivity/blob/master/config/default.json) file:\n\n```json\n{\n   "general":{\n      "publish_interval":30\n   },\n   "comstation":{\n      "enable":false,\n      "port":"/dev/ttyUSB0",\n      "work_period":300,\n      "geo":"",\n      "public_key":""\n   },\n   "httpstation":{\n      "enable":true,\n      "port":8001\n   },\n   "mqttstation": {\n      "enable": true,\n      "host": "connectivity.robonomics.network",\n      "port": 1883\n   },\n   "luftdaten":{\n      "enable":true\n   },\n   "robonomics":{\n      "enable":true,\n      "ipfs_provider":"/ip4/127.0.0.1/tcp/5001/http",\n      "ipfs_topic":"airalab.lighthouse.5.robonomics.eth"\n   },\n   "datalog":{\n      "enable":false,\n      "path":"",\n      "suri":"",\n      "remote":"wss://substrate.ipci.io",\n      "dump_interval":3600,\n      "temporal_username":"",\n      "temporal_password":""\n   },\n   "dev":{\n      "sentry":""\n   }\n}\n```\nAt the moment it\'s possible to publish data to [Luftdaten](https://luftdaten.info/), [Robonomics Network](https://robonomics.network/) and [Datalog](https://github.com/airalab/robonomics).\nThe last one is experimental!\n\n> DO NOT edit `config/default.json` file. Instead make a copy\n\nPlay around with the configuration!\n\nExplanation of options:\n\n| Field                         | Description                                                                                                                                                                                                                                           |\n|------------------------------    |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------    |\n| `general/publish_interval`         | integer number from 1 and above. Tells how often send measurements. Keep in mind that if measurements from sensors come less often than this number connectivity sends last data      |\n| `comstation/enable`                | true/false. Enabling/disabling the station      |\n| `comstation/port`                  | valid path to com port, for example `/dev/ttyUSB0`. It is where a sensor is connected to      |\n| `comstation/work_period`           | integer from 0 to 1800. For SDS011 sensor 0 means continuous work. Recommended period is 300 seconds     |\n| `comstation/geo`                   | `lat,lon` a string with two floats separated by a comma. It represents latitude and longitude of a sensor     |\n| `comstation/public_key`            | Ed25519 verifying key in hex format. If not provided connectivity generates a new one      |\n| `httpstation/enable`                | true/false. Enabling/disabling the station   |\n| `httpstation/port`                  | what port listen to      |\n| `mqttstation/enable`                | true/false. Enabling/disabling the station   |\n|`mqttstation/host`                   | the hostname or IP address of the remote broker |\n|`mqttstation/port`                   | the network port of the server host to connect to |\n| `luftdaten/enable`                 | true/false. Whether or not publish data to [Luftdaten](https://devices.sensor.community/). Don\'t forget to register the sensor\'s mac address on the site         |\n| `robonomics/enable`                | true/false. Whether or not publish data to IPFS topic according to Robonomics communication protocol      |\n| `robonomics/ipfs_proveder`         | an endpoint for IPFS daemon. By default it\'s `/ip4/127.0.0.1/tcp/5001/http` that means local daemon. The endpoint must by in multiaddr format. For example for [Infura.io](https://infura.io/) it would be `/dns/ipfs.infura.io/tcp/5001/https`       |\n| `robonomics/ipfs_topic`            | IPFS topic\'s name. If you want to use [DApp](https://sensors.robonomics.network) provided by Robonomics team leave it untouched                 |\n| `datalog/enable`                   | true/false. Enable/Disable saving log to [Robonomics on Substrate chain](https://ui.ipci.io/)    |\n| `datalog/path`                     | full path to `robonomics` executable file. You can find the latest release on [this](https://github.com/airalab/robonomics/releases) page  |\n| `datalog/suri`                     | a private key from substrate chain account  |\n| `datalog/remote`                   | an endpoint to substrate instance                                                           |\n| `datalog/dump_interval`            | specify a period of time for collecting log in seconds                                      |\n| `datalog/temporal_username`        | set username to upload files to [Temporal.Cloud](https://temporal.cloud/) (Optional)                  |\n| `detalog/temporal_password`        | set password to upload files to [Temporal.Cloud](https://temporal.cloud/) (Optional)                  |\n| `dev/sentry`                       | for development purpose. If you have a [Sentry.io](https://sentry.io/) account you can put sentry\'s credentials in here   |\n\n## Scenario #1: Connect SDS011 to serial port\n\nThe easiest and the most straightforward way to connect your sensor to the network is using the serial port\n\nConnect you SDS011 sensor to a USB port, let\'s assume it got `/dev/ttyUSB0` address\n\n```json\n{\n   "general":{\n      "publish_interval":30            \n   },\n   "comstation":{\n      "enable":true,\n      "port":"/dev/ttyUSB0",\n      "work_period":300,\n      "geo":"59.944954,30.294534",\n      "public_key":""\n   },\n   "httpstation":{\n      "enable":false,\n      "port":8001\n   },\n   "luftdaten":{\n      "enable":true\n   },\n   "robonomics":{\n      "enable":true,\n      "ipfs_provider":"/ip4/127.0.0.1/tcp/5001/http",\n      "ipfs_topic":"airalab.lighthouse.5.robonomics.eth"\n   },\n   "datalog":{\n      "enable":false,\n      "path":"",\n      "suri":"",\n      "remote":"wss://substrate.ipci.io",\n      "dump_interval":3600,\n      "temporal_username":"",\n      "temporal_password":""\n   },\n   "dev":{\n      "sentry":""\n   }\n}\n```\n\n## Scenario #2: Connect SDS011 via HTTP\n\n### Connectivity Configuration\n\n```json\n{\n   "general":{\n      "publish_interval":30            \n   },\n   "comstation":{\n      "enable":false,\n      "port":"/dev/ttyUSB0",\n      "work_period":300,\n      "geo":"59.944954,30.294534",\n      "public_key":""\n   },\n   "httpstation":{\n      "enable":true,\n      "port":8001\n   },\n   "luftdaten":{\n      "enable":true\n   },\n   "robonomics":{\n      "enable":true,\n      "ipfs_provider":"/ip4/127.0.0.1/tcp/5001/http",\n      "ipfs_topic":"airalab.lighthouse.5.robonomics.eth"\n   },\n   "datalog":{\n      "enable":false,\n      "path":"",\n      "suri":"",\n      "remote":"wss://substrate.ipci.io",\n      "dump_interval":3600,\n      "temporal_username":"",\n      "temporal_password":""\n   },\n   "dev":{\n      "sentry":""\n   }\n}\n```\n\n> Do not forget to open the port in system firewall\n>\n> On NixOS you can do:\n> ```\n> networking.firewall.allowedTCPPorts = [ 31313 ];\n> ```\n\n## Scenario #3: Connect SDS011 via MQTT\n\n### Connectivity Configuration\n\n```json\n{\n   "general":{\n      "publish_interval":30\n   },\n   "comstation":{\n      "enable":false,\n      "port":"/dev/ttyUSB0",\n      "work_period":300,\n      "geo":"",\n      "public_key":""\n   },\n   "httpstation":{\n      "enable":true,\n      "port":8001\n   },\n   "mqttstation": {\n      "enable": true,\n      "host": "connectivity.robonomics.network",\n      "port": 1883\n   },\n   "luftdaten":{\n      "enable":true\n   },\n   "robonomics":{\n      "enable":true,\n      "ipfs_provider":"/ip4/127.0.0.1/tcp/5001/http",\n      "ipfs_topic":"airalab.lighthouse.5.robonomics.eth"\n   },\n   "datalog":{\n      "enable":false,\n      "path":"",\n      "suri":"",\n      "remote":"wss://substrate.ipci.io",\n      "dump_interval":3600,\n      "temporal_username":"",\n      "temporal_password":""\n   },\n   "dev":{\n      "sentry":""\n   }\n}\n```\n\n## Scenario #4: Connect Multiple Sensors and Publish to Datalog\n\n### Install Robonomics\n\nFrom `root` user do:\n\n```\necho "https://github.com/airalab/airapkgs/archive/nixos-unstable.tar.gz nixos" > /root/.nix-channels\nnix-channel --update\n```\n\nThen edit `/etc/nixos/configuration.nix` and add:\n\n```\n...\n  environment.systemPackages = with pkgs; [\n        substrate-node-robonomics-bin\n  ];\n...\n```\n\nRun rebuild and find out where `robonomics` is:\n```\nnixos-rebuild switch\nwhereis robonomics\n```\n\nLet\'s assume you got the following path: `/nix/store/2gz2ik17w5xad8w819bsb05a23pbjbya-system-path/bin/robonomics`\n\n### Configuration\n\n```json\n{\n   "general":{\n      "publish_interval":30            \n   },\n   "comstation":{\n      "enable":false,\n      "port":"/dev/ttyUSB0",\n      "work_period":300,\n      "geo":"59.944954,30.294534",\n      "public_key":""\n   },\n   "httpstation":{\n      "enable":true,\n      "port":8001\n   },\n   "luftdaten":{\n      "enable":true\n   },\n   "robonomics":{\n      "enable":true,\n      "ipfs_provider":"/ip4/127.0.0.1/tcp/5001/http",\n      "ipfs_topic":"airalab.lighthouse.5.robonomics.eth"\n   },\n   "datalog":{\n      "enable":true,\n      "path":"/nix/store/2gz2ik17w5xad8w819bsb05a23pbjbya-system-path/bin/robonomics",\n      "suri":"0x...",\n      "remote":"wss://substrate.ipci.io",\n      "dump_interval":3600,\n      "temporal_username":"temporaluser",\n      "temporal_password":"temporalpass"\n   },\n   "dev":{\n      "sentry":""\n   }\n}\n```\n\n\n'}},{node:{id:"8332f5b88bb826b2a7bc3452ff171f40",title:"Community",path:"/docs/es/community/",content:"\n**Here you can learn how to get involved in the Robonomics Network Community.**\n\nThere are many ways to contribute to Robonomics Network: you can contribute directly based on your skills and professional background, you can attend an event, join the conversation online or watch for our latest news and release.\n\n## For Developers\n\n- [Robonomics' code base and new releases on GitHub](https://github.com/airalab)\n- [Ask your technical question on Riot](https://riot.im/app/#/room/#robonomics:matrix.org)\n\n## For Researchers & Academics\n\n- [Read Robonomics White Paper and our scientific articles](https://robonomics.network/community/#science)\n\nIf you have a background in mathematics, cryptography, or economics you might be interested for collaboration with us, write us to [research@aira.life](mailto:research@aira.life)\n\n## For All, even non-technical\n\n- [Get familiar with Robonomics services and statistics in dApp - open in browser with Metamask](https://dapp.robonomics.network)\n- [Read our blog](https://blog.aira.life)\n- [Stay tuned by following us on Twitter](https://twitter.com/AIRA_Robonomics)\n\nIf you are not a developer or a researcher, you can start with other suggestions for getting involeved in Robonomics Network Community. If you want to organize a meetup in your city, write content about Robonomics, translate Robonomics content into your native language, write to [community@aira.life](mailto:community@aira.life)\n"}},{node:{id:"15c6cfe6de8d4524a770338780070ed6",title:'Say "Hello Baxter!" with robonomics',path:"/docs/es/baxter2/",content:'\nExample of how it works is available [here][db1].\n\n## Requirements:\n - Ubuntu 18.04\n - ROS Melodic + Gazebo (installation manual [here][db2])  \n - extra packages:\n```sh\nsudo apt-get install ros-melodic-qt-build ros-melodic-driver-common ros-melodic-gazebo-ros-control ros-melodic-gazebo-ros-pkgs ros-melodic-ros-control ros-melodic-control-toolbox ros-melodic-realtime-tools ros-melodic-ros-controllers ros-melodic-xacro python-wstool ros-melodic-tf-conversions ros-melodic-kdl-parser python-wstool python-catkin-tools qt4-default\n```\n\n- IPFS 0.4.22 (download from [here][db3] and install)\n- pip:\n```sh\nsudo apt install python-pip\n```\n\n- ipfshttpclient\n```sh\npip install ipfshttpclient\n```  \n\n\n - Robonomics node (binary file) (download latest [release][db4] here)\n - Create __Baxter__ and __Employer__ accounts  on **Robonomics Portal**  \n (you can find tutorial ["Create an Account on Robonomics Portal"][db8] here).\n - IPFS browser extension (not necessary)\n\n## 1. Download Baxter model\nDownload packages:\n```sh\ncd ~\nmkdir -p robot_ws/src\ncd robot_ws/src/\nwstool init .\nwstool merge https://raw.githubusercontent.com/RethinkRobotics/baxter_simulator/master/baxter_simulator.rosinstall\nwstool update\ngit clone https://github.com/nakata5321/Baxter_simulation_controller.git\n```\nThis packages were created for ROS indigo. We have to change some files to run them on ROS melodic.\nWe will use **patch** files.\n```sh\npatch ./baxter_simulator/baxter_sim_io/include/baxter_sim_io/qnode.hpp ./Baxter_simulation_controller/patch/qnode_patch\npatch ./baxter_simulator/baxter_sim_kinematics/src/arm_kinematics.cpp ./Baxter_simulation_controller/patch/arm_patch\n```\nAnd let\'s build  all our packages:\n```sh\ncd ..\ncatkin build\n```\nDont forget to add source command:\n```sh\necho "source /home/$USER/robot_ws/devel/setup.bash" >> ~/.bashrc\nsource ~/.bashrc\n```  \n__Important!__ At the end save *Robonomics node (binary file)* in **robot_ws** directory.\n\n## 2. Start simulation\nFirst of all copy and edit `baxter.sh`\n```sh\ncp src/baxter/baxter.sh .\n```\n\nFind your local ip adress with command:\n```\nip a\n```\n![ip_a][im14]\n\nEdit the following values in `baxter.sh` :\n```\nnano baxter.sh\n```\n\nEdit the following values in `baxter.sh` :\n\n- your_ip - put your local ip address. See `ip a`\n- ros_version - for example "melodic"\n\n![baxtersh][im15]\n\nRun the baxter shell script with sim specified:\n```sh\n./baxter.sh sim\nroslaunch baxter_gazebo baxter_world.launch\n```\nYou can put some models in front of our baxter. It will be more intresting.\n![baxter][im2]\n\n## 3.Manage accounts in DAPP\n\nSince we are testing, let us create a local robonomics network with robonomics binary file. Go to folder with robonomics file and run:\n```sh\n./robonomics --dev --rpc-cors all\n```\n![robonomics][im3]\n\nDon\'t forget to remove `db` folder after every launch:\n```sh\nrm -rf /home/$USER/.local/share/robonomics/chains/dev/db\n```\n\nGo to [https://parachain.robonomics.network][db5] and switch to local node\n![local node][im4]\n\nGo to Accounts and transfer some money to __Baxter__ and __Employer__ accounts.\n\nYou can find The manual "Create an Account on Robonomics Portal" [here.][db8]\n\n\nAdd Baxter\'s secret key and adress to `config.yaml` in `robot_ws/src/Baxter_simulation_controller/config/`\n\n## 4.Beginning of work\n\nIn new window run:\n```sh\nifps init #you only need to do this once\nipfs daemon\n```\nOpen separate terminal and start *controller package*:\n```sh\nrosrun robot_controller robot_control.py\n```\n![waiting][im7]\n\nReturn to the first terminal, open new window and send command to [**robonomics io**][db6]. This command will turn ON your robot:\n```sh\necho "ON" | ./robonomics io write launch -r <BAXTER ADDRESS> -s <EMPLOYER’S KEY>\n```\nWhere `<BAXTER ADDRESS>`  and `<EMPLOYER’S KEY>` are replaced with previously saved strings accordingly.\n\n![rob_message][im8]\n\nYou should see the following:\n\n![working][im9]\n\nwhen the work is over go to the Robonomics Portal to `Developer > Chain state`. Choose *datalog* in **state query** and add Baxter datalog message using "+" button.\n\n![datalog][im10]\n\nNow the IPFS hash of the telemetry and photos is saved in the blockchain. To see the data simply copy the hash and insert it in the search bar with URL: `gateway.ipfs.io/ipfs/<put your hash here>`\n\n\nThat\'s all!\n\n![result1][im12]\n![result2][im13]\n\n[db1]: <https://youtu.be/2AQGFVzkGdg>\n[db2]: <http://wiki.ros.org/melodic/Installation>\n[db3]: <https://dist.ipfs.io/go-ipfs/v0.4.22/go-ipfs_v0.4.22_linux-386.tar.gz>\n[db4]: <https://github.com/airalab/robonomics/releases>\n[db8]: </docs/create-account-in-dapp>\n[im1]: <../images/baxter_demo/empty_world.jpg>\n[im2]: <../images/baxter_demo/baxter_simulation.jpg>\n[im3]: <../images/baxter_demo/robonomics.jpg>\n[db5]: <https://parachain.robonomics.network>\n[im4]: <../images/baxter_demo/local_node.jpg>\n[im7]: <../images/baxter_demo/waiting.jpg>\n[im8]: <../images/baxter_demo/rob_message.jpg>\n[im9]: <../images/baxter_demo/working.jpg>\n[im10]: <../images/baxter_demo/datalog.jpg>\n[im11]: <../images/baxter_demo/ipfs.jpg>\n[im12]: <../images/baxter_demo/result1.jpg>\n[im13]: <../images/baxter_demo/result2.jpg>\n[db6]: </docs/rio-overview>\n[im14]:<../images/baxter_demo/ip_a.png>\n[im15]:<../images/baxter_demo/baxter_sh.jpg>\n'}},{node:{id:"875a30fdb13574ad02073435030cbd9e",title:"Control Baxter robot with robonomics",path:"/docs/es/baxter/",content:'\nExample of how it works:\n\nhttps://youtu.be/AeufQmaNRWk\n\n## Requirements:\n - Ubuntu 18.04\n - ROS Melodic + Gazebo (installation manual [here][db2])  \n - extra packages:\n```sh\nsudo apt-get install ros-melodic-gazebo-ros-control ros-melodic-effort-controllers ros-melodic-joint-state-controller\n```\n- IPFS 0.4.22 (download from [here][db3] and install)\n- pip:\n```sh\nsudo apt install python-pip\n```\n\n- ipfshttpclient:\n```sh\npip install ipfshttpclient\n```\n\n\n - Robonomics node (binary file) (download latest [release][db4] here)\n - Create __Baxter__ and __Employer__ accounts  on **Robonomics Portal**  \n (you can find tutorial ["Create an Account on Robonomics Portal"][db6] here).\n - IPFS browser extension (not necessary)\n\n## 1. Download Baxter model and controller packages\nDownload packages:\n```sh\ncd ~\nmkdir -p robot_ws/src\ncd robot_ws/src\ngit clone https://github.com/nakata5321/Baxter_simulation_controller.git\ncd Baxter_simulation_controller\ngit checkout old_version\ncd ../..\ncatkin build\n```\nDont forget to add source command:\n```sh\necho "source /home/$USER/robot_ws/devel/setup.bash" >> ~/.bashrc\nsource ~/.bashrc\n```\n\n## 2. Create simulation world\nLet\'s start gazebo world and put our baxter in it:\n```sh\nroslaunch gazebo_ros empty_world.launch\n```\n![empty world][im1]\n\nOpen one more window in terminal:\n```sh\nrosrun gazebo_ros spawn_model -file `rospack find baxter_description`/urdf/baxter.urdf -urdf -z 1 -model baxter\n```\nYou can put some models in front of our baxter. It will be more intresting.\n![baxter][im2]\n\n## 3.Manage accounts in DAPP\n\nSince we are testing, let us create a local robonomics network with robonomics binary file. Go to folder with robonomics file and run:\n```sh\n./robonomics --dev --rpc-cors all\n```\n![robonomics][im3]\n\nDon\'t forget to remove `db` folder after every launch:\n```sh\nrm -rf /home/$USER/.local/share/robonomics/chains/dev/db\n```\n\nGo to [https://parachain.robonomics.network][db5] and switch to local node\n![local node][im4]\n\nGo to Accounts and transfer some money to __Baxter__ and __Employer__ accounts.\n\nYou can find The manual "Create an Account on Robonomics Portal" [here.][db6]\n\nAdd Baxter\'s secret key and adress to `configuration.txt` in `robot_ws/src/robot_controller/src/`\n\n## 4.Start simulation\n\nIn new window run:\n```sh\nifps init #you only need to do this once\nipfs daemon\n```\nOpen separate terminal and start *controller package*:\n```sh\nrosrun robot_controller robot_control.py\n```\n![waiting][im7]\n\nReturn to the first terminal, open new window and send command to [**robonomics io**][db7]. This command will turn ON your robot:\n```sh\necho "ON" | ./robonomics io write launch -r <CURIOSITY ADDRESS> -s <EMPLOYER’S KEY>\n```\nWhere `<CURIOSITY ADDRESS>` and `<EMPLOYER’S KEY>` are replaced with previously saved strings accordingly\n\n![rob_message][im8]\n\nYou should see the following:\n\n![working][im9]\n\nwhen the work is over go to the Robonomics Portal to `Developer > Chain state`. Choose *datalog* in **state query** and add Baxter datalog message using "+" button.\n\n![datalog][im10]\n\nNow the IPFS hash of the telemetry and photos is saved in the blockchain. To see the data simply copy the hash and insert it in IPFS Companion:\n\n![ipfs][im11]\n\nClick  __View on Gateway__ and that\'s all!\n\n![result1][im12]\n![result2][im13]\n\n[db2]: <http://wiki.ros.org/melodic/Installation>\n[db3]: <https://dist.ipfs.io/go-ipfs/v0.4.22/go-ipfs_v0.4.22_linux-386.tar.gz>\n[db4]: <https://github.com/airalab/robonomics/releases>\n[im1]: <../images/baxter_demo/empty_world.jpg>\n[im2]: <../images/baxter_demo/baxter_simulation.jpg>\n[im3]: <../images/baxter_demo/robonomics.jpg>\n[db5]: <https://parachain.robonomics.network>\n[im4]: <../images/baxter_demo/local_node.jpg>\n[im7]: <../images/baxter_demo/waiting.jpg>\n[db6]: </docs/create-account-in-dapp>\n[im8]: <../images/baxter_demo/rob_message.jpg>\n[im9]: <../images/baxter_demo/working.jpg>\n[im10]: <../images/baxter_demo/datalog.jpg>\n[im11]: <../images/baxter_demo/ipfs.jpg>\n[im12]: <../images/baxter_demo/result1.jpg>\n[im13]: <../images/baxter_demo/result2.jpg>\n[db7]: </docs/rio-overview>\n'}},{node:{id:"cf303c5554d42be605c5e25884c096ec",title:"AIRA Overview",path:"/docs/es/aira-overview/",content:"\n## Introduction\n\nAIRA stands for \"Autonomous Intelligent Robot Agent\". It implements the standard of economic interaction between human-robot and robot-robot. AIRA makes it possible to connect a variety of different robots under decentralized computer's control (currently supported Ethereum and Polkadot/Substrate).\n\nBasically it is the client for Robonomics Network developed by [Airalab](https://aira.life).\n\nAIRA is NixOS based operating system and officially supports the following architectures: x86, Raspberry Pi 3 B+ and Raspberry Pi 4.\n\nThe most simple way to get familiar with AIRA is to try installing AIRA as a [virtual machine](/docs/aira-installation-on-vb/).\n\nAIRA comes with a few preinstalled and configured services to help you focus on [agent](/docs/glossary#agent) development.\n\nMeanwhile it's highly customizable, but it's recommended to understand [NixOS](http://nixos.org/) and [Nix](https://nixos.org/nix/) language.\n\n## What's included? \n\nThe following services are included in the default distribution:\n\n* [Robonomics communication stack](https://github.com/airalab/robonomics_comm)\n* [IPFS](https://ipfs.io/)\n* OpenSSH\n* [cjdns](https://github.com/cjdelisle/cjdns)\n* [Yggdrasil-go](https://yggdrasil-network.github.io/)\n\nBesides at the first launch AIRA [generates](/docs/aira-installation-on-vb#launch-the-machine) for you new Ethereum address and IPNS identifier.\n\nIt's possible to use AIRA as a virtual machine or install as a main operating system. Also you can install only the services you need.\n"}},{node:{id:"485554d9085b01c42dbeddc124ac7fc9",title:"AIRA Installation",path:"/docs/es/aira-installation/",content:"\n- [**How to launch AIRA on VirtualBox**](/docs/aira-installation-on-vb/)\n\n- **The installation on Raspberry Pi** is as simple as writing an image of AIRA on SD card using `dd` or [Etcher](https://www.balena.io/etcher/), for example.\n\n\n"}},{node:{id:"46c772c3bb327255baf4a520417f6de1",title:"Instalación de AIRA en VirtualBox",path:"/docs/es/aira-installation-on-vb/",content:'\nAIRA significa “Autonomous Intelligent Robot Agent”. Es el cliente de Robonomics Network desarrollado por [Airalab](https://aira.life). Es un sistema operativo basado en [NixOS](https://nixos.org/). Con AIRA puedes convertir cualquier sistema ciberfísico en un agente económico, donde los robots operan como un servicio por los pagos razonables. [Más informacion sobre AIRA aquí]((/docs/aira-overview))\n\nEs posible instalar AIRA en una x86_64 PC. También hay imágenes para Raspberry Pi 3 y 4 compatibles con el equipo.\n\nLa mejor manera de probar AIRA es comenzar desde instalarlo como una máquina virtual en [VirtualBox](https://www.virtualbox.org/).\n\n## Requerimientos\n\n* VirtualBox\n* [Paquete de extensión de VirtualBox](https://www.virtualbox.org/wiki/Downloads#VirtualBox6.1.2OracleVMVirtualBoxExtensionPack)\n* 2Gb de RAM para la máquina\n* 40Gb de espacio libre en disco\n\n## Obtener la Imagen\n\nAIRA tiene canales [estables](https://aira.life/channels/aira-stable/) e [inestables](https://aira.life/channels/aira-unstable/). Para obtener una imagen estable, descargue el archivo con la extensión `.ova`. El enlace para una imagen estable [está aquí](https://releases.aira.life/channels/aira/stable/862-aira-stable/nixos-20.03pre-git-x86_64-linux.ova).\n\nNo olvide comparar la suma de comprobación de la imagen descargada con el hash `SHA-256` de la última columna en [la página de descarga](https://aira.life/channels/aira-stable/). Debe ser igual a la salida del siguiente comando (es un ejemplo, primero verifique el nombre del archivo .ova descargado):\n\n```\nsha256sum nixos-20.03pre-git-x86_64-linux.ova\n```\n\nEs posible que desee ver el video tutorial:\n\nhttps://www.youtube.com/embed/cDcaypYPBhI\n\n## Solución de Problemas\n\nSi tiene VirtualBox recién instalado, debe instalar el pack de [extensión](https://www.virtualbox.org/wiki/Downloads) o deshabilitar el controlador USB 2.0.\n\nAdemás, VirtualBox puede mostrar una advertencia sobre `Display settings`. Considere cambiar el `Graphics Controller` en la configuración de la máquina virtual a `VMSVGA`.\n\n## Importar a VirtualBox\n\nAbra VirtualBox y presione `Ctrl+I` o `File > Import Applicance...`\n\n![Imagen VB de importación AIRA](../images/aira-installation/aira_import_vb_image.jpg "Imagen VB de importación AIRA")\n\nEn este momento, el siguiente paso no es necesario, pero te ayudará a conectarte a la VM a través de SSH fácilmente.\n\nPrimero agregue el adaptador `Host-Only` en el menú de VirtualBox `File > Host Network Manager...` o presionando `Ctrl+H`\n\n![Host Only](../images/aira-installation/host_only_adapter.jpg "Host Only")\n\nLuego vaya a la configuración de la imagen, Red y agregue el segundo adaptador de red.\n\n![Segundo adaptador](../images/aira-installation/add_second_adapter.jpg "Segundo adaptador")\n\nPara obtener más detalles, consulte [la lección](/docs/aira-connecting-via-ssh/) independiente.\n\nOpcionalmente, puede aumentar la cantidad de memoria de video y cambiar `Graphics Controller` a `VMSVGA`.\n\n## Iniciar la Maquina\n\nFinalmente presione `Start` y verá AIRA dándole la bienvenida con la dirección Ethereum generada y el identificador IPFS\n\n![Imagen AIRA lista, pantalla de bienvenida](../images/aira-installation/aira_image_ready.jpg "Imagen AIRA lista, pantalla de bienvenida")\n\nEn la primera inicialización, AIRA genera una nueva dirección Ethereum e identificador IPNS para usted.\n\n'}},{node:{id:"163fa3a4415473e2230c79894343b4ba",title:"Frequently Asked Questions about AIRA",path:"/docs/es/aira-faq/",content:"\n## How to see logs from main services?\n\nIPFS in real time:\n\n    journalctl -u ipfs -f\n\nand Liability::\n\n    journalctl -u liability -f\n\n## How to check the quantity of IPFS peers?\n\n    ipfs pubsub peers \n\n## IPFS can't connect to the daemon, what should I do?\n\nTry to specify `--api` option\n\n    ipfs swarm peers --api=/ip4/127.0.0.1/tcp/5001/\n\n## How to change ethereum address of AIRA?\n\nDelete `keyfile` and `keyfile-psk` in `/var/lib/liability` and restart the service\n\n```\nsystemctl restart liability\n```\n\n## IPFS daemon doesn't start\n\nThe error mostly occurs on single-board computers like Raspberry Pi or LattePanda after unexpected electricity lost.\n\nUsually the file `/var/lib/ipfs/api` is corrupted and one may see error:\n\n```\nError: Failed to parse '/var/lib/ipfs/api' file.\n  error: failed to parse multiaddr \"\": empty multiaddr\nIf you're sure go-ipfs isn't running, you can just delete it.\nOtherwise check:\n  ps aux | grep ipfs\n```\n\nYou can delete `/var/lib/ipfs/api` file and restart the service\n\n"}},{node:{id:"32ee662b61ab1efe0d77a1914c330239",title:"Conexión de Aira a través de SSH",path:"/docs/es/aira-connecting-via-ssh/",content:'\nEs más conveniente trabajar con una máquina virtual a través de una conexión SSH. En esta sección configuraremos VM.\n\n> **Se requiere tener su clave pública ssh en Github. En caso de que no tenga uno, siga [el enlace](https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/)**\n\nA continuación se muestra el video tutorial:\n\nhttps://www.youtube.com/embed/R6waDG5iwm0\n\n## Añadir el Adaptador Host\n\nVaya a `File` -> `Host Network Manager...` o presione `Ctrl+H`\n\n![Administrador de red de VirtualBox](../images/virtualbox_network_manager.png "Administrador de red de VirtualBox")\n\nClick en boton `Create`.\n\n## Añadir el segundo adaptador a la VM\n\nSeleccione la VM importada y haga clic en `Settings`. Vaya a la pestaña `Network` y habilite el segundo adaptador.\n\n![Añadir el segundo adaptador](../images/add_second_adapter_to_vm.png "Añadir el segundo adaptador")\n\n## Keys Autorizadas Pobladas\n\nInicie la VM y ejecute el siguiente comando reemplazando `<username>` con su nombre de usuario de Github:\n\n```\nmkdir .ssh\nchmod 700 .ssh\ncurl -sSL https://github.com/<username>.keys >> .ssh/authorized_keys\n```\n\nDescubra la dirección IP de la máquina virtual ejecutando:\n\n```\nip a\n```\n\nDebe buscar una dirección que comience con `192.168.xx.xx`\n\n## Iniciar Sesion a través de SSH\n\nAhora abra su terminal e inicie sesión a través de SSH como de costumbre usando la dirección del paso anterior:\n\n```\nssh root@192.168.xx.xx\n```\n'}},{node:{id:"844872b5b5b148bd32571e745ad79b49",title:"Basic usage of AIRA",path:"/docs/es/aira-basic-usage/",content:"\nTo get familiar with AIRA, let's see what is under the hood.\n\nOnce you launch the client several ros nodes will already be on the run. Here's a list of robonomics communication stack nodes:\n\n```bash\n$ rosnode list\n/eth/erc20_token\n/eth/eth_node\n/graph/aira_graph\n/liability/executor\n/liability/infochan/eth/signer\n/liability/infochan/ipfs_channel\n/liability/persistence\n/liability/listener\n/rosout\n```\n\n- `/eth/erc20_token`, `/eth/eth_node` - proved services for Ethereum blockchain and ERC20 tokens\n- `/graph/aira_graph` - service node for exploring other AIRA instances\n- `/liability/executor` - gets rosbag file from IPFS and plays it\n- `/liability/infochan/ipfs_channel` - is responsible for offer, demand and result messages. It catches messages from the channel and sends signed messages back\n- `/liability/infochan/eth/signer` - offers services for signing offer, demand and result messages\n- `/liability/listener` - watches for a new liability contracts. When the event is received the node calls executor node\n- `/liability/persistence` - helps to store incoming liabilities and restart them after shutdown\n\nAnd here's a list of robonomics stack topics.\n\n```bash\n$ rostopic list\n/eth/event/approval\n/eth/event/transfer\n/graph/greetings\n/liability/complete\n/liability/finalized\n/liability/incoming\n/liability/infochan/eth/sending/demand\n/liability/infochan/eth/sending/offer\n/liability/infochan/eth/sending/result\n/liability/infochan/eth/signing/demand\n/liability/infochan/eth/signing/offer\n/liability/infochan/eth/signing/result\n/liability/infochan/incoming/demand\n/liability/infochan/incoming/offer\n/liability/infochan/incoming/result\n/liability/persistence/add\n/liability/persistence/del\n/liability/persistence/update_timestamp\n/liability/ready\n/liability/result\n/rosout\n/rosout_agg\n```\n\nThe most important topics for us are:\n\n- `/liability/incoming` - when a new liability is created, this topic publishes Ethereum address of the contract\n- `/liability/result` - this topic is for publishing results. But don't publish a result directly to this topic! Use a service instead\n- `/liability/infochan/incoming/*` - a CPS gets information about offer, demand or result from corresponding topics\n- `/liability/infochan/eth/signing/*` - a CPS sends offer, demand or result messages to corresponding topics\n\nFor the details check out the [API page](/docs/robonomics-liability/).\n\nLet's start with greetings - say hello to AIRA!\n\nYou should just launch a pre-installed package `hello_aira`:\n\n```\n$ rosrun hello_aira hello_aira\n```\n\nWe've launched our agent. It will wait for a demand message. Now it's time to send the message. Go to [dapp](https://airalab.github.io/robonomics_tutorials/) and press Order.\nNow go back to the console and see the result!"}},{node:{id:"a70d1e9fa48be6a0d780b12a09066f26",title:"Agent development examples",path:"/docs/es/agent-development-examples/",content:"\nUseful pieces of code and a few scenarios. All source code is [here](https://github.com/vourhey/robonomics_tutorials).\n\n1. [Broadcast Demand](https://github.com/Vourhey/robonomics_tutorials/tree/master/01_broadcast_demand/)\n2. [Broadcast Offer](https://github.com/Vourhey/robonomics_tutorials/tree/master/02_broadcast_offer/)\n3. [Trader](https://github.com/Vourhey/robonomics_tutorials/tree/master/03_trader/)\n4. [Trader with ACL](https://github.com/Vourhey/robonomics_tutorials/tree/master/04_trader_with_acl/)\n5. [Open Sensor Data](https://github.com/Vourhey/robonomics_tutorials/tree/master/05_open_sensor_data/)\n\n"}},{node:{id:"accf2ce5f73f81bf63e784a00c9dbb89",title:"Lesson 4, Robonomics parachain in practice",path:"/docs/en/wschool2021-robonomics-parachain-in-practice/",content:"import Asciinema from '~/components/Asciinema.vue'\n\nRobonomics parachain is not a general purpose parachain on Polkadot ecosystem. The target of Robonomics\nis building economy of machines, the parachain in this scope of aims helps to integrate Polkadot ecosystem\nwith IoT, Smart Cities and Industry 4.0 concepts.\n\n## Requirements\n\n* Docker, please [install it](https://docs.docker.com/engine/install/).\n* Polkadot-launch, please [install it](https://github.com/paritytech/polkadot-launch#install).\n\n## Launch the relay\n\nThe relay chain is a core of Polkadot, it provides [shared security](https://wiki.polkadot.network/docs/en/learn-security)\nfor all child parachains and implements message passing mechanics for them. Let's launch local instance of Rococo (polkadot testnet)\nrelay chain with two robonomics-based parachains as a childs. I'll use prepared [Docker image tag: \"winter-school-2\"](https://hub.docker.com/layers/robonomics/robonomics/winter-school-2/images/sha256-92f4795262f3ded3e6a153999d2777c4009106a7d37fd29969ebf1c3a262dc85?context=explore) but all source code of examples\navailable in [Robonomics GitHub](https://github.com/airalab/robonomics/tree/master/scripts/polkadot-launch).\n\n<Asciinema vid=\"419Jrg22ziFfMFPZlh2WtiLvg\"/>\n\nIt could take a time, but be partient. As result you should have three chain instances at ports:\n\n* `9944` - local rococo relay chain.\n* `9988` - robonomics parachain with `id=100`\n* `9989` - robonomics parachain with `id=200`\n\nIf you use remote server, you need to create some ssh tunnels on local machine:\n```\nssh -f -N -L 9944:127.0.0.1:9944 root@REMOTE_SERVER_IP\nssh -f -N -L 9988:127.0.0.1:9988 root@REMOTE_SERVER_IP\nssh -f -N -L 9989:127.0.0.1:9989 root@REMOTE_SERVER_IP\n```\nAfter that, you can use `ws://127.0.0.1:9944`, `ws://127.0.0.1:9988`and `ws://127.0.0.1:9989` in https://parachain.robonomics.network/\n\n![relay](https://ipfs.io/ipfs/QmR9Tj86yPkrXQsSwereJwqDxsZgkAdySB16G4SMHrhpBu/upcoming.png)\n\nSome time ago parachains should be registered.\n\n![relay2](https://ipfs.io/ipfs/QmR9Tj86yPkrXQsSwereJwqDxsZgkAdySB16G4SMHrhpBu/parachains.png)\n\nAnd start to produce blocks.\n\n![relay3](https://ipfs.io/ipfs/QmR9Tj86yPkrXQsSwereJwqDxsZgkAdySB16G4SMHrhpBu/parachains2.png)\n\nAs next step let's create HRMP channel to pass messages between parachains. I'll use `sudo` module call on relay chain page.\n\n![hrmp](https://ipfs.io/ipfs/QmR9Tj86yPkrXQsSwereJwqDxsZgkAdySB16G4SMHrhpBu/hrmp.png)\n\nWhen channel created, the XCM calls is available. Let's use `datalogXcm` pallet - a XCM version of `datalog` pallet.\n\n![datalogXcmSend](https://ipfs.io/ipfs/QmR9Tj86yPkrXQsSwereJwqDxsZgkAdySB16G4SMHrhpBu/datalogXcmSend.png)\n\nAs result message on second parachain will call `datalog` pallet and write data on chain.\n\n![datalogXcmRecv](https://ipfs.io/ipfs/QmR9Tj86yPkrXQsSwereJwqDxsZgkAdySB16G4SMHrhpBu/datalogXcmRecv.png)\n\nAs result, this example demonstrate how XCM could be used for cross chain usage of standard robonomics pallets.\n"}},{node:{id:"3728ead98b03926b163404444cb7218d",title:"Lesson 3, Robonomics IO in practice",path:"/docs/en/wschool2021-robonomics-io-in-practice/",content:'import Asciinema from \'~/components/Asciinema.vue\'\n\n## Requirements\n\n* the Docker is required, please [install](https://docs.docker.com/engine/install/) it first.\n* the [Nova SDS011](https://aqicn.org/sensor/sds011) sensor is *optional*.\n\n### SDS011 check (optional)\n\nIf you have connected SDS011 sensor then please check that it presented in `/dev` and have correct access rights.\n\n<Asciinema vid="WCFcx8C6M8e52UKDNei1xZloU"/>\n\n## Quick start\n\nWhen docker is installed let\'s launch robonomics docker image from [Official repository](https://hub.docker.com/r/robonomics/robonomics). I\'ll use `winter-school` tag during this lesson.\n\n<Asciinema vid="wM43jozIVfcRmt52ENrJ6yPlH"/>\n\nWhen docker image is ready let\'s try to read a data using `robonomics io` command (optiona if you have SDS011 device).\n\n<Asciinema vid="iztt22tKGaV8wq3cMXY1oUEYv"/>\n\nIf you have no SDS011 sensor then feel free to use virtual SDS011 sensor available in the same docker container via `vsds011.sh`. And everywhere in folloding command please use it as transparent replacement for physical sensor.\n\n<Asciinema vid="GCkSiJBA1DgpLAAHiMhIOSpgG"/>\n\nThe Robonomics IO subsystem have two kind of commands:\n\n* `read` - get data from device that support read access;\n* `write` - write data into device that support write access.\n\nSome devices support them both, in that case devices presented in both command arguments.\n\n> For example, virtual device `ipfs` supports `read` data from IPFS by hash as same as `write` data into IPFS.\n\nFull list of supported devices is possible to get running `robonomics io read` or `robonomics io write` without arguments.\n\n## IPFS access\n\nOn next step runned IPFS daemon is required. For this purpose let\'s run init IPFS and run daemon on dedicated\nterminal tab.\n\n<Asciinema vid="ir6ziXSBUDrRltTmNxg7sdXVY"/>\n\nWhen daemon launched is possible to connect docker image in separate tab and use `robonomics io` for writing and reading a data.\n\n<Asciinema vid="ZtwcmpB9Lhum2Sc221QmNwHG4"/>\n\nThe output forwarding is also works here, that means it\'s possible to forward SDS011 sensor data into IPFS using `|` (pipe) symbol in console. Let\'s try to do it.\n\n<Asciinema vid="XS0QESWG7f8ELsQe1bGQllb9O"/>\n\nWhere JSON data from SDS011 forwarded as input for IPFS writer and result is published on stdout.\n\nThis approach permits engineer extrimely quickly make a simple program just combine a primitive readers and writers from `robonomics io` tools.\n\n```bash\nrobonomics io read sds011 | gz | robonomics io write pubsub my-sensor-data\n```\n\n## Robonomics Datalog\n\n> The target of Robonomics [Datalog](https://crates.robonomics.network/robonomics_protocol/datalog/index.html) is data blockchainization. This pallet provides function to store custom data on blockchain to make it immutable, impossible to change in future.\n\nFor the final part of this lesson runned robonomics node is required. Development mode is preffered because of quick block time and already distributed balances on preset accounts. Let\'s launch it on separate terminal tab in the same container.\n\n<Asciinema vid="QnN9l0sdaZZOyK9ah0DntvCXt"/>\n\nThen private seed also required as argument for `datalog` device. This seed is used to sign transaction and presents account as a sender. Let\'s generate it using embedded `robonomics key` command.\n\n<Asciinema vid="4Cdfl9F0GgjNWv1c1ZcTBBktF"/>\n\nSave generated address and seed on safe place for use it later.\n\nCurrently address balance is zero and the network don\'t permits to send transactions from this address. To fix it let\'s transfer a bit of tokens from `Alice` account. I\'ll use Robonomics Portal on https://parachain.robonomics.network connected to local node with address `ws://127.0.0.1:9944`.\n\n![portal transfer](https://ipfs.io/ipfs/QmbpArfthyor5wFWRexgPAyjK7GaFduasc1eoReaf9TpJg/tran.png)\n\nAnd then `datalog` device could be used for saving any data on blockchain. The key `-s` is used to set secret seed of account. Account should have non-zero balance to send transactions.\n\n<Asciinema vid="FzERH9TmFB8oRuas8ZU202Pv8"/>\n\nIf every thing is correct the you should see `Datalog` event on `Explorer` page of Robonomics portal.\n\n![portal datalog](https://ipfs.io/ipfs/QmbpArfthyor5wFWRexgPAyjK7GaFduasc1eoReaf9TpJg/datalog.png)\n\nThe final step is a bit complex but it\'s good to try use all knowledge of this lesson. Let\'s make a simple program\nthat collects data from SDS011 sensor (or file), pack it into IPFS and then send `datalog` transaction to save hash on blockchain.\n\n```\nSDS011 -> IPFS -> Blockchain\n```\n\nIt\'s easy to implement using Robonomics IO, let\'s do that.\n\n<Asciinema vid="MTpiawGo8DKEn081OozbYb5mU"/>\n\nIf everything well the `Datalog` event with IPFS hash should be presented.\n\n![portal datalog complex](https://ipfs.io/ipfs/QmbpArfthyor5wFWRexgPAyjK7GaFduasc1eoReaf9TpJg/datalog_complex.png)'}},{node:{id:"c2660bc3293b4f9225a0cea6e66b6d5c",title:"Lesson 2, Robonomics GitHub overview",path:"/docs/en/wschool2021-robonomics-github-overview/",content:"\n## Step 1: AIRA Installation on VirtualBox\n\nhttps://youtu.be/ISKilRfY3Ow\n\n## Step 2: Connecting Aira via SSH\n\nhttps://youtu.be/W0rOcRA2sEc\n\n## Step 3: Interact with AIRA\n\nhttps://youtu.be/fhRTF2mddfU"}},{node:{id:"07d29afc221735d0307cc4254dfd0b86",title:"Robonomics Winter School 2021 introduction",path:"/docs/en/wschool2021-intro/",content:"\nRobonomics Winter School 2021 is held from 10 to 24 February **online**. It's **free**.\n\nWe are publishing **lessons** online in different ways: text here in Wiki, video on our [YouTube channel](https://www.youtube.com/channel/UCrSiho1uB-1n6F8cZpCLhjQ), announce in [Twitter account](https://twitter.com/AIRA_Robonomics). Please, keep in mind, that video lessons and text lessons are not the same. For the start we plan to publish two language versions: English and Russian. \n\nJoin us, take your steps through the lessons, **discuss and ask questions** in [Discord](https://discord.gg/5UWNGNaAUf).\n\n## Watch opening ceremony\n\nhttps://youtu.be/kQaSwNYHJQ8\n\n## Basic information\n\nTake a look at [page about school](https://robonomics.network/blog/winter-robonomics-school/) on our website. We are collecting there all basic information: shedule, infopartners, links.\n\n## Links, links, links\n\nLets repeat what links do we have for following Robonomics Winter School 2021:\n\n- [Summary on website](https://robonomics.network/blog/winter-robonomics-school/)\n- Wiki for text lessons, YOU ARE HERE 🤓\n- [Video lessons](https://www.youtube.com/channel/UCrSiho1uB-1n6F8cZpCLhjQ)\n- [Fast announce on Twitter](https://twitter.com/AIRA_Robonomics)\n- [Questions, Discussions, Quizes in Discord](https://discord.gg/5UWNGNaAUf)\n\n**Lets start learn Robonomics!**"}},{node:{id:"3849d5eb0258718426e2447e80611911",title:"Lesson 5, Connectivity",path:"/docs/en/wschool2021-connectivity-service/",content:'\n## IoT as a Multiple Pie\n\n* Device Software\n    * FreeRTOS\n    * ESP/Arduino\n    * Single-board computers (RPi, LattePanda etc)\n* Connectivity\n    * IoT Hub\n    * IoT Manager\n* Analytics Services\n    * AWS\n    * Google Cloud IoT Core\n    * ThingsBoard\n\nAs a rule, most are not interested in sensors and servers, but data analytics.\nTo get it, you need to decide which device to use, how to work with it and where to connect\n\n## Device Software\n\nConsider the example of a home weather station. It is necessary to collect data on air pollution (SDS011), temperature and humidity (BME). The ESP8266 microcontroller can handle this task.\n\nRequirements:\n\n* Correctly read data from sensors\n* Have a unique identifier\n* Transfer data to a known server\n* Provide digital signature of data (optional)\n\nYou can find the current firmware [here](https://github.com/LoSk-p/sensors-software/tree/366b19bf447a5fc19220ef89eab0f2440f8db1c2)\n\n## What is Connectivity? \n\nIn the IoT world, connectivity refers to the connection of various IoT devices to the Internet to send data and / or control the device.\n\nWell-known architectural solutions can be roughly divided into 3 groups:\n\n* Fully decentralized. For example, devices are connected by a mesh network. Not suitable for wide area networks due to high hardware requirements\n* Centralized. For example, AWS. Provides a single entry point and ease of connection, but there is a high risk of failure in case of server problems\n* Hybrid. For example, [Robonomics Connectivity](https://github.com/airalab/sensors-connectivity). Provides an address for devices on a "local" network and publishes data to a distributed IPFS message channel\n\n## Comparison of AWS and Robonomics Connectivity\n\n| Management services \t| AWS                               \t|               Robonomics              \t|\n|---------------------\t|-----------------------------------\t|---------------------------------------\t|\n| Transaction type    \t| Technical                         \t| Technical and economic                \t|\n| Security            \t| IT-company cloud control          \t| Polkadot and Ethereum                 \t|\n| Protocol            \t| HTTPS, MQTT                       \t| IPFS, Robonomics                      \t|\n| Ecosystem           \t| Private                           \t| Shared                                \t|\n| Access to DeFi      \t| No                                \t| Yes                                   \t|\n| Costs               \t| Pushing data - $1-2 a sensor      \t| Pushing data - $0                     \t|\n|                     \t| Shadow         - from $10 a month \t| Digital Twin    - $0,01 a transaction \t|\n\n## Installing Connectivity on Aira\n\nhttps://www.youtube.com/watch?v=JbBNMHAzJKM\n\n### Requirements\n\n* [VirtualBox 6.1](https://www.virtualbox.org/wiki/Downloads) and above\n* [Aira OS ova image](https://static.aira.life/ova/airaos-21.03_robonomics-winter-school.ova)\n\nImport Aira image in VirtualBox as described [here](/docs/aira-installation-on-vb/)\n\nSet up a connection over [SSH](/docs/aira-connecting-via-ssh/)\n\nWhen everything is set and you successfully log in via SSH, let\'s clone the main package and build it \n\n```\ngit clone https://github.com/airalab/sensors-connectivity\ncd sensors-connectivity\nnix build -f release.nix\n```\n\nNow let\'s create a copy of the default configuration file for later usage. \nTo learn about all the options check [this article](/docs/configuration-options-description/) out.\nThen launch the package with `roslaunch`\n\n```\ncp config/default.json config/my.json\nsource result/setup.zsh\nroslaunch sensors_connectivity agent.launch config:=$PWD/config/my.json\n```\n\n## Connect Sensor to Connectivity\n\nhttps://www.youtube.com/watch?v=yxqxBk-6bpI\n\n### Requirements\n\n* [Nova SDS011](https://aqicn.org/sensor/sds011) sensor \n* [Yarn Packet Manager](https://yarnpkg.com/getting-started/install)\n\nNow let\'s connect a real sensor, forward USB port to the virtual machine, set up a map and look at our own measurements\n\nFirst, stop the Aira OS if it was running and add a corresponding USB device\n\n![VB USB Forwarding](../images/vb_forward_usb.jpg)\n\nStart the VM, connect via SSH and set `comstation/port` option according to your USB device in the VM. Also enable `comstation` and set your latitude and longitude. In the end `config/my.json` should look like this:\n\n```\n{\n   "general":{\n      "publish_interval":30\n   },\n   "comstation":{\n      "enable":true,\n      "port":"/dev/ttyUSB0",\n      "work_period":0,\n      "geo":"59.944917,30.294558",\n      "public_key":""\n   },\n   "httpstation":{\n      "enable":false,\n      "port":8001\n   },\n   "mqttstation": {\n      "enable": false,\n      "host": "connectivity.robonomics.network",\n      "port": 1883\n   },\n   "luftdaten":{\n      "enable":false\n   },\n   "robonomics":{\n      "enable":true,\n      "ipfs_provider":"/ip4/127.0.0.1/tcp/5001/http",\n      "ipfs_topic":"airalab.lighthouse.5.robonomics.eth"\n   },\n   "datalog":{\n      "enable":false,\n      "path":"",\n      "suri":"",\n      "remote":"wss://substrate.ipci.io",\n      "dump_interval":3600,\n      "temporal_username":"",\n      "temporal_password":""\n   },\n   "dev":{\n      "sentry":""\n   }\n}\n```\n\n> If you don\'t have a real sensor, you can use `sensors-connectivity/utils/virtual-sensor.py` script to emulate one\n> \n> Enable `HTTPStation` and disable `COMStation` by changing the configuration file as:\n> ```\n> {\n>    "general":{\n>       "publish_interval":30\n>    },\n>    "comstation":{\n>       "enable":false,\n>       "port":"/dev/ttyUSB0",\n>       "work_period":0,\n>       "geo":"59.944917,30.294558",\n>       "public_key":""\n>    },\n>    "httpstation":{\n>       "enable":true,\n>       "port":8001\n>    },\n>    ...\n> }\n> ```\n>\n> and launching `utils/virtual-sensor.py` in a dedicated terminal in the VM\n\nSave the file and launch connectivity from `sensors-connectivity` folder:\n\n```\nsource result/setup.zsh\nroslaunch sensors_connectivity agent.launch config:=$PWD/config/my.json\n```\n\nYou should see first measurements in the console output\n\nLook for your IPFS ID in the VM. It appears right after booting the image or via `ipfs id` command. We will need it later.\n\nNow let\'s set up our own instance of the map. On your laptop (not in the VM) clone [this](https://github.com/airalab/sensors.robonomics.network) repository and build the app:\n\n```\ngit clone https://github.com/airalab/sensors.robonomics.network\ncd sensors.robonomics.network\nyarn install\n```\n\nEdit `src/agents.json` file and put your IPFS ID. For example:\n\n```\n[\n  "12D3KooWSCFAD3Lpew1HijniE6oFTuo4jsMwHzF87wNnXkpCRYWn"\n]\n```\n\nLaunch the map:\n\n```\nyarn serve\n```\n\nGo to [http://localhost:8080/](http://localhost:8080/) or the address yarn gave you and look for the sensor.\n\n## Practice\n\n### Trajectory 1. Flash a sensor ESP + SDS011\n\nRequirements:\n\n* ESP8266\n* At least one of sensors SDS011, BME280, HTU21D\n\nUse the [instruction](https://wiki.robonomics.network/docs/connect-sensor-to-robonomics/) to connect a sensor to Robonomics Connectivity. \n\nCheck that your sensor appears on our [map](https://sensors.robonomics.network/#/).\n\n### Trajectory 2. Launch Connectivity\n\nRequirements:\n\n* ROS\n* Python\n* Nix (optional)\n\nBuild and launch [sensors-connectivity](https://github.com/airalab/sensors-connectivity#get-a-package-and-build)\n\n> How it build, install [here](https://wiki.robonomics.network/docs/iot-sensors-connectivity/) and configure [here](https://wiki.robonomics.network/docs/configuration-options-description/)\n\nGeneral scheme of the package:\n\n```\n    station1 \\                        / feeder1\n    station2 -  sensors-connectivity  - feeder2\n    station3 /                        \\ feeder3\n```\n\nThe choice is proposed to implement either a new station, for example, a random number generator, or a new feeder, for example, displaying a string on the screen.\n\nInterface `IStation` [here](https://github.com/airalab/sensors-connectivity/blob/master/src/stations/istation.py#L73).\n\nInterface `IFeeder` [here](https://github.com/airalab/sensors-connectivity/blob/master/src/feeders/ifeeder.py#L5)\n\n'}},{node:{id:"d5fe1ca3f70b5407d1ed7b384a5b99ca",title:"Lesson 1, Connect robotics to user app",path:"/docs/en/wschool2021-connect-robotics-to-user-app/",content:"\nhttps://youtu.be/NOQxyojvaao\n\n- [Reference tutorial on Wiki](https://wiki.robonomics.network/docs/get-weather-on-fuji-mountain/)\n- [Dapp](https://dapp.robonomics.network/#/)"}},{node:{id:"16ae56d2ed3604ed41b92ecb8330e2dc",title:"Lesson 6.2, Build IoT Dapps For End Users",path:"/docs/en/wschool2021-build-dapp-interface/",content:'\n![Building User Interface for Decentralized Applications, on top of Robonomics and Polkadot](../images/build-dapp-interface/sum.gif "Building User Interface for Decentralized Applications, on top of Robonomics and Polkadot")\n\n## Introduction\n\nThis tutorial continues the previous lesson, where you have already built simple application and were focused on connecting an account to a node, sending transactions and other vital functions of the dapp. Now we will **build user-friendly interface** for this application.\n\n## Prerequisites\n\nThis tutorial is designed for people who are familiar with **HTML, CSS, JavaScript** a bit and want to learn how to apply these skills for decentralized applications.\n\nFor building your dapp\'s interface you can choose any JavaScript framework which is comfortable for you or even try to build interface without any framework. In Robonomics 2021 we use [Vue.js](https://vuejs.org) as it is quite scalable and easy to use.\n\n## Set up for this tutorial\n\nIf you start with this step and prefer to **learn by doing**, please, follow this to-do list to launch the resulting dapp from the previous lesson:\n\n1. Download a local Robonomics node from [releases page](https://github.com/airalab/robonomics/releases/) that fits your OS. If you do not find your system in the latest release, please, find the most recent version in the previous releases.\n\n2. Launch the Robononomics node in the Developer mode by typing `./robonomics --dev` in your terminal.\n\n3. Download the Polkadot Extension for Chrome or Firefox [here](https://polkadot.js.org/extension/)\n\n4. Clone [this repository](https://github.com/vol4tim/example-robonomics-dapp/).\n\n5. Install [Yarn](https://yarnpkg.com).\n\n6. Install [@vue/cli](https://cli.vuejs.org/guide/installation.html)\n\n7. Start developing dapp with `yarn serve` command in your terminal.\n\n\n**You should get this screen in your browser:**\n\n![Dapp Start](../images/build-dapp-interface/dapp-start.png "Dapp Start")\n\n\n<details>\n\n  <summary>Some additional tips for launching</summary>\n\n  - Make sure your **node is running**:\n    ![Example of running a Robonomics node](../images/build-dapp-interface/robonomics-node-launch.png "Example of running Robonomics node")\n\n  - In **macOS** you may need to change the **access permissions** `chmod +x robonomics`\n\n  - Make sure you allowed **access for Polkadot Extension**:\n    ![Polkadot Extension giving access](../images/build-dapp-interface/polkadot-permission.png "Polkadot Extension giving access")\n\n  - If you have errors in log of the running node and dapp is not loading correctly, please, try to delete data base of dev chain: `sudo rm -rf <YOUR LOCAL PATH>/robonomics/chains/dev/db/` and restart the node. If it does not help, restart your machine.\n\n</details>\n\n## Inspecting the code\n\nLet\'s inspect the structure of the dapp to clear up what and where we can fix in order to change UI.\n\n```\n.\n├── public/\n│   ├── favicon.ico           # Icon for your dapp\n│   └── index.html            # The template file (injects icons links, JavaScript and CSS files for the app)\n├── src/\n│   ├── assets/               # Folder for images and global styles\n│   ├── components/           # Folder with components\n│   │   ├── Datalog.vue       # Tab \'Datalog\' in dapp\n│   │   ├── Demo.vue          # Tab \'Demo\' in dapp\n│   │   ├── Launch.vue        # Tab \'Launch\' in dapp\n│   ├── utils/                # Folder with important for app js functions (we will touch api.js in this tutorial)\n│   ├── App.vue               # The root of our app, contains HTML, CSS, JS for the whole page. In fact it is Vue Component also\n│   ├── main.js               # The app’s entry file, we will import here global styles\n├── ...                       # There are config files and dependencies files, that we will not change mannually\n├── README.md                 # You can write here any instructions for your dapp\n\n```\n\n> **The code of this tutorial is in this [repository](https://github.com/positivecrash/wscool21-ui-dapp)**\n\n## CSS-in-JS VS. Global stylesheets\n\nIn this tutorial I show how to change the interface of a small dapp from scratch without any stable library of UI components. So I will import and create not only different Vue components, but also write my own styles.\n\nIf your application is big or your project has the whole bunch of dapps, in future you\'d better look for building library of components specifically for your project to make UI more organized and efficient ([for example, here is a tool for organizing components](https://storybook.js.org)). Or if you are okay with standart interface themes, you can use any UI Libraries of third party ([for example](https://vuetifyjs.com/)).\n\n## First import or where to start\n\nI don\'t have any specific design for this dapp, but I have [Brandbook](https://static.robonomics.network/assets/Robonomics-Visual-Identity.pdf) and [quit well-established](https://robonomics.network) typography, fonts, button styles etc. So for the start I will import the following css files globally:\n\n```\n...\n├── src/\n│   ├── assets/\n│   │   ├── styles/\n│   │   │   ├── reset.css         # The goal is to reduce browser inconsistencies\n│   │   │   ├── variables.css     # Contains specific values to be reused such as colors, font-names, space values etc.\n│   │   │   ├── typography.css    # Global typography for the whole dapp\n│   │   │   ├── animation.css     # Keyframe animations used throughout the dapp\n...\n\n```\n\nThe content of any of these files you can write in App.vue instead, if it fits your perception better. But I recommend to import some CSS files globally for this example to keep App.vue a little bit more clear.\n\nImport these CSS files into your app by editing **main.js** file:\n\n![Import global CSS in Vue app](../images/build-dapp-interface/import-css-vue-1.png "Import global CSS in Vue app")\n\n```JS\nimport \'./assets/styles/reset.css\'\nimport \'./assets/styles/variables.css\'\nimport \'./assets/styles/typography.css\'\nimport \'./assets/styles/animation.css\'\n```\n\n**Check if fonts have been changed in the dapp:**\n\n![Dapp Interface changing step 1](../images/build-dapp-interface/dapp-1.png "Dapp Interface changing step 1")\n\n\n## Change layout and prettify the title\n\nLet\'s change layout of the application. As I mentioned earlier, you can write your styles directly in App.vue, but for this example I prefer to separate this process.\n\n- Comment or delete styles from tag `<style>` in **App.vue**\n\n- Create css file **app.css** in styles folder for this application and import it into **main.js**\n\n```JS\nimport \'./assets/styles/app.css\'\n```\n\n<details>\n\n<summary>Write in app.css first basic styles for the app:</summary>\n\n```css\n#app {\n  display: grid;\n  grid-template-rows: auto 1fr;\n  align-items: stretch;\n\n  text-align: center;\n}\n\nbody {\n  background-color: var(--color-gray-light);\n}\n```\n\n</details>\n\n\n<details>\n\n<summary>Change the title of the app [App.vue]</summary>\n\n```html\n<div class="top">\n    <h1>dApp Robonomics Demo</h1>\n    <i>Winter School 2021</i>\n    <img class="label" alt="" src="./assets/images/robonomics-winter-school-2021-logo.png"/>\n</div>\n```\n\n</details>\n\n\n\n<details>\n\n<summary>Write styles for the title [app.css]</summary>\n\n```css\n.top {\n  position: relative;\n  padding-top: var(--space);\n  padding-bottom: calc(var(--space)*2);\n\n  border-bottom: 2px solid var(--color-dark);\n  background-color: var(--color-light);\n}\n\n.top h1 {\n  font-size: 1.8rem;\n}\n\n.top i {\n  display: block;\n}\n\n.top .loader-label {\n  display: block;\n  margin: calc(var(--space)/3) auto;\n  max-width: 150px;\n\n  visibility: hidden;\n  opacity: 0;\n  animation: 0.5s FadeIn 0.3s ease forwards, 0.5s ScaleDown 0.1s ease forwards;\n}\n\n.top .label {\n  position: absolute;\n  width: 100px;\n  bottom: -50px;\n  left: calc(50% - 50px);\n  display: block;\n\n  transform: translateY(1rem);\n  visibility: hidden;\n  opacity: 0;\n  animation: 0.7s FadeIn 0.5s ease forwards, 1s ScaleUp 0.5s ease forwards;\n}\n```\n\n</details>\n\n- Place a file with the logo of the Robonomics winter school 2021 in the folder **./src/assets/images**\n\n**You will get the following screen:**\n![Dapp Interface changing step 2](../images/build-dapp-interface/dapp-2.png "Dapp Interface changing step 2")\n\n## Define styles according to the dapp\'s data\n\nNow I will wrap the app\'s content in `<div>` element. Also I will need different styles for different states of the dapp (loaded or not loaded).\n\n- Open the **App.vue** and write a wrapping element:\n```html\n<div class="content">\n  \x3c!--here is everything going after the title--\x3e\n</div>\n```\n- Find the variable `load`, it has already been defined in `<script>`.\n- Pass an object to `v-bind:class` to dynamically toggle classes (I use shortened version `:class`):\n```html\n<div class="content" :class="{ load: load }">\n  \x3c!--here is everything going after the title--\x3e\n</div>\n```\nThat\'s how you can easily toggle styles in your app according to the data you get. You will see the usage of this class below.\n\n## Define views according to the dapp\'s data\n\nLet\'s change the loader for the app.\n- For this purpose I will import my component from another Robonomics project \n\n<details>\n\n<summary>./src/components/AnimatedRobonomicsLogo.vue</summary>\n\n```HTML\n<template>\n  <div class="logo-animated" :style="{transform: \'scale(\'+scale+\')\'}">\n      <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="196.9px" height="170.3px" viewBox="0 0 196.9 170.3" style="enable-background:new 0 0 196.9 170.3;" xml:space="preserve">\n\t\t<g transform="translate(2530 155)">\n            <path class="line" d="M-2523.4,7.9l184.2,0.5l-91.7-158.1L-2523.4,7.9z"/>\n\n            <circle class="dot" cx="-2339.7" cy="8.7" r="6.6"/>\n            <circle class="dot" cx="-2523.4" cy="8.2" r="6.6"/>\n            <circle class="dot" cx="-2430.8" cy="-148.4" r="6.6"/>\n            \n            <path class="triangle-1" d="M-2477.3-18.3l92.1,0.3l-45.8-79L-2477.3-18.3z"/>\n            <path class="triangle-2" d="M-2431.2-18.1l46,0.1l-45.8-79L-2431.2-18.1z"/>\n            <path class="triangle-3" d="M-2477.3-18.3l92.1,0.3l-46-20.3L-2477.3-18.3z"/>\n          </g>\n\t</svg>\n  </div>\n</template>\n\n<script>\n\nexport default {\n\n  props: {\n    scale: {\n      type: String,\n      default: \'1\'\n    },\n  },\n\n};\n<\/script>\n\n<style scoped>\n    /*\n    Global styles required:\n    FadeIn - keyframe animation from animation: .css\n    all --color- variables from variables.css\n    */\n\n    .logo-animated {\n        transform-origin: 0 0;\n    }\n\n    .logo-animated .dot {\n        fill: var(--color-blue);\n        visibility: hidden;\n        opacity: 0;\n        animation: 1s FadeIn 0.3s ease forwards;\n    }\n\n    .logo-animated .line {\n        fill: transparent;\n        stroke: var(--color-blue);\n        stroke-miterlimit:10;\n        stroke-dasharray: 700;\n        stroke-dashoffset: 700;\n        animation: 1s DrawSvgPath 0.5s ease-in-out forwards; \n    }\n\n    .logo-animated .triangle-1 {\n        fill: var(--color-blue);\n        visibility: hidden;\n        opacity: 0;\n        animation: 0.5s FadeIn 0.3s ease forwards, 5s logo-triangle-1 0.1s linear infinite;\n    }\n\n    .triangle-2 {\n        fill: var(--color-violet-light);\n        visibility: hidden;\n        opacity: 0;\n        animation: 0.5s FadeIn 0.3s ease forwards, 5s logo-triangle-2 0.1s linear infinite;\n    }\n\n    .triangle-3 {\n        fill: var(--color-violet-mid);\n        visibility: hidden;\n        opacity: 0;\n        animation: 0.5s FadeIn 0.3s ease forwards, 5s logo-triangle-3 0.1s linear infinite;\n    }\n\n\n    @keyframes DrawSvgPath\n        {\n        to {\n            stroke-dashoffset: 0;\n        }\n        }\n\n    @keyframes logo-triangle-1\n    {\n        0% { fill: var(--color-blue); }\n        25% { fill: var(--color-blue); }\n        50% { fill: var(--color-blue); }\n        75% { fill: var(--color-violet-light); }\n        100% { fill: var(--color-blue); }\n    }\n\n    @keyframes logo-triangle-2\n    {\n        0% { fill: var(--color-violet-light); }\n        25% { fill: #E0BDED; }\n        50% { fill: var(--color-blue); }\n        75% { fill: var(--color-blue); }\n        100% { fill: var(--color-violet-light); }\n    }\n\n    @keyframes logo-triangle-3\n    {\n        0% { fill: var(--color-violet-mid); }\n        25% { fill: var(--color-violet-light); }\n        50% { fill: var(--color-violet-light); }\n        75% { fill: var(--color-violet-dark); }\n        100% { fill: var(--color-violet-mid); }\n    }\n</style>\n```\n\n</details>\n\n- Register this component in **App.vue**\n```JS\nexport default {\n  components: {\n    Loader: () => import("./components/AnimatedRobonomicsLogo")\n  }\n}\n```\n- Insert it with conditional Vue directive `v-if`, using the already known variable `load`:\n```HTML\n<div class="content" :class="{ load: load }">\n  <Loader v-if="load" />\n  <template v-else>\n    \x3c!-- here will be main content of loaded dapp --\x3e\n  </template>\n</div>\n```\n- Watch the result in browser. It has some issues that we will fix now:\n\n1. Loader pops up to the title (it should be in the center). Let\'s insert these lines to **app.css**:\n```css\nbody, html, #app {\n  height: 100%;\n  position: relative;\n}\n```\n2. If your connection goes too fast, you will see just blinking loader for a moment. It may confuse a lot. Let\'s set a timeout for the app\'s responce. To do that open **api.js** and find in the function `initAccount` this code:\n```JS\nconst timeout = new Promise(resolve => {\n  setTimeout(resolve, 300);\n});\n```\nI set `1700` instead of `300` and check the result:\n\n![Dapp Interface changing step 3](../images/build-dapp-interface/dapp-3.gif "Dapp Interface changing step 3")\n\n\n## Using reusable components\n\nYou have already watched how to register and use a component in the previous section about Loader, but now I want to focus on it more carefully.\n\nLet\'s change the Account section. Here I will use self-written components (box, button, icon) and the third party\'s one ([from Vue Polkadot Library](https://vue-polkadot.js.org/vue-ui/vue-identicon/#vue-polkadot-vue-identicon )).\n\n### Adding the box\n\n<details>\n\n<summary>Create Box component in ./src/components/Box.vue file </summary>\n\n```HTML\n<template>\n    <section class="box" :class="classList">\n        <slot />\n    </section>\n</template>\n\n<script>\n\nexport default {\n\n  props: {\n    classList: {\n      type: String\n    },\n  },\n\n};\n<\/script>\n\n<style>\n    /*\n    Global styles required for css variables from variables.css\n    */\n\n    .box {\n        background-color: var(--color-light);\n        border: 1px solid var(--color-dark);\n        padding: calc(var(--space)*0.5) var(--space);\n        box-shadow: 2px 2px 0 var(--color-dark);\n        margin-bottom: calc(var(--space)*1.5);\n    }\n</style>\n```\n</details>\n\nNow we can use it many times throught out the dapp. Let\'s see this on the Account section example:\n\n- Register component (**App.vue**):\n\n```JS\nexport default {\n  components: {\n    Box: () => import("./components/Box")\n  }\n}\n```\n\n- Use it for the Account section with an additional class passed with prop `classList`:\n\n```HTML\n<Box :classList="\'account\'">\n  Account: <b>{{ account }}</b> {{ balance }} |\n  <button @click="faucet">\n    faucet\n  </button>\n</Box>\n```\n\n**Check the result:**\n![Dapp Interface changing step 4](../images/build-dapp-interface/dapp-4.png "Dapp Interface changing step 4")\n\n### Adding the button\n\nYou may even not notice the button in the box that we have added. Let\'s fix it and add a component for buttons as it is not the only button in the app.\n\n<details>\n\n<summary>Create Button component in ./src/components/Button.vue file </summary>\n\n```HTML\n<template>\n  <button type="button" :class="classList" @click="onClick" :disabled="disabled" class="inline-block">\n    {{ label }}\n  </button>\n</template>\n\n<script>\n\nexport default {\n\n  components: {\n    Icon: () => import("./Icon")\n  },\n\n  props: {\n    label: {\n      type: String,\n    },\n    type: {\n      type: String,\n      default: \'primary\',\n      validator: function (value) {\n        return [\'primary\', \'secondary\'].indexOf(value) !== -1;\n      }\n    },\n    disabled: {\n      type: Boolean,\n      default: false,\n    },\n    size: {\n      type: String,\n      default: \'medium\',\n      validator: function (value) {\n        return [\'small\', \'medium\', \'large\'].indexOf(value) !== -1;\n      }\n    }\n  },\n\n  computed: {\n    classList() {\n      return {\n        \'button\': true,\n        [`${this.type}`]: true,\n        [`button__${this.size}`]: true,\n      };\n    },\n  },\n\n  methods: {\n    onClick() {\n      this.$emit(\'onClick\');\n    },\n  },\n\n};\n<\/script>\n\n<style>\n    /*\n    Global styles required for css variables from variables.css\n    */\n\n    .button {\n        appearance: none;\n        -webkit-appearance: none;\n        outline: 0;\n        border: 0;\n\n        transition: 0.1s all linear;\n\n        padding: .15rem 0.6rem;\n        border-width: 1px;\n        border-style: solid;\n        border-radius: .25rem;\n  \n        cursor: pointer;\n\n        font-family: var(--font-family);\n        font-size: calc(var(--font-size)*0.9);\n        line-height: 1;\n        font-weight: 500;\n\n        text-transform: uppercase;\n        letter-spacing: 1px;\n    }   \n\n    .button:not([disabled]):hover {\n    filter: saturate(1.5);\n    }\n\n    .button[disabled] {\n        cursor: default;\n        opacity: 0.6;\n    }\n\n    button.primary {\n        border-color: var(--color-green);\n        background-color: var(--color-green);\n        color: var(--color-light);\n    }\n\n    button.secondary {\n        border-color: var(--color-blue);\n        color: var(--color-blue);\n    }\n\n    button.secondary:not([disabled]):hover {\n        background-color: var(--color-blue);\n        color: var(--color-light);\n    }\n\n    .button__small {\n        font-size: .85rem;\n        padding: .1rem 0.45rem;\n    }\n\n    .button__large {\n        font-size: 1.2rem;\n        padding: .5rem 1.7rem;\n    }\n\n</style>\n```\n</details>\n\n\n- Register the component (**App.vue**):\n\n```JS\nexport default {\n  components: {\n    Button: () => import("./components/Button")\n  }\n}\n```\n\n- Use it for the \'Faucet\' button with props defined in the \'Button\' component\n\n```HTML\n<Box :classList="\'account\'">\n  Account: <b>{{ account }}</b> {{ balance }}\n  <Button label="Faucet" size="large" @onClick="faucet" />\n</Box>\n```\n\n**We get this view:**\n![Dapp Interface changing step 5](../images/build-dapp-interface/dapp-5.png "Dapp Interface changing step 5")\n\nFor the Button component we have emited the click from prop with `@onClick`, so I will pay attention if the faucet function is working correctly now (the balance should change on click):\n\n![Dapp Interface changing step 6](../images/build-dapp-interface/dapp-6.gif "Dapp Interface changing step 6")\n\n### Adding the icon\n\nLet\'s add an icon to this button to attract more attention to this element of the interface, as user can\'t interact with the dapp properly without units and clicking on this button.\n\nFor this purpose you can use any ready Vue library for icons, I will create my own component with the icon.\n\n- I found an appropriate icon on [the big online archive of icons](https://www.flaticon.com).\n- Downloaded .svg file and edited it in the vector graphics editor to make the proper size.\n- Inserted svg as a text in the Icon.vue component.\n\n<details>\n\n<summary>Here is what I got as the Icon.vue component</summary>\n\n```JS\n<template>\n  <div class="icon inline-block" :class="classList">\n    <svg v-if="icon == \'faucet\'" class="icon-fill" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" :width="SvgWidth(20)"  viewBox="0 0 20 24.9" style="enable-background:new 0 0 20 24.9;" xml:space="preserve">\n      <path d="M2.7,24.9c0.2,0,2.4,0,2.4-2.4c0-2-2.2-5.2-2.2-5.2s-2.5,3.3-2.5,5.3C0.4,24.6,2.4,24.9,2.7,24.9z M20,10.8V7.2V3.1h-2.6v2.6h-3.1V1.5h2.6c0.4,0,0.8-0.3,0.8-0.8S17.3,0,16.9,0h-6.7C9.8,0,9.5,0.3,9.5,0.8s0.3,0.8,0.8,0.8h2.6v4.1H7.9c-4.7,0-6.2,3.2-6.3,4.8c0,0,0,0.1,0,0.1v2.8H0v2.1h6.2v-2.1H4.6v-2.7c0-0.3,0.4-1.9,3.3-1.9h9.6v2.1L20,10.8L20,10.8z"/>\n    </svg>\n\n  </div>\n</template>\n\n<script>\n\nexport default {\n  props: {\n    icon: {\n      type: String\n    },\n    classList: {\n      type: String\n    },\n    scale: {\n      type: String,\n      default: \'1\'\n    },\n  },\n\n  methods: {\n    SvgWidth(SvgWidth) {\n      return `${SvgWidth * this.scale}px`;\n    }\n  }\n};\n<\/script>\n\n<style>\n.icon {\n    line-height: 1;\n}\n</style>\n\n```\n\n</details>\n\nTo use it with the button, edit the Button component.\n\nImport the Icon in **Button.vue**:\n\n```JS\ncomponents: {\n    Icon: () => import("./Icon")\n}\n```\n\nRegister prop:\n\n```JS\nprops: {\n  icon: {\n    type: String,\n    default: \'none\'\n  }\n}\n```\n\nAdd the Icon to the button (we can specify different templates with `v-if` condition):\n\n```HTML\n<template v-if="icon != \'none\'">\n  <Icon :icon="icon" />\n  <span v-if="label != \'\'" class="inline-block">{{ label }}</span>\n</template>\n<template v-if="icon == \'none\' & label != \'\'">\n  {{ label }}\n</template>\n```\n\nAdd styles:\n\n```CSS\n.button .icon-fill path {\n  fill: var(--color-light);\n}\n\n.button > *:not(:last-child) {\n  margin-right: calc(var(--space)/2);\n}\n\n```\n\nAdd the icon prop into the button in **App.vue**:\n\n```HTML\n<Button label="Faucet" size="large" icon="faucet" @onClick="faucet" />\n```\n\n**Check:**\n\n![Dapp Interface changing step 7](../images/build-dapp-interface/dapp-7.png "Dapp Interface changing step 7")\n\n### Add the Polkadot avatar\n\n- Install [@vue-polkadot/vue-identicon](https://vue-polkadot.js.org/vue-ui/vue-identicon/#vue-polkadot-vue-identicon)\n\n- Import to App.vue:\n```JS\ncomponents: {\n    Identicon: () => import("@vue-polkadot/vue-identicon")\n}\n```\n\n- Insert the avatar instead of the word \'Account\', pass props according to the documentation, use `account` data as a value prop:\n```HTML\n<Identicon\n  :value="account"\n  :theme="\'polkadot\'"\n  :size="40"\n  :class="\'inline-block\'"\n/>\n```\n\n**Check:**\n\n![Dapp Interface changing step 8](../images/build-dapp-interface/dapp-8.png "Dapp Interface changing step 8")\n\n## Data manipulation for the better view\n\nLet\'s cut the account address:\n\n- Wrap the variable `account` in the computed property:\n\n```JS\ncomputed: {\n  AccountAddress() {\n    return this.account.slice(0, 6) + "..." + this.account.slice(-4);\n  }\n}\n```\n\n- Replace the variable `account` with `AccountAddress` in the template\n\n**Check:**\n\n![Dapp Interface changing step 9](../images/build-dapp-interface/dapp-9.png "Dapp Interface changing step 9")\n\n## CSS magic\n\nLet\'s prettify the account section a little bit more:\n\n<details>\n\n<summary>Template</summary>\n\n```HTML\n<Box :classList="\'account\'">\n              \n  <div class="account__address">\n    <Identicon\n      :value="account"\n      :theme="\'polkadot\'"\n      :size="40"\n      :class="\'inline-block\'"\n    />\n\n    <code class="inline-block">{{ AccountAddress }}</code>\n  </div>\n  \n  <div class="account__balance">{{ balance }}</div>\n\n  <Button label="Faucet" size="large" @onClick="faucet" />\n  \n</Box>\n```\n\n</details>\n\n\n<details>\n\n<summary>Styles (in app.css)</summary>\n\n```CSS\n.account {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  align-items: center;\n  justify-items: stretch;\n  column-gap: var(--space);\n}\n\n.account__balance {\n    font-size: 150%;\n    font-weight: 500;\n    font-family: var(--font-family-code);\n    white-space: nowrap;\n}\n\n.account__address > *:not(:last-child) {\n    margin-right: calc(var(--space)/2);\n}\n```\n\n</details>\n\n![Dapp Interface changing step 10](../images/build-dapp-interface/dapp-10.gif "Dapp Interface changing step 10")\n\nLet\'s edit styles for the tabs:\n\n<details>\n\n<summary>Styles (in app.css)</summary>\n\n```CSS\n.tabs {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  margin-top: calc(var(--space)*2.5);\n}\n\n.tabs button {\n  text-transform: uppercase;\n  letter-spacing: 1px;\n  border-width: 0 0 1px;\n  font-family: var(--font-family);\n  font-size: calc(var(--font-size)*1.5);\n  font-weight: 300;\n  cursor: pointer;\n  transition: 0.2s all linear;\n}\n\n.tabs button:not(.active) {\n  opacity: 0.5;\n  border-color: var(--color-gray)\n}\n\n.tabs-content {\n  padding-top: var(--space);\n}\n```\n\n</details>\n\n<details>\n\n<summary>Minimal template changes:</summary>\n\n```HTML\n<div class="tabs-content">\n  <Demo v-if="tab === \'demo\'" :api="api" :account="account" />\n  <Launch v-if="tab === \'launch\'" :api="api" :account="account" />\n  <Datalog v-if="tab === \'datalog\'" :api="api" :account="account" /> \n</div>\n```\n\n</details>\n\n![Dapp Interface changing step 11](../images/build-dapp-interface/dapp-11.gif "Dapp Interface changing step 11")\n\n> Let me remind you that the finished code for this tutorial is in [this](https://github.com/positivecrash/wscool21-ui-dapp) repository. And let\'s shift to the next steps :)\n\n## Datalog\n\nStart with fixing UI elements that are already known in the dapp: buttons (same as we have done for the \'Faucet\', but with different props).\n\nThen I will wrap these elements in `<fieldset>` to separate them by meaning. And I will write my own styles for the fieldset and input elements.\n\n<details>\n\n<summary>Template in Datalog.vue:</summary>\n\n```HTML\n<div class="tools">\n  <fieldset>\n    <Button label="Read data" size="large" type="secondary" @onClick="read" />\n  </fieldset>\n\n  <fieldset>\n    <input v-model="data" :disabled="isWrite" class="large" />\n    <Button label="Write" :disabled="isWrite" size="large" type="secondary" @onClick="write" />\n  </fieldset>\n</div>\n```\n\n</details>\n\n\n<details>\n\n<summary>Styles for input elements in app.css - it\'s supposed to be global:</summary>\n\n```CSS\ninput, select{\n  padding: .3rem 0.6rem;\n  border: 1px solid var(--color-gray);\n  background-color: var(--color-light);\n  border-radius: var(--radius);\n  font-size: var(--font-size);\n  font-family: var(--font-family-code);\n  border-radius: .25rem;\n  transition: 0.2s ease all;\n}\n\ninput:focus {\n  border-color: var(--color-dark);\n}\n\ninput.large, select.large {\n  font-size: 1.2rem;\n  padding: .35rem 1rem;\n}\n\n\n.tools *, .tools fieldset:not(:last-child):after {\n  display: inline-block;\n  vertical-align: middle;\n  vertical-align: -moz-middle-with-baseline;\n  vertical-align: -webkit-baseline-middle;\n}\n\n.tools fieldset {\n  border: 0;\n}\n\n.tools fieldset:not(:last-child):after {\n  content: "•";\n}\n\n.tools fieldset > *,  .tools > * {\n  margin-right: calc(var(--space)/2)\n}\n```\n\n</details>\n\n**Let\'s check that everything works fine after updates:**\n\n![Dapp Interface changing step 12](../images/build-dapp-interface/dapp-12.gif "Dapp Interface changing step 12")\n\nWe have a datalog section through out the dapp, so I\'ll make a component for it.\n\n<details>\n\n<summary>I have got the following code for a new component DatalogSection.vue</summary>\n\n```HTML\n<template>\n    <div v-if="log" class="log">\n        <h4 class="log-title">Datalog</h4>\n\n        <div class="log-content">\n\n          <p v-if="log.length === 0" class="error">Not found</p>\n\n          <details v-for="(item, k) in log" :key="k" class="box" :open="k === 0">\n              <summary>{{ item[0] }}</summary>\n              <pre>{{ item[1] }}</pre>\n          </details>\n        </div>\n    </div>\n</template>\n\n<script>\n\nexport default {\n\n  props: {\n    log: {\n      type: Array\n    }\n  },\n\n}\n\n<\/script>\n\n<style>\n\n.log {\n  text-align: left;\n  margin: var(--space) auto;\n  width: 100%;\n}\n\n.log-content {\n  border: 1px solid var(--color-gray);\n  max-height: 500px;\n  overflow-y: auto;\n  padding: var(--space);\n  background-color: var(--color-gray-middark);\n  outline: 1px solid #fff;\n  box-shadow: 0 0 60px 20px #fff inset;\n}\n\n.log-title {\n  color: var(--color-gray-dark);\n  font-weight: 300;\n  font-family: var(--font-family-code);\n\n  border-bottom: 1px solid var(--color-gray);\n}\n\n.log .box {\n  margin-bottom: var(--space);\n}\n\ndetails {\n  transition: 0.2s all ease;\n}\n\ndetails summary {\n  cursor: pointer;\n}\n\ndetails.box {\n  padding-top: 0;\n  padding-bottom: 0;\n}\n\ndetails.box[open] {\n  padding-bottom: calc(var(--space)*0.5);\n}\n\ndetails.box:focus {\n  box-shadow: 0 0 5px var(--color-gray)\n}\n\ndetails.box summary {\n  padding-top: calc(var(--space)*0.5);\n  padding-bottom: calc(var(--space)*0.5);\n}\n\ndetails.box[open] summary {\n  border-bottom: 1px solid var(--color-dark);\n  margin-bottom: calc(var(--space)*0.5);\n  font-weight: 500;\n}\n\n.log details.box summary {\n  font-family: var(--font-family-code);\n}\n\n</style>\n```\n\n</details>\n\nWhat you should pay attention to here: we pass prop `log` as an array. I assume that this multidimensional array will contain log of entries and every entry has a title (I wrote there date for all logs in the dapp) and content. We need to reformat arrays in components **Datalog.vue** and **Launch.vue**.\n\nNow edit **Datalog.vue**. Find method, where we get the log:\n```JS\nasync read() {\n  this.log = (await this.api.query.datalog.datalog(this.account)).toArray();\n}\n```\n\nNow we have to format data in **Datalog.vue**, and pass ready log array for **DatalogSection.vue**. So let\'s map the log array:\n```JS\nasync read() {\n  this.log = (await this.api.query.datalog.datalog(this.account)).toArray().map((item) => {\n    return [new Date(Number(item[0])).toLocaleString(), u8aToString(item[1])]\n  });\n}\n```\n\nWe don\'t need this code anymore:\n```JS\nfilters: {\n  dateFormat: function(v) {\n    return new Date(Number(v)).toLocaleString();\n  },\n  dataFormat: function(v) {\n    return u8aToString(v);\n  }\n}\n```\n\n**Let\'s check the datalog section in Datalog tab:**\n\n![Dapp Interface changing step 13](../images/build-dapp-interface/dapp-13.gif "Dapp Interface changing step 13")\n\n## Launch\n\nFor this step, most of improvements have already been done, we just need to apply them to the template: import Button and Datalog components, remove the excessive title:\n\n![Dapp Interface changing step 14](../images/build-dapp-interface/dapp-14.gif "Dapp Interface changing step 14")\n\nLet\'s replace `select` control element with `checkbox`.\n\nInstead of this:\n```HTML\n<select v-model="parameter" :disabled="isWrite">\n  <option value="ON">ON</option>\n  <option value="OFF">OFF</option>\n</select>\n```\n\nWrite this:\n```HTML\n<div class="toggler inline-block">\n  <input v-model="parameter" :disabled="isWrite" type="checkbox" id="robot-switch" />\n  <label for="robot-switch"><span></span></label>\n</div>\n```\n\n<details>\n\n<summary>Styles in app.css:</summary>\n\n```CSS\n.toggler input { display: none; }\n.toggler label {\n  position: relative;\n  display: block;\n  width: 60px;\n  height: 40px;\n  border-radius: 4px;\n  font-weight: 500;\n  text-transform: uppercase;\n  letter-spacing: 1px;\n  cursor: pointer;\n  background-color: var(--color-gray);\n  color: var(--color-light);\n  text-align: center;\n}\n\n.toggler label:before {\n  content: \'Off\';\n  width: 100%;\n  text-align: center;\n  line-height: 40px;\n}\n\n.toggler label:after {\n  content: \'\';\n  display: block;\n  width: 6px;\n  height: 100%;\n  border-radius: 10px;\n  background-color: var(--color-gray-dark);\n\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: 10;\n\n  transition: 0.3s ease-out all;\n}\n\n.toggler input:checked + label {\n  background-color: var(--color-green);\n}\n\n.toggler input:checked + label:before {\n  content: \'On\';\n}\n\n.toggler input:checked + label:after {\n  transform: translateX(54px);\n  background-color: #007038;\n}\n```\n\n</details>\n\n![Dapp Interface changing step 15](../images/build-dapp-interface/dapp-15.gif "Dapp Interface changing step 15")\n\nI want to clarify something with the interface: with these elements we start some device. Let\'s visualize it. I\'ve chosen a drone, so I will toggle classes according to `item.parameter`.\n\nCreate a new property in `data`:\n```JS\ndata() {\n  status: false\n}\n```\n\nAssign value of `parameter` to `status` after button is clicked and tx is sent to the block:\n```JS\nmethods: {\n    async launch() {\n      try {\n        this.error = "";\n        this.isWrite = true;\n\n        const tx = await this.api.tx.launch\n          .launch(this.robot, this.parameter === "ON")\n          .signAsync(this.account);\n\n        await tx.send(result => {\n          if (result.status.isInBlock) {\n            this.isWrite = false;\n            this.status = this.parameter; // new line here\n          }\n        });\n      } catch (error) {\n        this.error = error.message;\n        this.isWrite = false;\n      }\n    }\n  }\n```\n\nWrite styles for the drone in **Launch.vue**. Don\'t forget `scoped` for `<style>` tag, to apply styles only for this component.\n\n<details>\n\n<summary>CSS for drone:</summary>\n\n```CSS\n<style scoped>\n.tools {\n  position: relative;\n  padding-left: 120px;\n  text-align: left;\n  display: inline-block;\n}\n\n.launch-drone {\n  position: absolute;\n  width: 100px;\n  left: 0;\n  filter: grayscale(1);\n  transition: 1s all ease-in;\n}\n\n.launch-drone.on {\n  filter: grayscale(0);\n  animation: DroneLaunch 10s linear infinite;\n}\n\n@keyframes DroneLaunch {\n  0%, 20%, 40%, 60%, 80%, 100% {\n    transform: translateY(0);\n  }\n  10%, 30%, 50%, 70%, 90% {\n    transform: translateY(-20%);\n  }\n}\n</style>\n```\n\n</details>\n\n![Dapp Interface changing step 16](../images/build-dapp-interface/dapp-16.gif "Dapp Interface changing step 16")\n\nNow let\'s add the **DatalogSection.vue** component.\n\n```JS\ncomponents: {\n  DatalogSection: () => import("./DatalogSection")\n}\n```\n\nReformat the log array from:\n\n```JS\nthis.log.push({\n  sender,\n  robot,\n  parameter\n});\n```\n\nto (for structure like `[["entry 1 date", "entry 1 content"], ["entry 2 date", "entry 2 content"]]`):\n\n```JS\nthis.log.push([new Date().toLocaleString(), {\n  sender,\n  robot,\n  parameter\n}]);\n```\n\nReplace the code from the template:\n\n```HTML\n<div v-if="log.length > 0" class="log">\n  <div v-for="(item, k) in log" :key="k" class="row">\n    sender: <b>{{ item.sender }}</b>\n    <br />\n    robot: <b>{{ item.robot }}</b>\n    <br />\n    parameter: <b>{{ item.parameter ? "ON" : "OFF" }}</b>\n  </div>\n</div>\n```\n\nwith this:\n\n```HTML\n<DatalogSection :log="log"/>\n```\n\n**Check:**\n![Dapp Interface changing step 17](../images/build-dapp-interface/dapp-17.gif "Dapp Interface changing step 17")\n\nSometimes you get some errors, it\'s almost inevitable. Something can go wrong with the connection or anything else can happen. So we have fallbacks with error messages through out the dapp, I haven\'t changed them from the start, in the code they look like:\n\n```HTML\n<div v-if="error" class="error">{{ error }}</div>\n```\n\nOn the interface errors look this way now:\n\n![Dapp Interface changing step 18](../images/build-dapp-interface/dapp-18.png "Dapp Interface changing step 18")\n\nAdd styles for the `.error` in **app.css**:\n\n```CSS\n.error {\n  font-weight: 400;\n  text-transform: uppercase;\n  letter-spacing: 1px;\n  color: var(--color-red);\n}\n```\n\nAnd I will fix a space between the `.tools` section and other content from the bottom as well in **app.css**:\n\n```CSS\n.tools {\n  margin-bottom: var(--space);\n}\n```\n\nWe get:\n\n![Dapp Interface changing step 19](../images/build-dapp-interface/dapp-19.png "Dapp Interface changing step 19")\n\nNow on this page we have to "primary" buttons. Technically it is okay, but this is not okay from the above user experience. It\'s better not to use more than one prevailing button on the screen. So let\'s fix it and add for the `Button` in **Launch.vue** with property `type="secondary"`:\n\n![Dapp Interface changing step 20](../images/build-dapp-interface/dapp-20.png "Dapp Interface changing step 20")\n\nGreat, now I\'ll fix some issues with my node and go to the Demo step.\n\n## Demo\n\nFor the start, I\'d like to swap tabs, to pay more attention to the most relevant one, but this is not the first step that we do to practice. Reverse tabs in **App.vue**.\n\nDon\'t forget to replace the default data:\n\n```JS\ndata() {\n    return {\n      ...\n      tab: "demo"\n    };\n},\n```\n\n![Dapp Interface changing step 21](../images/build-dapp-interface/dapp-21.png "Dapp Interface changing step 21")\n\nAs usual let\'s start with changing what we have already got.\n\n- Remove the title `<h2>Demo</h2>` as in the previous steps\n- Find UI elements that we have already learn – datalog, buttons, account address. But not so fast. Now we\'ll change the datalog only.\n\nAdd the component to **Demo.vue**:\n\n```JS\ncomponents: {\n  DatalogSection: () => import("./DatalogSection")\n}\n```\n\n```HTML\n<DatalogSection :log="log"/>\n```\n\nWe\'ve got raw data in the log, so we need to reformat the array with the log to pass in the component ready-view data as in the previous steps. Find the line `return [item[0], item[1]];` in `async created()` and replace it with:\n\n```JS\nreturn [new Date(Number(item[0])).toLocaleString(), JSON.parse(u8aToString(item[1]))];\n```\n\nRemove the unused code from the log:\n\n```HTML\n<div v-if="log" class="log">\n  <p v-if="log.length === 0" class="error">Not found</p>\n  <div v-for="(item, k) in log" :key="k" class="row">\n    <b>{{ item[0] | dateFormat }}</b>\n    <pre>{{ item[1] | dataFormat }}</pre>\n  </div>\n</div>\n```\n\nand:\n\n```JS\nfilters: {\n  dateFormat: function(v) {\n    return new Date(Number(v)).toLocaleString();\n  },\n  dataFormat: function(v) {\n    return JSON.parse(u8aToString(v));\n  }\n},\n```\n\n**Check:**\n![Dapp Interface changing step 22](../images/build-dapp-interface/dapp-22.png "Dapp Interface changing step 22")\n\nFor customization of this demo example with launching a robot, you are free to come up with any idea. Personally, I started with this town:\n\n![Dapp Interface changing step 23](../images/build-dapp-interface/dapp-23.gif "Dapp Interface changing step 23")\n\nI won\'t show the whole code for this not to confuse you at all, but schematically there will be something like this:\n\n```HTML\n<div class="demo" :class="[robot.state ? \'play\' : \'stop\']">\n  <div class="demo-back"></div>\n  <div class="demo-city"></div>\n  <div class="demo-car"></div>\n</div>\n```\n\nThan within the element `.demo.play` write styles for moving the city backward, and the car forward.\n\nWhile working on this, I came up with the idea of realization the CyberPunk city. As I have no any particullar task, so the car became a taxi, driver became a passenger, and now on the interface we have an AI robot hologram welcoming the passenger (these all are just CSS and graphics tweaks&&tricks).\n\n**The code for the Cyberpunk city demo:**\n\n<details>\n\n<summary>Template</summary>\n\n```HTML\n<div class="demo" :class="[robot.state ? \'play\' : \'stop\']">\n  <div class="demo-back-1"></div>\n  <div class="demo-back-2"></div>\n  <div class="demo-city-1"></div>\n  <div class="demo-car"></div>\n\n  <div class="demo-data">\n    <div class="demo-data-driver inline-block">\n      <img alt="Driver\'s avatar" src="../assets/images/cabman.png" v-if="robot.state"/>\n    </div>\n    <div class="demo-data-lines inline-block">\n      <div class="demo-data-line">\n          <div>Robot</div>\n          <div>[ {{ addressShort(robot.address) }} ]</div>\n      </div>\n\n      <div class="demo-data-line" v-if="robot.state">\n          <div>Passenger</div>\n          <div>[ {{ addressShort(robot.driver) }} ]</div>\n      </div>\n\n      <div class="demo-data-welcome" v-if="robot.state">\n          <span>Hello, passenger. </span>\n          <span>I\'ve linked to the vehicle. </span>\n          <span>Your ride begins, congrats! </span>\n      </div>\n    </div>\n\n  </div>\n\n  <Button :label="robot.state ? \'stop\' : \'run\'" :disabled="isWrite" size="large" @onClick="run" />\n</div>\n```\n\n</details>\n\nThere are more than one hash address that should be shortenned, so I added the method:\n\n```JS\nmethods: {\n  addressShort(address) {\n    return address.slice(0, 6) + "..." + address.slice(-4);\n  }\n}\n```\n\nDon\'t forget to register the Button component\n\n```JS\ncomponents: {\n  Button: () => import("./Button")\n}\n```\n\n<details>\n\n<summary>Styles</summary>\n\n```CSS\n<style scoped>\n.demo {\n    --h: 120px;\n    --color-yellow: #F2F209;\n\n    background-color: #AFCCD3;\n\n    background: linear-gradient(#010123, #4baac7);\n\n    position: relative;\n    height: 500px;\n    overflow: hidden;\n\n    border-width: 2px 2px 2px 15px;\n    border-style: solid;\n    border-color: var(--color-yellow);\n    \n}\n\n.demo:before {\n    content: \'[ Delamain cabs rental DEMO ]\';\n    background-color: var(--color-yellow);\n    color: #000;\n\n    position: absolute;\n    top: 0;\n    left: 0;\n    padding: .5rem 1rem;\n\n    text-transform: uppercase;\n    letter-spacing: 1px;\n    font-weight: 300;\n\n    border-width: 0 6px 2px 0;\n    border-style: solid;\n    border-color: #7B186E;\n}\n\ndiv[class^=demo-back-], div[class^=demo-city-] {\n    position: absolute;\n    left: 0;\n    width: 100%;\n    z-index: 2;\n}\n\ndiv[class^=demo-back-]{\n    border-top: 1px solid #364444;\n}\n\ndiv[class^=demo-city-] {\n    background-repeat: repeat-x;\n    background-size: cover;\n    background-position: 100% 0;\n\n    height: 300px;\n    bottom: var(--h);\n\n    animation: 50s MoveCity infinite linear 1.5s;\n}\n\ndiv.demo-back-1 {\n    background-color: #060236;\n    background: linear-gradient(#7B186E, #060236);\n    height: var(--h);\n    bottom: 0;\n}\n\ndiv.demo-back-2 {\n    background-color: #c515ae;\n    border-width: 2px 0;\n    border-style: solid;\n    border-color: #69045c;\n\n    height: 20px;\n    bottom: var(--h);\n    z-index: 10;\n}\n\ndiv.demo-city-1 {\n    background-image: url(../assets/images/city-1.png);\n}\n\n.demo-car {\n    background-image: url(../assets/images/car.png);\n    background-size: contain;\n    background-repeat: no-repeat;\n    background-position: 100% 0;\n\n    width: calc(508px * 0.5);\n    height: calc(257px * 0.5);\n    position: absolute;\n    bottom: calc(var(--h) + 4px);\n    z-index: 10;\n\n    transform: translateX(-100px);\n    animation: MoveCar 50s infinite 1.5s linear;\n}\n\n.demo.play div[class^=demo-city-], .demo.play .demo-car { animation-play-state: running; }\n.demo.stop div[class^=demo-city-], .demo.stop .demo-car { animation-play-state: paused; }\n\n.demo.play .demo-car {\n    background-image: url(../assets/images/car-ride.png);\n}\n\n\n.demo button {\n    background-color: var(--color-yellow);\n    border-color: var(--color-yellow);\n    color: #000;\n\n    position: absolute;\n    bottom: 30px;\n    right: 30px;\n    z-index: 1000;\n}\n\n.demo-data {\n    position: absolute;\n    bottom: 30px;\n    left: 30px;\n    z-index: 1000;\n\n    background-color: rgba(0, 0, 0, .5);\n    color: #fff;\n    padding: .5rem;\n    font-family: var(--font-family-code);\n\n    transition: 0.2s all ease;\n}\n\n.demo-data-lines {\n    max-width: 400px;\n}\n\n.demo-data-line {\n    display: grid;\n    grid-template-columns: 100px auto;\n    gap: .5rem;\n    text-align: left;\n}\n\n.demo-data-line div:first-child {\n    text-transform: uppercase;\n    letter-spacing: 1px;\n    font-weight: 700;\n}\n\n.demo-data-driver {\n    margin-right: 1rem;\n}\n\n.demo-data-driver img {\n    display: block;\n    max-width: 100px;\n\n    visibility: hidden;\n    opacity: 0;\n    animation: FadeInBlink .3s cubic-bezier(0.075, 0.82, 0.165, 1) 0.6s forwards;\n}\n\n.demo-data-welcome {\n    text-align: left;\n    padding-top: .5rem;\n}\n\n.demo-data-welcome span {\n    visibility: hidden;\n    opacity: 0;\n\n    animation-name: FadeIn;\n    animation-timing-function: cubic-bezier(0.075, 0.82, 0.165, 1);\n    animation-duration: 0.6s;\n    animation-fill-mode: forwards;\n}\n\n.demo-data-welcome span:nth-child(1) { animation-delay: 1.5s; }\n.demo-data-welcome span:nth-child(2) { animation-delay: 2.5s; }\n.demo-data-welcome span:nth-child(3) { animation-delay: 3.2s; }\n\n\n@keyframes MoveCity\n{\n  100% {\n    background-position: -1000px 0;\n  }\n}\n\n@keyframes MoveCar\n{\n    0% {\n        transform: translateX(-100px);\n    }\n    100% {\n        transform: translateX(960px);\n    }\n}\n</style>\n\n```\n\n</details>\n\n**Result:**\n\n![Dapp Interface changing step 25](../images/build-dapp-interface/dapp-25.gif "Dapp Interface changing step 25")\n\n## Conclusion\n\nCongratulations! Now you have redesigned the dapp and clues how to start building your application\'s interface.\n\n### Checkout links\n\n- [Full code of this tutorial](https://github.com/positivecrash/wscool21-ui-dapp)\n- [Discuss in Discord](https://discord.gg/5UWNGNaAUf)\n- [View the Robonomics Winter School 2021 schedule and summary](https://robonomics.network/blog/winter-robonomics-school/)\n- [Github of contributor](https://github.com/positivecrash)\n\n### Practice\n\nIf you have some extra time or want to practice your skills, there are some ideas for improvements that you could make to this demo:\n\n- Adapt UI for narrow screens, make the dapp mobile-friendly\n- Add the \'day/night\' mode, by editing the **_variables.scss** file and the template file of the dapp\n- Add \'Copy to clipboard\' buttons for addresses\n- Make delicate popus to inform users about changes (e.g. you can popup a message that units are received after clicking the \'Faucet\' button, or you can move in the popup an error that we had in the \'Launch\' section).\n\nPlease, fill free to ask questions and share your results in [Discord](https://discord.gg/5UWNGNaAUf), mark me in your message `@positivecrash`\n\n\n\n\n\n\n'}},{node:{id:"c1b5b8acb186e3cbcaf0a6c6d0de0188",title:"Lesson 6.1, Build IoT Dapps For End Users",path:"/docs/en/wschool2021-build-dapp-for-end-users/",content:'\n## Getting ready\n\n### Robonomics node launch\n\nFor dApp development and testing, we will use a local Robonomics node. To do this, you need to download the compiled binary file https://github.com/airalab/robonomics/releases. I will be using Ubuntu, so I download the appropriate version.\n\nUnpack the archive\n```sh\nwget https://github.com/airalab/robonomics/releases/download/v0.24.0/robonomics-ubuntu-0.24.0-x86_64.zip\nunzip robonomics-ubuntu-0.24.0-x86_64.zip\ncd robonomics-ubuntu-0.24.0-x86_64\nchmod +x robonomics\n```\n\nNow we can start the node in development mode. To do this, use the --dev flag\n```sh\n./robonomics --dev\n```\n\n> Troubleshooting\n```sh\n./robonomics purge-chain --dev\n```\n\n### Browser extension\n\nTo store keys in a browser, there is a `polkadot{.js} extension`. In dApp we will use it to sign transactions.\n\nThe extension is currently available for `Google chrome` and `Firefox` https://polkadot.js.org/extension/\n\nAfter installing the extension, create a new account.\n![screen1](../images/build-iot-dapps/screen1.png)\n\n> The first step is completed.\n\n## DApp development\n\n### Step 1\n\n> We will write the dApp using the vue.js framework, although you can use whatever you like/can.\n\nLet\'s start developing the dApp by creating a startup application with vue.js And here you can do it in two ways.\n\nWay 1:\n\nUsing the `Vue cli` console utility.\nTo do this, you need to install it https://cli.vuejs.org/guide/installation.html\n\nAfter installation, you can run the command in the terminal\n\n```sh\nvue create mydapp\n```\n\nAnswer a few questions of the setup wizard. We will be using version Vue 2, so we keep the default version `Default ([Vue 2] babel, eslint)`.\n\nWay 2:\n\nClone the prepared git repository with the example and switch to step 1\n\n```sh\ngit clone https://github.com/airalab/example-robonomics-dapp.git mydapp\ncd mydapp\ngit checkout step-1\n```\n\nAs a result, we will get a directory with the installed startup application, which can already be launched and opened in the browser.\n\n```sh\nyarn\nyarn serve\n```\n\n### Step 2. Getting started with polkadot.js\n\n#### Installing dependencies\n\nTo connect the dApp to the Robonomics chain, there is the `@polkadot/api` library. And for interaction of dApp with an extension with keys, we have the `@polkadot/extension-dapp` library. We need to install them into our application.\nMore details on using this library can be found in the documentation https://polkadot.js.org/docs/.\n\nWay 1:\n\n```sh\nyarn add @polkadot/api @polkadot/extension-dapp\n```\n\nYou also need to add the `vue.config.js` file to support `mjs` extension.\n\n`vue.config.js`\n```js\nmodule.exports = {\n  publicPath: "",\n  configureWebpack: {\n    resolve: {\n      extensions: ["*", ".mjs", ".js", ".vue", ".json", ".gql", ".graphql"]\n    },\n    module: {\n      rules: [\n        {\n          test: /\\.mjs$/,\n          include: /node_modules/,\n          type: "javascript/auto"\n        }\n      ]\n    }\n  }\n};\n```\n\n#### Connecting to Robonomics\n\nFirst, let\'s create a configuration file with the parameters for connecting to the Robonomics node. In the demo repository, there is an example of this file `config.template.json`.\n\n`src/config.json`\n```json\n{\n  "endpoint": "ws://localhost:9944",\n  "types": {\n    "Record": "Vec<u8>",\n    "Parameter": "Bool",\n    "Address": "AccountId",\n    "LookupSource": "AccountId"\n  }\n}\n```\n\nIn this file, we indicate the node, which we are going to connect to, and custom types. The types for Robonomics can be taken from github https://github.com/airalab/robonomics/blob/master/bin/node/cli/res/custom_types.json\n\nNow we need to write a script to connect to our running node.\n\n`src/utils/api.js`\n```js\nimport { ApiPromise, WsProvider } from "@polkadot/api";\nimport config from "../config.json";\n\nlet api;\nexport async function initApi() {\n  const provider = new WsProvider(config.endpoint);\n  api = await ApiPromise.create({\n    provider,\n    types: config.types\n  });\n  return api;\n}\n\nexport function getApi() {\n  return api;\n}\n```\n\nSo that we can sign transactions with the key from the extension, let’s add two functions for connecting to the extension and the function for initializing the account.\n\n`src/utils/api.js`\n```js\n...OTHER_CODE...\n\nimport {\n  web3Accounts,\n  web3Enable,\n  web3FromAddress\n} from "@polkadot/extension-dapp";\n\nasync function getExtension() {\n  const extensions = await web3Enable("demo");\n  if (extensions.length === 0) throw new Error("no extension");\n  return extensions[0];\n}\n\nexport async function initAccount(index = 0) {\n  const timeout = new Promise(resolve => {\n    setTimeout(resolve, 300);\n  });\n  await timeout;\n  await getExtension();\n  const accounts = await web3Accounts();\n  if (accounts.length > 0) {\n    const injector = await web3FromAddress(accounts[index].address);\n    api.setSigner(injector.signer);\n    return accounts[index].address;\n  }\n  throw new Error("no accounts");\n}\n\n...OTHER_CODE...\n```\n\nOur account will have a zero balance, while we need a little funds. So we need to create another faucet function. As we launched Robonomics with the `--dev` flag, we have `Alice` account with a large balance, so we will request funds from there.\n\n`src/utils/api.js`\n```js\n...OTHER_CODE...\n\nimport { Keyring } from "@polkadot/keyring";\n\nexport function getBalance(account, cb) {\n  api.query.system.account(account, ({ data: { free: currentFree } }) => {\n    cb(currentFree);\n  });\n}\n\nexport const keyring = new Keyring({ type: "sr25519" });\n\nexport async function faucet(address) {\n  keyring.setSS58Format(api.registry.chainSS58);\n  const account = keyring.addFromUri("//Alice");\n  const tx = api.tx.balances.transfer(address, 1000000000000000);\n  await tx.signAndSend(account);\n}\n\n...OTHER_CODE...\n```\n\nThe full version of script https://github.com/airalab/example-robonomics-dapp/blob/master/src/utils/api.js\n\nRun app\n\n```sh\nyarn serve\n```\n\nWay 2:\n\nIf you start the application with cloning the repository, then in order to complete these steps, it will be enough to switch to step 2 and install the rest of the dependencies.\n\n```sh\ngit checkout step-2\ncp src/config.template.json src/config.json\nyarn\nyarn serve\n```\n\n### Step 3. Vue connecting component\n\n#### Connecting\n\nWe have already written a script for connecting. Now we can use it on our interface. It is enough to call the written `initApi` function in  the root component `App.vue`. And while the user is waiting for a connection, we will show him a small loader, for now in the form of an ellipsis.\n\nWay 1:\n\nComponent template and base styles.\n\n`src/App.vue`\n```js\n<template>\n  <div id="app">\n    <h1>Robonomics dApp</h1>\n    <div v-if="load">...</div>\n    <template v-else>\n      <div v-if="error" class="error">{{ error }}</div>\n      <template v-else-if="api">\n        connected\n      </template>\n    </template>\n  </div>\n</template>\n\n...OTHER_CODE...\n\n<style>\n#app {\n  font-family: Avenir, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n  margin-top: 60px;\n}\nbutton {\n  font-size: 14px;\n  padding: 5px 12px;\n}\nbutton:hover {\n  cursor: pointer;\n}\ninput {\n  font-size: 14px;\n  padding: 5px;\n}\nselect {\n  font-size: 14px;\n  padding: 5px;\n}\nbutton:focus,\ninput:focus {\n  outline: none;\n}\n.error {\n  color: rgb(151, 31, 31);\n  font-weight: bold;\n  text-align: center;\n  margin: 10px 0;\n}\n</style>\n```\n\nThere is the component code where the  `initApi` function will be called\n\n`src/App.vue`\n```js\n<script>\nimport { initApi } from "./utils/api";\n\nexport default {\n  name: "App",\n  data() {\n    return {\n      load: false,\n      api: null,\n      error: null\n    };\n  },\n  created() {\n    this.init();\n  },\n  methods: {\n    async init() {\n      try {\n        this.load = true;\n        this.api = await initApi();\n        this.load = false;\n      } catch (error) {\n        this.error = error.message;\n        this.load = false;\n      }\n    }\n  }\n};\n<\/script>\n```\n\n#### Account with balance\n\nNow we can use our account, top up its balance and show it on the interface.\n\nLet’s add the appropriate markup to the template\n\n`src/App.vue`\n```js\n<template>\n\n  ...OTHER_CODE...\n\n    <template v-else>\n      <div v-if="error" class="error">{{ error }}</div>\n      <template v-else-if="api && account">\n        <p>\n          Account: <b>{{ account }}</b> {{ balance }} |\n          <button @click="faucet">\n            faucet\n          </button>\n        </p>\n      </template>\n    </template>\n\n  ...OTHER_CODE...\n\n</template>\n```\n\nLet’s add new fields for account address and balance\n\n`src/App.vue`\n```js\n\n...OTHER_CODE...\n\ndata() {\n  return {\n\n    ...OTHER_CODE...\n\n    account: null,\n    balance: 0,\n\n    ...OTHER_CODE...\n\n  };\n}\n\n...OTHER_CODE...\n```\n\nWe need to add the account initialization to the `init` function and get its balance\n\n`src/App.vue`\n```js\n<script>\nimport { initApi, initAccount, getBalance, faucet } from "./utils/api";\nimport { formatBalance } from "@polkadot/util";\n\n...OTHER_CODE...\n\nasync init() {\n\n  ...OTHER_CODE...\n\n  this.api = await initApi();\n  this.account = await initAccount();\n  getBalance(this.account, balance => {\n    this.balance = formatBalance(balance);\n  });\n\n  ...OTHER_CODE...\n\n}\n\n...OTHER_CODE...\n<\/script>\n```\n\nIt remains to add the function of replenishing the balance, when clicking on the button\n\n`src/App.vue`\n```js\n\n...OTHER_CODE...\n\n  methods: {\n    faucet() {\n      faucet(this.account);\n    },\n\n...OTHER_CODE...\n```\n\nhttps://github.com/airalab/example-robonomics-dapp/blob/step-3/src/App.vue\n\nRun app\n\n```sh\nyarn serve\n```\n\nWay 2:\n\nIf you start the application with cloning the repository, then to complete these steps, you will just need to switch to step 3.\n\n```sh\ngit checkout step-3\nyarn serve\n```\n\nAs a result we will get this picture in the browser\n\n![screen2](../images/build-iot-dapps/screen2.png)\n\n### Step 4. Datalog\n\nTo save and read any data in the chain, we use the `datalog` module.\n\nFor an example of how to use this module, let\'s make a `Datalog.vue` component.\n\nWay 1:\n\nIn the markup, we will have a button for reading data `read` with a block, where we will display a list in the form of a date and the data itself. And there will be a form with a text input, into which you can enter any data in the form of a string, and a `write` button.\n\n`src/components/Datalog.vue`\n```js\n<template>\n  <div>\n    <h2>Datalog</h2>\n    <button @click="read">read</button> |\n    <input v-model="data" :disabled="isWrite" />\n    <button @click="write" :disabled="isWrite">write</button>\n    <div v-if="error" class="error">{{ error }}</div>\n    <div v-if="log" class="log">\n      <p v-if="log.length === 0" class="error">Not found</p>\n      <div v-for="(item, k) in log" :key="k" class="row">\n        date: <b>{{ item[0] | dateFormat }}</b>\n        <br />\n        data: <b>{{ item[1] | dataFormat }}</b>\n      </div>\n    </div>\n  </div>\n</template>\n\n...OTHER_CODE...\n\n<style scoped>\n.log {\n  border: 1px solid #eee;\n  text-align: left;\n  width: 800px;\n  margin: 20px auto;\n}\n.log .row {\n  margin: 10px;\n}\n</style>\n```\n\nComponent code. Here the main point in sending a transaction is to call the function, into which we transfer data and which we sign with our account, via api `this.api.tx.datalog.record(stringToHex(this.data)).signAsync(this.account);`\n\n`src/components/Datalog.vue`\n```js\n<script>\nimport { stringToHex, u8aToString } from "@polkadot/util";\n\nexport default {\n  props: ["api", "account"],\n  data() {\n    return {\n      data: "data string",\n      log: null,\n      isWrite: false,\n      error: ""\n    };\n  },\n  filters: {\n    dateFormat: function(v) {\n      return new Date(Number(v)).toLocaleString();\n    },\n    dataFormat: function(v) {\n      return u8aToString(v);\n    }\n  },\n  methods: {\n    async read() {\n      this.log = (await this.api.query.datalog.datalog(this.account)).toArray();\n    },\n    async write() {\n      try {\n        this.error = "";\n        this.isWrite = true;\n        const tx = await this.api.tx.datalog\n          .record(stringToHex(this.data))\n          .signAsync(this.account);\n        await tx.send(result => {\n          if (result.status.isInBlock) {\n            this.read();\n            this.isWrite = false;\n          }\n        });\n      } catch (error) {\n        this.error = error.message;\n        this.isWrite = false;\n      }\n    }\n  }\n};\n<\/script>\n```\n\nhttps://github.com/airalab/example-robonomics-dapp/blob/master/src/components/Datalog.vue\n\nTo switch between components, added to `App.vue` the output of our component\n\n`src/App.vue`\n```js\n...OTHER_CODE...\n\n<template v-else-if="api && account">\n  <p>\n    Account: <b>{{ account }}</b> {{ balance }} |\n    <button @click="faucet">faucet</button>\n  </p>\n\n  <div>\n    <div class="tabs">\n      <button\n        @click="tab = \'datalog\'"\n        :class="{ active: tab === \'datalog\' }"\n      >\n        datalog\n      </button>\n    </div>\n    <Datalog v-if="tab === \'datalog\'" :api="api" :account="account" />\n  </div>\n</template>\n\n...OTHER_CODE...\n\n<script>\nimport Datalog from "./components/Datalog";\n\n...OTHER_CODE...\n\nexport default {\n  name: "App",\n  components: {\n    Datalog\n  },\n  data() {\n    return {\n      tab: "datalog"\n\n...OTHER_CODE...\n<\/script>\n\n<style>\n...OTHER_CODE...\n\n.tabs button {\n  font-size: 14px;\n  padding: 10px 20px;\n  font-weight: bold;\n  background: #ececec;\n  border: 1px solid #aaa;\n}\n.tabs button:hover {\n  background: #bfbfbf;\n}\n.tabs button:last-child {\n  border-left: none;\n}\n.tabs button.active {\n  background: #ced5e2;\n}\n</style>\n```\n\nRun app\n\n```sh\nyarn serve\n```\n\nWay 2:\n\nIf you start the application with cloning the repository, then to complete these steps, you will just need to switch to step 4.\n\n```sh\ngit checkout step-4\nyarn serve\n```\n\nAs a result we will get this picture in the browser\n\n![screen3](../images/build-iot-dapps/screen3.png)\n\n### Step 5. Launch\n\nThis function is used to start and stop the robot. To demonstrate how to use this module, let\'s write the `Launch.vue` component.\n\nWay 1:\n\nIn the component template, we will have a form where you can specify the address of the robot, the ON/OFF clicker and the button for sending.\n\n`src/components/Launch.vue`\n```js\n<template>\n  <div>\n    <h2>Launch</h2>\n    <input v-model="robot" :disabled="isWrite" placeholder="Robot address" />\n    <select v-model="parameter" :disabled="isWrite">\n      <option value="ON">ON</option>\n      <option value="OFF">OFF</option>\n    </select>\n    <button @click="launch" :disabled="isWrite">launch</button>\n    <div v-if="error" class="error">{{ error }}</div>\n    <div v-if="log.length > 0" class="log">\n      <div v-for="(item, k) in log" :key="k" class="row">\n        sender: <b>{{ item.sender }}</b>\n        <br />\n        robot: <b>{{ item.robot }}</b>\n        <br />\n        parameter: <b>{{ item.parameter ? "ON" : "OFF" }}</b>\n      </div>\n    </div>\n  </div>\n</template>\n\n...OTHER_CODE...\n\n<style scoped>\n.log {\n  border: 1px solid #eee;\n  text-align: left;\n  width: 800px;\n  margin: 20px auto;\n}\n.log .row {\n  margin: 10px;\n}\n</style>\n```\n\nThe code looks like the `Datalog.vue` component. The difference is just in reading. The robot will receive the command through events.\n\n`src/components/Launch.vue`\n```js\n<script>\nexport default {\n  props: ["api", "account"],\n  data() {\n    return {\n      robot: this.account,\n      parameter: "ON",\n      log: [],\n      isWrite: false,\n      error: "",\n      unsubscribe: null\n    };\n  },\n  async created() {\n    this.unsubscribe = await this.api.query.system.events(events => {\n      events.forEach(record => {\n        const { event } = record;\n        if (event.section === "launch" && event.method === "NewLaunch") {\n          const sender = event.data[0].toString();\n          const robot = event.data[1].toString();\n          const parameter = event.data[2].toHuman();\n          this.log.push({\n            sender,\n            robot,\n            parameter\n          });\n        }\n      });\n    });\n  },\n  destroyed() {\n    if (this.unsubscribe) {\n      this.unsubscribe();\n    }\n  },\n  methods: {\n    async launch() {\n      try {\n        this.error = "";\n        this.isWrite = true;\n        const tx = await this.api.tx.launch\n          .launch(this.robot, this.parameter === "ON")\n          .signAsync(this.account);\n        await tx.send(result => {\n          if (result.status.isInBlock) {\n            this.isWrite = false;\n          }\n        });\n      } catch (error) {\n        this.error = error.message;\n        this.isWrite = false;\n      }\n    }\n  }\n};\n<\/script>\n```\n\nhttps://github.com/airalab/example-robonomics-dapp/blob/master/src/components/Launch.vue\n\nFor display, add a new component to `App.vue`\n\n`src/App.vue`\n```js\n<template>\n...OTHER_CODE...\n\n  <div>\n    <div class="tabs">\n      <button\n        @click="tab = \'datalog\'"\n        :class="{ active: tab === \'datalog\' }"\n      >\n        datalog\n      </button>\n      <button\n        @click="tab = \'launch\'"\n        :class="{ active: tab === \'launch\' }"\n      >\n        launch\n      </button>\n    </div>\n    <Datalog v-if="tab === \'datalog\'" :api="api" :account="account" />\n    <Launch v-if="tab === \'launch\'" :api="api" :account="account" />\n  </div>\n\n...OTHER_CODE...\n</template>\n\n...OTHER_CODE...\n\n<script>\nimport Datalog from "./components/Datalog";\nimport Launch from "./components/Launch";\n\n...OTHER_CODE...\n\ncomponents: {\n  Datalog,\n  Launch\n},\n\n...OTHER_CODE...\n```\n\nRun app\n\n```sh\nyarn serve\n```\n\nWay 2:\n\nIf you start the application with cloning the repository, then to complete these steps, you will just need to switch to step 5.\n\n```sh\ngit checkout step-5\nyarn serve\n```\n\nAs a result we will get this picture in the browser\n\n![screen4](../images/build-iot-dapps/screen4.png)\n\n### Step 6. Demo\n\nIn this demo, we will have a car that can be started and stopped through the dApp. The car collects a log during the trip, and after stopping, saves it to the chain. Here we will use both modules, which we tried separately, in conjunction.\n\nTo emulate the behavior of a robot (car), we will write a Robot class. We will use the `Alice` key as an account for this robot. The `Robot` class will watch for `NewLaunch` events to turn itself on and off. After turning on, it starts collecting data into the log, in terms of data it will be just a timestamp. And after shutdown, it saves this log to the `datalog` module.\n\nWay 1:\n\nCreate file `src/utils/robot.js`. The full code of the file https://github.com/airalab/example-robonomics-dapp/blob/master/src/utils/robot.js\n\nFor visualization, we will create a `Demo.vue` component, where we will have a start button, car animation and log output.\n\n`src/components/Demo.vue`\n```js\n<template>\n  <div>\n    <h2>Demo</h2>\n    <template v-if="robot">\n      <h3>Robot: {{ robot.address }}</h3>\n      <p v-if="robot.state">Driver: {{ robot.driver }}</p>\n      <button @click="run" :disabled="isWrite">\n        <template v-if="!robot.state">run</template>\n        <template v-else>stop</template>\n      </button>\n      <div class="road">\n        <div\n          class="robot"\n          :class="[robot.state ? \'robot-play\' : \'robot-stop\']"\n        ></div>\n      </div>\n      <div v-if="error" class="error">{{ error }}</div>\n      <div v-if="log" class="log">\n        <p v-if="log.length === 0" class="error">Not found</p>\n        <div v-for="(item, k) in log" :key="k" class="row">\n          <b>{{ item[0] | dateFormat }}</b>\n          <pre>{{ item[1] | dataFormat }}</pre>\n        </div>\n      </div>\n    </template>\n  </div>\n</template>\n\n...OTHER_CODE...\n\n<style scoped>\n.log {\n  border: 1px solid #eee;\n  text-align: left;\n  width: 800px;\n  margin: 20px auto;\n  height: 500px;\n  overflow-y: auto;\n}\n.log .row {\n  margin: 10px;\n  border-bottom: 1px solid #eee;\n}\n.road {\n  width: 1000px;\n  margin: 20px auto;\n  background-color: #eee;\n  padding: 20px 0;\n  border: 5px solid #a5a5a5;\n  border-left: 0;\n  border-right: 0;\n  position: relative;\n}\n.road::before {\n  content: " ";\n  width: 1000px;\n  border-top: 5px dashed #a5a5a5;\n  position: absolute;\n  top: 50%;\n  left: 0;\n}\n@keyframes move {\n  from {\n    transform: translateX(0);\n  }\n  to {\n    transform: translateX(100%);\n  }\n}\n.robot {\n  height: 100px;\n  width: 100px;\n  color: #fff;\n  font-weight: bold;\n  font-style: 14px;\n  animation: move 30s linear infinite;\n  border-radius: 0 10px 10px 0;\n  background: url("../images/build-iot-dapps/car.png") no-repeat 0 0;\n  background-size: cover;\n}\n.robot-play {\n  animation-play-state: running;\n}\n.robot-stop {\n  animation-play-state: paused;\n}\n</style>\n```\n\nComponent code. Here we need to create an instance of the `Robot` class and a launch/stop function.\n\n`src/components/Demo.vue`\n```js\n...OTHER_CODE...\n\n<script>\nimport { u8aToString } from "@polkadot/util";\nimport Robot from "../utils/robot";\n\nexport default {\n  props: ["api", "account"],\n  data() {\n    return {\n      isWrite: false,\n      error: "",\n      robot: null,\n      log: []\n    };\n  },\n  filters: {\n    dateFormat: function(v) {\n      return new Date(Number(v)).toLocaleString();\n    },\n    dataFormat: function(v) {\n      return JSON.parse(u8aToString(v));\n    }\n  },\n  async created() {\n    this.robot = new Robot("//Alice", this.api);\n    await this.robot.subscribeLog(r => {\n      this.log = r.reverse().map(item => {\n        return [item[0], item[1]];\n      });\n    });\n  },\n  destroyed() {\n    this.robot.destroy();\n  },\n  methods: {\n    async run() {\n      try {\n        this.error = "";\n        this.isWrite = true;\n        const tx = await this.api.tx.launch\n          .launch(this.robot.account.address, !this.robot.state)\n          .signAsync(this.account);\n        await tx.send(result => {\n          if (result.status.isInBlock) {\n            this.isWrite = false;\n          }\n        });\n      } catch (error) {\n        this.error = error.message;\n        this.isWrite = false;\n      }\n    }\n  }\n};\n<\/script>\n\n...OTHER_CODE...\n```\n\nhttps://github.com/airalab/example-robonomics-dapp/blob/master/src/components/Demo.vue\n\nLet\'s add another picture of our car to `src/images/build-iot-dapps/car.png`. Example https://github.com/airalab/example-robonomics-dapp/blob/master/src/images/build-iot-dapps/car.png.\n\nFor display, add a new component to `App.vue`\n\n`src/App.vue`\n```js\n<template>\n\n...OTHER_CODE...\n\n  <div>\n    <div class="tabs">\n      <button\n        @click="tab = \'datalog\'"\n        :class="{ active: tab === \'datalog\' }"\n      >\n        datalog\n      </button>\n      <button\n        @click="tab = \'launch\'"\n        :class="{ active: tab === \'launch\' }"\n      >\n        launch\n      </button>\n      <button @click="tab = \'demo\'" :class="{ active: tab === \'demo\' }">\n        demo\n      </button>\n    </div>\n    <Datalog v-if="tab === \'datalog\'" :api="api" :account="account" />\n    <Launch v-if="tab === \'launch\'" :api="api" :account="account" />\n    <Demo v-if="tab === \'demo\'" :api="api" :account="account" />\n  </div>\n\n...OTHER_CODE...\n\n</template>\n\n...OTHER_CODE...\n\n<script>\nimport Datalog from "./components/Datalog";\nimport Launch from "./components/Launch";\nimport Demo from "./components/Demo";\n\n...OTHER_CODE...\n\ncomponents: {\n  Datalog,\n  Launch,\n  Demo\n},\n\n...OTHER_CODE...\n```\n\nRun app\n\n```sh\nyarn serve\n```\n\nWay 2:\n\nIf you start the application with cloning the repository, then to complete these steps, you will just need to switch to step 6.\n\n```sh\ngit checkout step-6\nyarn serve\n```\n\nAs a result we will get this picture in the browser\n\n![screen5](../images/build-iot-dapps/screen5.png)\n\nThis concludes our lesson.\n\nThanks!\n'}},{node:{id:"f5c94a3b79e2681c5a9b28f59ae56ea8",title:"How to participate in the Wiki translation",path:"/docs/en/translate-wiki/",content:'\nEveryone can contribute to Robonomics. If you want to contribute to the translation of the documentation, you are on the right track: this article will tell you how to do it.\n\n## Editing an article\n\nIf support for your language has already been added to the site, follow these steps:\n\n1. Click the "Edit this page" button on the article you would like to translate. Each article is duplicated in a supported language, even if it has not yet been translated from English.\n2. Edit by sticking to the existing markup. You can read the article [How to edit WIKI](/docs/en/edit-wiki)\n3. Submit [PR](https://docs.github.com/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request) with the changes you have made.\n\n## Adding a new language\n\nIf the language you would like to translate the article into has not yet been added, request it from the Robonomics root team by, [creating Issue](https://docs.github.com/desktop/contributing-and-collaborating-using-github-desktop/creating-an-issue-or-pull-request) on GitHub.\n\nWhen we add support for the requested language to the site, we will close the Issue, commenting on it if necessary. You will be notified accordingly. This means you can translate pages (they will already be duplicated in English in a folder like `/docs/locale`)\n\n## Notes\n* If you see a way to improve an existing translation of an article, you can also use the PR or Issue on GitHub to request changes\n* If you make a significant contribution to the translation, you can participate in the rewards program\n'}},{node:{id:"de9266e0d2cb91c49357ebe4b387d950",title:"Sensors Connectivity",path:"/docs/en/sensors-connectivity/",content:'\nThis Aira package allows you to read data from a SDS011 sensor and publish to different output channels. That said Aira is able to form a json formatted message with measurements and publish to a few channels. Also it includes Datalog feature which is still experimental. It could be used to publish data to Substrate based blockchain by Robonomics.\n\nThe last release is [Sensors Connectivity v0.2](https://github.com/airalab/sensors-connectivity/releases/tag/v0.2)\n\n## Sensor Connectivity Protocol :: v1\n\n### Sensor to Station\n\n**TCP Session diagram**\n\n| HEADER | DATA1 | DATA2 | DATA3 | ... | DATAN |\n|--------|-------|-------|-------|-----|-------|\n\nwhere `HEADER` is 34 bytes\n\n|      | Name      |\n|------|-----------|\n| 0x00 | public_id |\n| 0x20 | codec_id  |\n\n* `public_id` - Public identifier, generated on sensor setup.\n* `codec_id` - Type of used data codec.\n\n**Data frame**\n\n|      | Name      |\n|------|-----------|\n| 0x22 | payload   |\n| 0xNN | signature |\n\n\n* `payload` - Sensor measurements.\n* `signature` - Measurement Ed25519 signature, 64 bytes long. ([pynacl](https://github.com/pyca/pynacl))\n\nFor SDS011 sensor `payload` consists of 4 float numbers: PM2.5, PM10, GEO_LAT, GEO_LON\n\n### Station to Robonomics\n\nThe default output channel is Robonomics protocol over IPFS pubsub. For every measurement connectivity produces the following json formatted string:\n\n```\n{public_id: {"model": codec_id,"timestamp": unix_timestamp, "measurement": {"pm25": PM2.5, "pm10": PM10, "geo": "GEO_LAT,GEO_LON"}}}\n```\n\n## Stations and Feeders\n\nIn Sensors Connectivity there are two entities: station and feeder.\n\n### Station\n\nStation represents a source of data. The package can handle many inputs simultaneously:\n\n```\nstation1 \\                        / output1\nstation2 -  sensors-connectivity  - output2\nstation3 /                        \\ output3\n```\n\nThere are COM Station and TCP Station implemented. The first one reads data from a sensor that is connected to a serial port. TCP Station starts a tcp server and listens to incoming connections. \n\nTCP Station can accept data from every sensor or you can specify an access control list (ACL) for known sensors only.\n\n### Feeder\n\nFeeder is an output in terms of sensors connectivity:\n\n```\ninput1 \\                        / feeder1\ninput2 -  sensors-connectivity  - feeder2\ninput3 /                        \\ feeder3\n```\n\nAt current implementation the package can publish data to [Luftdaten](https://meine.luftdaten.info/), Robonomics or Robonomics on Substrate (using Datalog feature).\n\n## Connectivity Configuration\n\nThe package is highly configurable. The default configuration file looks like:\n\n```yaml\n# Please DO NOT edit this file\n# Make a copy instead, make changes and pass the absolute path to the copy in arguments\ngeneral:\n  publish_interval: 300 # time between two published messages\ncomstation:\n  port: "/dev/ttyUSB0"  # COM port of the device\n  work_period: 300      # time between two measurements in seconds\n  geo: ""               # Geo coordinates as latitude,longitude\n  public_key: ""        # If not provided, COMStation creates itself\ntcpstation:\n  address: ""           # IP and PORT to listen to, for example 0.0.0.0:31313\n  acl:                  # list of known addresses. If not specified accepts from everyone\n  # -\n  # -\nluftdaten:\n  enable: true          # whether or not publish to https://luftdaten.info/\nrobonomics:\n  enable: true          # enable use of Robonomics Network\n  ipfs_provider: ""     # ipfs endpoint\n  ipfs_topic: "airalab.lighthouse.5.robonomics.eth"\ndatalog:\n  enable: false         # enable use of Datalog Robonomics subcommand\n  path: ""              # path to Robonomics execution file\n  suri: ""              # private key of publisher account\n  remote: "wss://substrate.ipci.io"\n  dump_interval: 3600   # time between two transactions in seconds\n  temporal_username:    # set to pin files in Temporal.Cloud\n  temporal_password:\ndev:\n  sentry: ""\n```\n\nTo get familiar with all the options and launch scenarios check the [README.md](https://github.com/airalab/sensors-connectivity/tree/v0.2) out.\n\n'}},{node:{id:"1fc1dc2dbf767f7998053575aa8cf958",title:"Install Sensors Connectivity on Your Own Aira",path:"/docs/en/sensors-connectivity-on-aira/",content:'\n## Prerequirements\n\nYou must have an AIRA instance somewhere\n\n## Install the Package\n\n```\ngit clone https://github.com/airalab/sensors-connectivity\ncd sensors-connectivity\nnix build -f release.nix\n```\n\nFrom this point you can run the package with the default configuration file or create a systemd service to launch it automatically\n\n### Edit Configuration File\n\nAssuming you are in the package root directory edit the file:\n```\ncp config/default.json config/my.json\nvim config/my.json\n```\n\nExtended description of options is located [here](/docs/configuration-options-description)\n\n### Run Manually\n\nFrom the package directory:\n\n```\nsource result/setup.zsh\nroslaunch sensors_connectivity agent.launch config:=/root/sensors-connectivity/config/my.json\n```\n\n### Run via systemd\n\nAdd the following to `/etc/nixos/configuration.nix`:\n\n```\nsystemd.services.connectivity = {\n  requires = [ "roscore.service" ];\n  after = ["roscore.service" ];\n  wantedBy = [ "multi-user.target" ];\n  environment.ROS_MASTER_URI =  "http://localhost:11311";\n  script = \'\'\n    source /root/sensors-connectivity/result/setup.bash && roslaunch sensors_connectivity agent.launch config:=/root/sensors-connectivity/config/my.json\n  \'\';\n  serviceConfig = {\n    Restart = "on-failure";\n    StartLimitInterval = 0;\n    RestartSec = 60;\n    User = "root";\n  };\n};\n```\n\nThen\n\n```\nnixos-rebuild switch\n```\n\nRunning\n\n```\nsystemctl start connectivity.service\n```\n\n'}},{node:{id:"2d49e0624e276ebb84f44de715aec0bb",title:"Securely connect cloud AI to the factory floor",path:"/docs/en/securely-connect-cloud-ai-to-the-factory-floor/",content:"\nRobonomics technologies can already solve the challenges that Industry 4.0 faces and they are already applied to real-world scenarios in the industrial environment.\n\nA large number of AI companies are building solutions to optimize the processes on the factory floor, allowing plants to produce more with less cost. However, most plants are hesitant to connect their infrastructure to the cloud directly since this results in potential cybersecurity risks, which could lead to million-dollar losses and even the loss of human life.\n\n[MerkleBot](https://merklebot.com) has used [Robonomics Network](https://robonomics.network) to build a solution for industrial clients to connect their factory to the cloud-based AI in a secure way.\n\nThis article is written in the wake of an experiment we conducted with [Veracity Protocol](https://www.veracityprotocol.org/) that uses algorithms to create non-invasive protection of any physical item based on the photographs from a mobile device.\n\nThis use case shows the process of scanning the industrial parts using a robotic arm.\n\n[Demo video](https://youtu.be/8AL70LFVX5w)\n\n## Step-by-step process\n\n### DApp as user interface\n\n![](../images/google-play-store.gif)\n\nDApp acts as a user interface for the operator. It is used to request the launch of the robot to collect the photographs and its purpose is to allow secure communication between the factory environment and cloud-based AI.\n\n### Launching the robot\n\n![](../images/Veracity_Protocol_Transaction.gif)\n\nThe operator launches the robotic scan by signing the transaction in the DApp. This step guarantees that the process on the factory floor can only start based on the transaction in the public blockchain.\n\nThe robot receives a command from the blockchain through the Robonomics Network and begins the scan. Robonomics Network technologies allow us to close the gap between the business objective and robotics operation.\n\n### Data collection and sending to cloud-based AI\n\nIn the DApp the operator sees the confirmation and the robot begins to scan the items placed on the table, such as in this use case, or on the factory line directly if the need arises.\n\n![](../images/Veracity_Protocol_Launch.gif)\n\nWhen the robot collects the data, it stores it locally and makes it available to cloud-based AI through IPFS protocol. By encrypting the data and organizing the data exchange through a blockchain transaction as well, we can authorize access to cloud-based AI while making sure that the data remains secure and in place.\n\nThe security mechanism built into Robonomics based on the shared security of public blockchains allows gaining the level of security that is prohibitively expensive for most factories to organize on their own.\n\n### Digital passport creation\n\nWhen the cloud-based AI analyses the data, the log file and recommendations are recorded as a [Digital Passport](https://wiki.robonomics.network/docs/create-digital-identity-run-by-ethereum/) automatically. Every operation and scan can be traced back since the blockchain record has the hash to all these files through IPFS protocol.\n\n## Comments about the use case\n\nIn this use case, Universal Robot UR3 industrial arm was used. But thanks to Robonomics support for ROS, most major industrial manipulators can be used and connected to cloud-based AI securely, including KUKA, Fanuc, and Yaskawa.\n\nIf you are interested to learn more about the deployment and integration of cloud-based AI instruments securely please [reach out](mailto:v@merklebot.com)\n"}},{node:{id:"3076c8d4aa1150ab281a796b0573acd5",title:"Manual start of the Robonomics network, consisting of 3 nodes",path:"/docs/en/robonomics-test-network-manual/",content:'\n**Need to start Robonomics network of N (N> = 2) nodes**\n\n## Requirements\n- Robonomics binary, download latest here: https://github.com/airalab/robonomics/releases/\n- Subkey tool, download latest here: https://github.com/airalab/robonomics/releases/\n- 3 servers with root shell. Their ip-addresses in the current instruction will be `165.227.171.127`, `159.89.25.75` and `159.89.30.50`\n\n## Introduction\nIn this tutorial, we will first create all key files locally, and then upload them to their corresponding nodes. \n\n## Prepare directories\nDownload 2 archives from the links above and open the folder with them in the terminal.\nThen create a directory for the project, unpack the archives into it and go to the created folder:\n```\n$ mkdir robonomics_test_network\n$ tar -xf ./robonomics-ubuntu-0.21.0-x86_64.tar.xz -C ./robonomics_test_network/\n$ tar -xf ./subkey-ubuntu-0.21.0-x86_64.tar.xz -C ./robonomics_test_network/\n$ cd ./robonomics_test_network/\n```\n\nNext, create a separate **uploads** directory and the necessary subdirectories for each server. All files intended for uploading to a specific server will be stored in these subdirectories:\n```\n$ mkdir -p uploads/165.227.171.127/keystore && mkdir -p uploads/165.227.171.127/network\n$ mkdir -p uploads/159.89.25.75/keystore && mkdir -p uploads/159.89.25.75/network\n$ mkdir -p uploads/159.89.30.50/keystore && mkdir -p uploads/159.89.30.50/network\n```\n\nAlso, create a **local** folder with **validators** and **sudo** folders, which will store the validators and sudo keys locally.\n```\n$ mkdir -p local/validators && mkdir -p local/sudo\n```\n\n## Prepare spec.json\nUsing the robonomics binary, generate a **spec.json** file, which will use as the basis:\n```\n$ ./robonomics build-spec --chain dev > uploads/spec.json\n```\n\nNext, edit this file. At first correct the first three fields, make them look like this:\n```\n"name": "Test Robonomics Network",\n"id": "dev",\n"chainType": "Live",\n```\n\n### bootNodes\nThe **bootNodes** field is a list of strings of special format. For each of the bootnodes must write the corresponding string here.\nTo do this, first create a key file for each bootnode using **subkey**:\n```\n$ ./subkey generate-node-key uploads/165.227.171.127/network/secret_ed25519  \n12D3KooWBPq1fDLQC2iqQ4FpM2mUpiXjBRcb8ptk7tbaqr2B6HZN\n$ ./subkey generate-node-key uploads/159.89.25.75/network/secret_ed25519\n12D3KooWRbGmdpbz6o1fe66wFs7nJsUYfBp2f3W7J1uDXj3gt4Bh\n$ ./subkey generate-node-key uploads/159.89.30.50/network/secret_ed25519\n12D3KooWMuTrL9CmJxj8LjH43s4hsJMsyuMdbuB86zCaAf9VCwFf\n```\n\nEach command creates a key file in the specified directory and outputs to stdout the string that will be needed to fill in the **bootNodes** field in the **spec.json** file. As a result, the **bootNodes** section should look like following example:\n```\n"bootNodes": [\n"/ip4/165.227.171.127/tcp/30333/p2p/12D3KooWBPq1fDLQC2iqQ4FpM2mUpiXjBRcb8ptk7tbaqr2B6HZN",\n"/ip4/159.89.25.75/tcp/30333/p2p/12D3KooWRbGmdpbz6o1fe66wFs7nJsUYfBp2f3W7J1uDXj3gt4Bh",\n"/ip4/159.89.30.50/tcp/30333/p2p/12D3KooWMuTrL9CmJxj8LjH43s4hsJMsyuMdbuB86zCaAf9VCwFf"\n],\n```\nThe next 3 fields (telemetryEndpoints, protocolId, properties) can be filled like this:\n```\n "telemetryEndpoints": [\n     [\n       "/dns4/telemetry.polkadot.io/tcp/443/x-parity-wss/%2Fsubmit%2F",\n       0\n     ]\n ],\n"protocolId": "txrt",\n"properties": {\n    "ss58Format": 32,\n    "tokenDecimals": 9,\n    "tokenSymbol": "TXRT"\n},\n```\nFurther up to the **palletBalances** field leave unchanged.\n\n\n### palletBalances\nTo fill the palletBalances field create **the number of nodes + 1** (the last key is for **sudo**) keys. This can be done using **subkey**, in the file name must specify **SS58 Address** from the generated key, in the file content must specify **seed** phrase in quotes. \n\nExample creating one key.\n - Generate key:\n    ```\n    $ ./subkey -n robonomics generate\n    Secret phrase `display cargo domain april joy still bundle notice bridge pencil fat approve` is account:\n      Network ID/version: substrate\n      Secret seed:        0x0275ab9bce53e4359184f02112943162c708f483009e0b7b3ba63549c5c2e514\n      Public key (hex):   0xd0996b85dd1b2876080b26123f9c27097d698f871c5978c3cb9c299253e7a530\n      Account ID:         0xd0996b85dd1b2876080b26123f9c27097d698f871c5978c3cb9c299253e7a530\n      SS58 Address:       4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx\n    ```\n - Create key file:\n    ```\n    $ touch ./local/validators/4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx && echo \'"display cargo domain april joy still bundle notice bridge pencil fat approve"\' | tee ./local/validators/4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx\n    ```\n  \nCommand template for creating a validator key file:  \n`touch ./local/validators/**SS58_Address** && echo \'"**seed**"\' | tee ./local/validators/**SS58_Address**`\n\nCommand template for creating a sudo key file:   \n`touch ./local/sudo/**SS58_Address** && echo \'"**seed**"\' | tee ./local/sudo/**SS58_Address**`\n\nThree keys are stored in the **local/validators** folder and one in the **local/sudo** folder. As a result, the following content should appear in the **local** directory:\n```\n./local/\n├── sudo\n│   └── 4Dy6bzrvoApwjLaAjfrtvtX3tthCw6fnCU1Ym5KNyRGt3kKb\n└── validators\n    ├── 4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx\n    ├── 4EeMi84pk5P5nQpyupQeCZ1C4NhUFtMF7Xh1MXJLANkZ3BTd\n    └── 4FPRYfSVqwaX39vXZ78tT3DPBT9FmFXvdQDD7y5UQKncJGu1\n```\n\nNow fill the palletBalances section in the spec.json file with these keys.\nAs a result, it should look like this:\n```\n"palletBalances": {\n  "balances": [\n    [\n      "4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx",    <-- Generated validator 1 key\n      1000000000000000000\n    ],\n    [\n      "4EeMi84pk5P5nQpyupQeCZ1C4NhUFtMF7Xh1MXJLANkZ3BTd",    <-- Generated validator 2 key\n      1000000000000000000\n    ],\n    [\n      "4FPRYfSVqwaX39vXZ78tT3DPBT9FmFXvdQDD7y5UQKncJGu1",    <-- Generated validator 3 key\n      1000000000000000000\n    ],\n    [\n      "4Dy6bzrvoApwjLaAjfrtvtX3tthCw6fnCU1Ym5KNyRGt3kKb",    <-- Generated sudo key\n      1000000000000000000\n    ],\n  ]\n},\n```\nThe values that were previously presented in the palletBalances section must be deleted.\n\n### palletSession\nNext step is the **palletSession** section in file **spec.json**. First let\'s describe its format. \nThis section contains the "keys" field, that contains a list of three lists (equals of nodes count). Each of these lists looks like follows:\n```\n[\n    "%validator_SS58_address%",\n    "%validator_SS58_address%",\n    {\n        "babe": "%sr25519_babe_SS58_address%",\n        "im_online": "%sr25519_im_online_SS58_address%"\n        "authority_discovery": "%sr25519_authority_discovery_SS58_address%",\n        "grandpa": "%ed25519_grandpa_SS58_address%",\n    }\n]\n```\n**%validator_SS58_address%** is the validator key that was generated for each node in the **palletBalances** section of this manual. Just copy it twice for each node.\n\nTo fill in the remaining 4 lines for each node, you need to create 4 key files for each node and store them in the **keystore** folders.\nAs key files are generated, you can fill **palletSession**.\n\nEach key file must contain a **seed** phrase in quotes.\nMaking of the name of each key file require separate consideration.\nThe name of each key file is formed as **prefix** + **account_id without leading hexadecimal zero**.\n\nPrefixes matching:  \n>      grandpa: \'6772616e\'  \n>      babe: \'62616265\'\n>      im_online: \'696d6f6e\'  \n>      authority_discovery: \'61756469\'  \n\nAn example of creating keys for one node:\n- Creating a **babe** (prefix *62616265*) key file.   \n  ```\n  $ ./subkey --sr25519 -n robonomics generate\n  ```\n  >  Secret phrase **cover once garment syrup income chair elder business diary frozen rack damage** is account:  \n  >\n  >  Network ID/version: `substrate`\n  >\n  >  Secret seed:        `0x90ddeee3a9a0c464572021d311c245eefc41f9a59c739faefda47efcf4755677`\n  >\n  >  Public key (hex):   `0xfa44d96e310cf68350dd855c745794f7c1afa63089ebdb2c96bff3797972bb43`\n  >\n  >  Account ID:         `0xfa44d96e310cf68350dd855c745794f7c1afa63089ebdb2c96bff3797972bb43`\n  > \n  >  SS58 Address:       `4HirHF5BVHxkRBtqptFxBSmnAiZir1qQLs6pL9Utmm4eF77C`\n  \n ```\n $ touch uploads/165.227.171.127/keystore/62616265fa44d96e310cf68350dd855c745794f7c1afa63089ebdb2c96bff3797972bb43 && echo \'"cover once garment syrup income chair elder business diary frozen rack damage"\' | tee ./uploads/165.227.171.127/keystore/62616265fa44d96e310cf68350dd855c745794f7c1afa63089ebdb2c96bff3797972bb43 \n ```\n This command creates a **babe** key file for the `165.227.171.127` node. To fill in **spec.json**, need to take from this output the value **SS58 Address**: `4HirHF5BVHxkRBtqptFxBSmnAiZir1qQLs6pL9Utmm4eF77C`. This address need to insert instead of `%sr25519_babe_SS58_address%` in the above **palletSession** template.\n   \n **babe** key file creation command template:  \n`touch ./uploads/[node_ip]/keystore/62616265+[Account_ID] && echo \'"[seed]"\' | tee ./uploads/[node_ip]/keystore/62616265+[Account_ID]`  \n\nAs you can see, the name of the babe key file is the sum of two substrings: `babe prefix (\'62616265\')`, and the `account_id` of the generated key, without the leading zero (`fa44d96e310cf68350dd855c745794f7c1afa63089ebdb2c96bff3797972bb43`). \n  Note that the keys `babe, im_online, authority_discovery` are generated with the indication `--sr25519`.  \n  **grandpa** key have to generate with the indication `--ed25519`.\n \n\n- Creating an **im_online** (prefix *696d6f6e*) key file.  \n  ```\n  $ ./subkey --sr25519 -n robonomics generate\n  ```\n  > Secret phrase **envelope truly balance turkey undo casual waste skill average ordinary gun split** is account:\n  >\n  >   Network ID/version: `substrate`\n  > \n  >   Secret seed:        `0x8a19df08feeff9f1fa3581902ca22a305252aea32e284d32f10e990d00bb8926`\n  > \n  >   Public key (hex):   `0x6c13ff8e37d91b80fe3b03f9b92a91a1ef7db741434cf12cc44d5ed29257ab09`\n  >  \n  >   Account ID:         `0x6c13ff8e37d91b80fe3b03f9b92a91a1ef7db741434cf12cc44d5ed29257ab09`\n  >  \n  >   SS58 Address:       `4EWQyBRoucH4Wjd4JtGoSEYYCw4bbkonjoFy9hNUX5fbmMEt`\n   \n  ```\n  $ touch uploads/165.227.171.127/keystore/696d6f6e6c13ff8e37d91b80fe3b03f9b92a91a1ef7db741434cf12cc44d5ed29257ab09 && echo \'"envelope truly balance turkey undo casual waste skill average ordinary gun split"\' | tee uploads/165.227.171.127/keystore/696d6f6e6c13ff8e37d91b80fe3b03f9b92a91a1ef7db741434cf12cc44d5ed29257ab09\n  ```\n  **im_online** key file creation command template:  \n  `touch ./uploads/[node_ip]/keystore/696d6f6e+[Account_ID] && echo \'"[seed]"\' | tee ./uploads/[node_ip]/keystore/696d6f6e+[Account_ID]`\n  \n  **spec.json**: `4EWQyBRoucH4Wjd4JtGoSEYYCw4bbkonjoFy9hNUX5fbmMEt` need to insert instead of `%sr25519_im_online_SS58_address%` in the above **palletSession** template.\n\n\n- Creating an **authority_discovery** (prefix *61756469*) key file.\n   ```\n   $ ./subkey --sr25519 -n robonomics generate\n   ```\n   > Secret phrase **boy harsh because omit equip atom apart spring undo explain walnut crystal** is account:\n   >\n   > Network ID/version: `substrate`\n   >\n   >   Secret seed:        `0x27838c9ea0524353da3717862ef0ecef123f40e81b73bb5ef377d12b47d1c543`\n   > \n   >   Public key (hex):   `0x4e33ccfd4105d30dfd93c5ef4658e2585a749508ea7c7abe754efc36dd634c07`\n   > \n   >   Account ID:         `0x4e33ccfd4105d30dfd93c5ef4658e2585a749508ea7c7abe754efc36dd634c07`\n   >  \n   >   SS58 Address:       `4DqEyoefRSz746sjaonxJ7KZQz8MUq4cKFA87DfoLzQgWk8t`\n   \n   ```\n   $ touch uploads/165.227.171.127/keystore/617564694e33ccfd4105d30dfd93c5ef4658e2585a749508ea7c7abe754efc36dd634c07 && echo \'"boy harsh because omit equip atom apart spring undo explain walnut crystal"\' | tee uploads/165.227.171.127/keystore/617564694e33ccfd4105d30dfd93c5ef4658e2585a749508ea7c7abe754efc36dd634c07\n   ```\n  **authority_discovery** key file creation command template:  \n  `touch ./uploads/[node_ip]/keystore/61756469+[Account_ID] && echo \'"[seed]"\' | tee ./uploads/[node_ip]/keystore/61756469+[Account_ID]` \n  \n   **spec.json**: `4DqEyoefRSz746sjaonxJ7KZQz8MUq4cKFA87DfoLzQgWk8t` need to insert instead of `%sr25519_authority_discovery_SS58_address%` in the above **palletSession** template.\n\n\n- Creating a **grandpa** (prefix *6772616e*) key file.\n   ```\n   $ ./subkey --ed25519 -n robonomics generate\n   ```\n   > Secret phrase **squeeze nature off vendor comic pause tattoo seek omit spatial regular cattle** is account:\n   > \n   >   Network ID/version: `substrate`\n   >\n   >   Secret seed:        `0xef0a9f51a4da7b789c0a25d39b44428d4da7262cc3fe013d4383b45216e8b83e`\n   >  \n   >   Public key (hex):   `0x7ea1beed13fb66a333b50b1ae417ebfd152bab99b223be2d4d886adb5fa7f009`\n   >  \n   >   Account ID:         `0x7ea1beed13fb66a333b50b1ae417ebfd152bab99b223be2d4d886adb5fa7f009`\n   > \n   >   SS58 Address:       `4EvjwRdgUg6YtdUDjq6Z3PoTKtzH5cgFgwnzArMSbw3RzYTa`\n    \n   ```\n   $ touch uploads/165.227.171.127/keystore/6772616e7ea1beed13fb66a333b50b1ae417ebfd152bab99b223be2d4d886adb5fa7f009 && echo \'"squeeze nature off vendor comic pause tattoo seek omit spatial regular cattle"\' | tee uploads/165.227.171.127/keystore/6772616e7ea1beed13fb66a333b50b1ae417ebfd152bab99b223be2d4d886adb5fa7f009\n   ```\n   **grandpa** key file creation command template:  \n  `touch ./uploads/[node_ip]/keystore/6772616e+[Account_ID] && echo \'"[seed]"\' | tee ./uploads/[node_ip]/keystore/6772616e+[Account_ID]`\n   \n   **spec.json**: `4EvjwRdgUg6YtdUDjq6Z3PoTKtzH5cgFgwnzArMSbw3RzYTa` need to insert instead of `%sr25519_grandpa_SS58_address%` in the above **palletSession** template.\n   \n   \n**Now 4 key files have been created for one node. Need to repeat this actions for the remaining two nodes.**\n\nYou should get the following **uploads** directory structure after creating all the keys:\n```\n./uploads/\n├── 165.227.171.127\n│   ├── keystore\n│   │   ├── 617564694e33ccfd4105d30dfd93c5ef4658e2585a749508ea7c7abe754efc36dd634c07\n│   │   ├── 62616265fa44d96e310cf68350dd855c745794f7c1afa63089ebdb2c96bff3797972bb43\n│   │   ├── 6772616e7ea1beed13fb66a333b50b1ae417ebfd152bab99b223be2d4d886adb5fa7f009\n│   │   └── 696d6f6e6c13ff8e37d91b80fe3b03f9b92a91a1ef7db741434cf12cc44d5ed29257ab09\n│   └── network\n│       └── secret_ed25519\n├── 159.89.25.75\n│   ├── keystore\n│   │   ├── 617564692ac9bd30c0168fa623cfd66abb4327992d900a652bcbb238b740bdde497a565f\n│   │   ├── 626162657cd666bb540c41cb33896a34d7413ffb86fcef1eddddfcd4edb325166df6335d\n│   │   ├── 6772616e084402349bc08ef90c2837e8e3f12ebe8bd4ab86809e9ee5f4f8ca26e73a0518\n│   │   └── 696d6f6e6ed2d507c0283ae869ba6514975bd8765eb8e06abd22afc09e8f36ef3950a116\n│   └── network\n│       └── secret_ed25519\n└── 159.89.30.50\n|   ├── keystore\n|   │   ├── 61756469f20a4e16a0ee79431d6f9a70c38892c7532ad1347c2226d43ef6ffe8966e9b30\n|   │   ├── 62616265e695aa459dbfd42bea7ed3b87970f164f34b6fee4d5a831ffbecd89eb9769b26\n|   │   ├── 6772616eadef59f896ea6b94bcd4519be8cc4b70263fc318cec1a3be14850bbc22117c34\n|   │   └── 696d6f6e2cb4dc8f8a67f477da15045ca40ef3861a2a6b2034ae0c64a179b4431341ea2c\n|   └── network\n|       └── secret_ed25519\n└── spec.json\n```\n\nThe palletSession section should look like this:\n```\n"palletSession": {\n    "keys": [\n        [\n            "4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx",    <-- Validator 1 SS58 Address\n            "4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx",    <-- Validator 1 SS58 Address\n            {\n                "authority_discovery": "4DqEyoefRSz746sjaonxJ7KZQz8MUq4cKFA87DfoLzQgWk8t",\n                "babe": "4HirHF5BVHxkRBtqptFxBSmnAiZir1qQLs6pL9Utmm4eF77C",\n                "grandpa": "4EvjwRdgUg6YtdUDjq6Z3PoTKtzH5cgFgwnzArMSbw3RzYTa",\n                "im_online": "4EWQyBRoucH4Wjd4JtGoSEYYCw4bbkonjoFy9hNUX5fbmMEt"\n            }\n        ],\n        [\n            "4EeMi84pk5P5nQpyupQeCZ1C4NhUFtMF7Xh1MXJLANkZ3BTd",    <-- Validator 2 SS58 Address\n            "4EeMi84pk5P5nQpyupQeCZ1C4NhUFtMF7Xh1MXJLANkZ3BTd",    <-- Validator 2 SS58 Address\n            {\n                "authority_discovery": "4F6daoG2gBXRLvbT4mVRajExZdZBHH7APmX3wDuLYJyzxHSS",\n                "babe": "4C7vBVHUYKqApCywqGsuap6XhjZ3gdYnW4YYP2mMyvYctLqT",\n                "grandpa": "4G3Ai6BGUjqtCoM2aTvWyR19gQ8WZiNnh1KFM47RyiYTwkE6",\n                "im_online": "4FHA7gzKfSLvd8jP85JUCWV6RyeRLm331KHcjnynGx7TWm7D"\n            }\n        ],\n        [\n            "4FPRYfSVqwaX39vXZ78tT3DPBT9FmFXvdQDD7y5UQKncJGu1",    <-- Validator 3 SS58 Address                        \n            "4FPRYfSVqwaX39vXZ78tT3DPBT9FmFXvdQDD7y5UQKncJGu1",    <-- Validator 3 SS58 Address\n            {\n                "authority_discovery": "4CqzJFkdSZg52PfV6Fd4gJ3vPLmRu1HGuPvNivjJ8dDWaz1a",\n                "babe": "4EComk8TsrT399xT6MPhGnhbZEif6U6cny8DiyZ3zezo9b5f",\n                "grandpa": "4Cqi4rG3CzWRZairhZX4isT8qG2jyz9fGDXJMrP6uBYkrft5",\n                "im_online": "4C7V6R59cZVbabExqgWvHVE1vj1E1cV42SZr8d8zZD3gmsqk"\n            }\n        ]\n    ]\n},\n```\n\n### palletStaking\n**palletStaking** must be filled in as follows:\n```\n"palletStaking": {\n    "historyDepth": 84,\n    "validatorCount": 10,\n    "minimumValidatorCount": 2,\n    "invulnerables": [\n        "4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx",     <-- Validator 1 SS58 Address\n        "4EeMi84pk5P5nQpyupQeCZ1C4NhUFtMF7Xh1MXJLANkZ3BTd",     <-- Validator 2 SS58 Address\n        "4FPRYfSVqwaX39vXZ78tT3DPBT9FmFXvdQDD7y5UQKncJGu1"      <-- Validator 3 SS58 Address\n    ],\n    "forceEra": "NotForcing",\n    "slashRewardFraction": 100000000,\n    "canceledPayout": 0,\n    "stakers": [\n        [\n            "4CnxYUugEzLQ8Re2d5P2Jso25pe8PBttcVjc3VdNL2V9shVx",  <-- Validator 1 SS58 Address\n            "4HirHF5BVHxkRBtqptFxBSmnAiZir1qQLs6pL9Utmm4eF77C",  <-- Validator 1 babe address\n            1000000,\n            "Validator"\n        ],\n        [\n            "4EeMi84pk5P5nQpyupQeCZ1C4NhUFtMF7Xh1MXJLANkZ3BTd",  <-- Validator 2 SS58 Address\n            "4C7vBVHUYKqApCywqGsuap6XhjZ3gdYnW4YYP2mMyvYctLqT",  <-- Validator 2 babe address\n            1000000,\n            "Validator"\n        ],\n        [\n            "4FPRYfSVqwaX39vXZ78tT3DPBT9FmFXvdQDD7y5UQKncJGu1",   <-- Validator 3 SS58 Address\n            "4EComk8TsrT399xT6MPhGnhbZEif6U6cny8DiyZ3zezo9b5f",   <-- Validator 3 babe address\n            1000000,\n            "Validator"\n        ]\n    ]\n},\n```\nThe example specified in which fields what values should be substituted.\n\n### palletSudo\nIn the rest of the **spec.json** file, you need to change only the contents of **palletSudo**, substituting the previously generated **sudo** address there:\n```\n            "palletBabe": {\n                "authorities": []\n            },\n            "palletGrandpa": {\n                "authorities": []  \n            },\n            "palletImOnline": {\n                "keys": []\n            },\n            "palletAuthorityDiscovery": {\n                "keys": []\n            },\n            "palletTreasury": {},\n            "palletElectionsPhragmen": {\n                "members": []\n            },\n            "palletCollectiveInstance1": {\n                "phantom": null,\n                "members": []\n            },\n            "palletSudo": {\n                "key": "4Dy6bzrvoApwjLaAjfrtvtX3tthCw6fnCU1Ym5KNyRGt3kKb"   <-- sudo address\n            }\n        }\n    }\n}\n```\n\n## systemd unit file\nNow create systemd unit file:\n```\n$ touch ./uploads/robonomics.service\n```\n\nAnd fill it like this:\n```\n[Unit]\nDescription=robonomics\nAfter=network.target\n\n[Service]\nUser=root\nGroup=root\nType=users\nWorkingDirectory=/root\nRestart=on-failure\nExecStart=/usr/bin/robonomics  --chain /etc/substrate/spec.json --name ${HOSTNAME} --validator\n\n[Install]\nWantedBy=multi-user.target\n```\nAs you can see from the "ExecStart" line, the **robonomics** binary is stored in the **/usr/bin/** directory, and the **spec.json** file is stored in the **/etc/substrate/** directory.\n\n## Uploading files\nThe following one-line command uploads all files to the required directories on the servers. It is important that there are no other folders in the **uploads** directory, except for the folders with the ip-addresses of the nodes:\n```\n$ \\\nfor IP in `ls -l ./uploads/ | grep \'^d\' | awk \'{print $9}\'`; do \\\n    ssh root@"$IP" "mkdir -p /root/.local/share/robonomics/chains/dev" && \\\n    scp -r ./uploads/$IP/* root@$IP:/root/.local/share/robonomics/chains/dev/ && \\\n    scp ./uploads/robonomics.service root@$IP:/etc/systemd/system/ && \\\n    scp ./robonomics root@$IP:/usr/bin/ && \\\n    ssh root@$IP "mkdir -p /etc/substrate" && \\\n    scp ./uploads/spec.json root@$IP:/etc/substrate/ \\\n; done\n```\n\n## Network launch\nNow connect to all nodes, enable and start the **robonomics.service** unit:\n```\n$  \\\nfor IP in `ls -l ./uploads/ | grep \'^d\' | awk \'{print $9}\'`; do \\\n   ssh root@$IP "systemctl enable robonomics.service && systemctl start robonomics.service" \\\n; done\n```\nAfter starting the service on all three nodes, you can view the node logs using **journalctl**. \nTo do this, you can connect to any existing server via ssh and run the following command:\n```\n$ journalctl -u robonomics.service -f\n```\n![Robonomics Chart](../images/robonomics-test-network-manual/result-journalctl.jpg "Robonomics Network journalctl stdout")\n'}},{node:{id:"0d26b6d8338c38dd7345c5b9a7b86289",title:"Robonomics + Prometheus + Grafana",path:"/docs/en/robonomics-prometheus-grafana/",content:"\n**The following instruction is provided by [Hubo Bubo](https://github.com/hubobubo)**\n\n**The original article is located [here](https://github.com/hubobubo/robonomics/wiki/Robonomics-(XRT)-metrics-using-Prometheus-and-Grafana)**\n\n## Introduction\nTo better monitor and maintain Robonomics node(s) it's good to setup a monitoring based on Prometheus Server and Grafana. This doc will show how to configure each one of it to fully monitor your node.\n\n##  Prerequisites\n* [Server Setup with Ubuntu 18.04](https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-18-04) \n* [Robonomics parachain collator installed](https://blog.aira.life/installing-and-running-the-robonomics-validator-in-the-polkadot-network-487ad4c1a567)\n* Make sure you have robonomics.service working on your machine and port 9615 is reachable \n\n## Step 1 — Creating Service Users\n\nFor security purposes, we’ll begin by creating two new user accounts, prometheus and node_exporter. Create these two users, and use the _--no-create-home_ and _--shell /bin/false_ options so that these users can’t log into the server.\n```\nsudo useradd --no-create-home --shell /bin/false prometheus\nsudo useradd --no-create-home --shell /bin/false node_exporter\n```\n\nBefore we download the Prometheus binaries, create the necessary directories for storing Prometheus’ files and data. Following standard Linux conventions, we’ll create a directory in _/etc_ for Prometheus’ configuration files and a directory in _/var/lib_ for its data.\n```\nsudo mkdir /etc/prometheus\nsudo mkdir /var/lib/prometheus\n```\nNow, set the user and group ownership on the new directories to the prometheus user.\n```\nsudo chown prometheus:prometheus /etc/prometheus\nsudo chown prometheus:prometheus /var/lib/prometheus\n```\n## Step 2 — Downloading Prometheus\n\nFirst, download and unpack the current stable version of Prometheus into your home directory. You can find the latest binaries on the [Prometheus download page.](https://prometheus.io/download/)\n\n```\nwget https://github.com/prometheus/prometheus/releases/download/v2.21.0/prometheus-2.21.0.linux-amd64.tar.gz\n\n```\nNow, unpack the downloaded archive.\n\n```\ntar xvf prometheus-2.21.0.linux-amd64.tar.gz\n\n```\nThis will create a directory called prometheus-2.21.0.linux-amd64 containing two binary files (prometheus and promtool), _consoles_ and _console_libraries_ directories containing the web interface files, a license, a notice, and several example files.\n\nCopy the two binaries to the _/usr/local/bin_ directory.\n\n```\nsudo cp prometheus-2.21.0.linux-amd64/prometheus /usr/local/bin/\nsudo cp prometheus-2.21.0.linux-amd64/promtool /usr/local/bin/\n\n```\nSet the user and group ownership on the binaries to the prometheus user created in Step 1.\n\n```\nsudo chown prometheus:prometheus /usr/local/bin/prometheus\nsudo chown prometheus:prometheus /usr/local/bin/promtool\n\n```\nCopy the consoles and _console_libraries_ directories to _/etc/prometheus_.\n\n```\nsudo cp -r prometheus-2.21.0.linux-amd64/consoles /etc/prometheus\nsudo cp -r prometheus-2.21.0.linux-amd64/console_libraries /etc/prometheus\n\n```\nSet the user and group ownership on the directories to the prometheus user. Using the -R flag will ensure that ownership is set on the files inside the directory as well.\n\n```\nsudo chown -R prometheus:prometheus /etc/prometheus/consoles\nsudo chown -R prometheus:prometheus /etc/prometheus/console_libraries\n\n```\nNow that Prometheus is installed, we’ll create its configuration and service files in preparation of its first run.\n\n## Step 3 — Configuring Prometheus\n\nIn the _/etc/prometheus_ directory, use nano or your favorite text editor to create a configuration file named _prometheus.yml_.\n\n```\nsudo nano /etc/prometheus/prometheus.yml\n\n```\nIn the global settings, define the default interval for scraping metrics. Note that Prometheus will apply these settings to every exporter unless an individual exporter’s own settings override the globals.\n\n```\nglobal:\n  scrape_interval: 15s\n\n```\nThis scrape_interval value tells Prometheus to collect metrics from its exporters every 15 seconds, which is long enough for most exporters.\nNow, add Prometheus itself to the list of exporters to scrape from with the following scrape_configs directive:\n\n```\n...\nscrape_configs:\n  - job_name: 'prometheus'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9090']\n```\nPrometheus uses the _job_name_ to label exporters in queries and on graphs, so be sure to pick something descriptive here.\n\nAnd, as Prometheus exports important data about itself that you can use for monitoring performance and debugging, we’ve overridden the global scrape_interval directive from 15 seconds to 5 seconds for more frequent updates.\n\nLastly, Prometheus uses the _static_configs_ and _targets_ directives to determine where exporters are running. Since this particular exporter is running on the same server as Prometheus itself, we can use localhost instead of an IP address along with the default port, 9090.\n\nYour configuration file should now look like this:\n\n```\nglobal:\n  scrape_interval: 15s\n\nscrape_configs:\n  - job_name: 'prometheus'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9090']\n```\nSave the file and exit your text editor.\n\nNow, set the user and group ownership on the configuration file to the prometheus user created in Step 1.\n\n```\nsudo chown prometheus:prometheus /etc/prometheus/prometheus.yml\n\n```\nWith the configuration complete, we’re ready to test Prometheus by running it for the first time.\n\n## Step 4 — Running Prometheus\n\nStart up Prometheus as the _prometheus_ user, providing the path to both the configuration file and the data directory.\n\n```\nsudo -u prometheus /usr/local/bin/prometheus \\\n    --config.file /etc/prometheus/prometheus.yml \\\n    --storage.tsdb.path /var/lib/prometheus/ \\\n    --web.console.templates=/etc/prometheus/consoles \\\n    --web.console.libraries=/etc/prometheus/console_libraries\n```\n\nThe output contains information about Prometheus’ loading progress, configuration file, and related services. It also confirms that Prometheus is listening on port _9090_.\n\n```\n_log output_\nSep 14 17:55:53 robonomics systemd[1]: Started Prometheus.\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.347Z caller=main.go:310 msg=\"No time or size retention was set so using the default time retention\" duration=15d\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.350Z caller=main.go:346 msg=\"Starting Prometheus\" version=\"(version=2.21.0, branch=HEAD, revision=e83ef207b6c2398919b69cd87d2693cfc2fb4127)\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:347 build_context=\"(go=go1.15.2, user=root@a4d9bea8479e, date=20200911-11:35:02)\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:348 host_details=\"(Linux 4.15.0-112-generic #113-Ubuntu SMP Thu Jul 9 23:41:39 UTC 2020 x86_64 robonomics (none))\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:349 fd_limits=\"(soft=1024, hard=4096)\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.351Z caller=main.go:350 vm_limits=\"(soft=unlimited, hard=unlimited)\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.357Z caller=main.go:701 msg=\"Starting TSDB ...\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.368Z caller=web.go:523 component=web msg=\"Start listening for connections\" address=0.0.0.0:9090\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.372Z caller=head.go:644 component=tsdb msg=\"Replaying on-disk memory mappable chunks if any\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:658 component=tsdb msg=\"On-disk memory mappable chunks replay completed\" duration=12.659µs\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.373Z caller=head.go:664 component=tsdb msg=\"Replaying WAL, this may take a while\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.380Z caller=head.go:716 component=tsdb msg=\"WAL segment loaded\" segment=0 maxSegment=1\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:716 component=tsdb msg=\"WAL segment loaded\" segment=1 maxSegment=1\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.381Z caller=head.go:719 component=tsdb msg=\"WAL replay completed\" checkpoint_replay_duration=48.125µs wal_replay_duration=8.253748ms total_replay_duration=8.343335ms\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.383Z caller=main.go:721 fs_type=EXT4_SUPER_MAGIC\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:724 msg=\"TSDB started\"\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:850 msg=\"Loading configuration file\" filename=/etc/prometheus/prometheus.yml\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:881 msg=\"Completed loading of configuration file\" filename=/etc/prometheus/prometheus.yml totalDuration=908.135µs remote_storage=6.693µs web_handler=819ns query_engine=1.383µs scrape=400.232µs scrape_sd=41.679µs notify=1.1µs notify_sd=1.847µs rules=1.522µs\nSep 14 17:55:53 robonomics prometheus[29488]: level=info ts=2020-09-14T15:55:53.384Z caller=main.go:673 msg=\"Server is ready to receive web requests.\"\n```\nIf you get an error message, double-check that you’ve used YAML syntax in your configuration file and then follow the on-screen instructions to resolve the problem.\n\nNow, halt Prometheus by pressing _CTRL+C_, and then open a new _systemd_ service file.\n\n```\nsudo nano /etc/systemd/system/prometheus.service\n\n```\nThe service file tells _systemd_ to run Prometheus as the prometheus user, with the configuration file located in the _/etc/prometheus/prometheus.yml_ directory and to store its data in the _/var/lib/prometheus_ directory.Copy the following content into the file:\n\n```\n[Unit]\nDescription=Prometheus\nWants=network-online.target\nAfter=network-online.target\n\n[Service]\nUser=prometheus\nGroup=prometheus\nType=simple\nExecStart=/usr/local/bin/prometheus \\\n    --config.file /etc/prometheus/prometheus.yml \\\n    --storage.tsdb.path /var/lib/prometheus/ \\\n    --web.console.templates=/etc/prometheus/consoles \\\n    --web.console.libraries=/etc/prometheus/console_libraries\n\n[Install]\nWantedBy=multi-user.target\n```\n\nFinally, save the file and close your text editor. To use the newly created service, reload systemd.\n\n```\nsudo systemctl daemon-reload\n\n```\nYou can now start Prometheus using the following command:\n\n```\nsudo systemctl start prometheus\n\n```\nTo make sure Prometheus is running, check the service’s status.\n\n```\nsudo systemctl status prometheus\n\n```\nThe output tells you Prometheus’ status, main process identifier (PID), memory use, and more.\n\nIf the service’s status isn’t active, follow the on-screen instructions and re-trace the preceding steps to resolve the problem before continuing the tutorial.\n\n```\n* prometheus.service - Prometheus\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\n   Active: active (running) since Mon 2020-09-14 17:59:48 CEST; 24h ago\n Main PID: 29650 (prometheus)\n    Tasks: 9 (limit: 4915)\n   CGroup: /system.slice/prometheus.service\n           `-29650 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\n```\n\nWhen you’re ready to move on, press _Q_ to quit the status command. Lastly, enable the service to start on boot.\n\n```\nsudo systemctl enable prometheus\n\n```\n\nNow that Prometheus is up and running, we can install an additional exporter to generate metrics about our server’s resources.\n\n## Step 5 — Downloading Node Exporter\n\nTo expand Prometheus beyond metrics about itself only, we’ll install an additional exporter called Node Exporter. Node Exporter provides detailed information about the system, including CPU, disk, and memory usage. Download the current stable version of Node Exporter into your home directory. You can find the latest binaries on [Prometheus download page.](https://prometheus.io/download/)\n\n```\nwget https://github.com/prometheus/node_exporter/releases/download/v1.0.1/node_exporter-1.0.1.linux-amd64.tar.gz\n\n```\nNow, unpack the downloaded archive.\n\n```\ntar xvf node_exporter-1.0.1.linux-amd64.tar.gz\n\n```\nThis will create a directory called _node_exporter-1.0.1.linux-amd64_ containing a binary file named _node_exporter_, a license, and a notice.\n\nCopy the binary to the _/usr/local/bin_ directory and set the user and group ownership to the node_exporter user that you created in Step 1.\n\n```\nsudo cp node_exporter-1.0.1.linux-amd64/node_exporter /usr/local/bin\nsudo chown node_exporter:node_exporter /usr/local/bin/node_exporter\n\n```\nNow that you’ve installed Node Exporter, let’s test it out by running it before creating a service file for it so that it starts on boot.\n\n## Step 6 — Running Node Exporter\n\nThe steps for running Node Exporter are similar to those for running Prometheus itself. Start by creating the Systemd service file for Node Exporter.\n\n```\nsudo nano /etc/systemd/system/node_exporter.service\n\n```\nCopy the following content into the service file:\n\n```\n[Unit]\nDescription=Node Exporter\nWants=network-online.target\nAfter=network-online.target\n\n[Service]\nUser=node_exporter\nGroup=node_exporter\nType=simple\nExecStart=/usr/local/bin/node_exporter --collector.systemd\n\n[Install]\nWantedBy=multi-user.target\n```\n\nSave the file and close your text editor. Finally, reload systemd to use the newly created service.\n\n```\nsudo systemctl daemon-reload\n\n```\nYou can now run Node Exporter using the following command:\n\n```\nsudo systemctl start node_exporter\n\n```\nVerify that Node Exporter’s running correctly with the status command.\n\n```\nsudo systemctl status node_exporter\n\n```\nLike before, this output tells you Node Exporter’s status, main process identifier (PID), memory usage, and more. If the service’s status isn’t active, follow the on-screen messages and re-trace the preceding steps to resolve the problem before continuing.\n\n```\n_Output_\n* node_exporter.service - Node Exporter\n   Loaded: loaded (/etc/systemd/system/node_exporter.service; enabled; vendor preset: enabled)\n   Active: active (running) since Mon 2020-09-14 17:58:25 CEST; 1 day 1h ago\n Main PID: 29612 (node_exporter)\n    Tasks: 7 (limit: 4915)\n   CGroup: /system.slice/node_exporter.service\n           `-29612 /usr/local/bin/node_exporter --collector.systemd\n```\nLastly, enable Node Exporter to start on boot.\n\n```\nsudo systemctl enable node_exporter\n\n```\nWith Node Exporter fully configured and running as expected, we’ll tell Prometheus to start scraping the new metrics.\n\n## Step 7 — Configuring Prometheus to Scrape Node Exporter\n\nBecause Prometheus only scrapes exporters which are defined in the scrape_configs portion of its configuration file, we’ll need to add an entry for Node Exporter, just like we did for Prometheus itself. Open the configuration file.\n\n```\nsudo nano /etc/prometheus/prometheus.yml\n\n```\nAt the end of the scrape_configs block, add a new entry called node_exporter.\n\n```\n...\n  - job_name: 'node_exporter'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9100']\n```\nBecause this exporter is also running on the same server as Prometheus itself, we can use localhost instead of an IP address again along with Node Exporter’s default port, 9100. Your whole configuration file should look like this:\n\n```\nglobal:\n  scrape_interval: 15s\n\nscrape_configs:\n  - job_name: 'prometheus'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9090']\n  - job_name: 'node_exporter'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9100']\n```\nSave the file and exit your text editor when you’re ready to continue. Finally, restart Prometheus to put the changes into effect.\n\n```\nsudo systemctl restart prometheus\n\n```\nOnce again, verify that everything is running correctly with the status command.\n\n```\nsudo systemctl status prometheus\n\n```\nIf the service’s status isn’t set to active, follow the on screen instructions and re-trace your previous steps before moving on.\n\n```\nOutput\n* prometheus.service - Prometheus\n   Loaded: loaded (/etc/systemd/system/prometheus.service; enabled; vendor preset: enabled)\n   Active: active (running) since Tue 2020-09-15 19:06:56 CEST; 2s ago\n Main PID: 19725 (prometheus)\n    Tasks: 8 (limit: 4915)\n   CGroup: /system.slice/prometheus.service\n           `-19725 /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries\n```\n\nWe now have Prometheus and Node Exporter installed, configured, and running.\n\n## Step 8 - Adding Robonomic build in node_exporter\n\nAfter successfully installed Prometheus and node_exporter we will have to use build in prometheus exporter in every substrate project. To make this happen we have to add additional entry to _/etc/prometheus/prometheus.yml_. \nOpen the configuration file.\n\n```\nsudo nano /etc/prometheus/prometheus.yml\n\n```\nAt the end of the scrape_configs block, add a new entry called robonomic_exporter.\n\n``` \n  - job_name: 'robonomics_exporter'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9615']\n```\nSave the file and exit your text editor. Your whole configuration file should look like this:\n\n```\nglobal:\n  scrape_interval: 15s\n\nscrape_configs:\n  - job_name: 'prometheus'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9090']\n  - job_name: 'node_exporter'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9100']\n  - job_name: 'robonomics_exporter'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['localhost:9615']\n```\n\nFinally, restart Prometheus to put the changes into effect.\n\n```\nsudo systemctl restart prometheus\n\n```\nOnce again, verify that everything is running correctly with the status command.\n\n```\nsudo systemctl status prometheus\n\n```\nWe now have _Prometheus_ and _Node Exporter_ as well as _Robonomic Exporter_ installed, configured, and running. Now move on to Grafana\n\n## Step 9 - Setting up Grafana\n\nThe last step is to connect Prometheus as a Data Source in Grafana. For purpose of this tutorial we will use free cloud-based grafana which allow to have up to 5 dashboards as well as dedicated [Robonomics dashboard](https://grafana.com/grafana/dashboards/13015). Simply go to [grafana.com](https://grafana.com/) create new account and login to your newly created grafana instance.\n\nAt the beginning we must add to Grafana new _**Data Source**_ which in our case will be Prometheus server.\nGo to Data Source:\n\n>![DataSource](../images/prometheus-grafana/grafana-6-2020-09-15-19-18-50-Window.png)\n\nThen click **_Add data source_**\n\n>![DataSource](../images/prometheus-grafana/grafana-7-2020-09-15-19-18-50-Window.png)\n\nNext select _**Prometheus**_\n\n>![DataSource](../images/prometheus-grafana/grafana-8-2020-09-15-19-18-50-Window.png)\n\nIn new screen put your **_Prometheus server IP adress with 9090 port_**\n\n> ![DataSource](../images/prometheus-grafana/grafana-9-2020-09-15-19-18-50-Window.png)\n\nAfter that _**Save & Test**_ if you did all steps you should be green and ready to go for importing dashboard. On the main site click to **+** and then **Import** as shown on the pic below:\n\n> ![Import dashboard](../images/prometheus-grafana/grafana-1-2020-09-15-19-18-50-Window.png)\n\nThen you should see Import page:\n\n> ![Import page](../images/prometheus-grafana/grafana-2-2020-09-15-19-18-50-Window.png)\n\nIn the _Grafana.com dashboard url or id_ write _**13015**_ (as this is ID of the Robonomic dashboard)\n\n> ![Import Robonomic dashboard](../images/prometheus-grafana/grafana-3-2020-09-15-19-18-50-Window.png)\n\nAfter loading external dashboard you will get this screen:\n\n> ![XRT 13015 dashboard import](../images/prometheus-grafana/grafana-4-2020-09-15-19-18-50-Window.png)\n\nThe last step is to choose previously created **_Data Source_** and click _**Import**_\n\n> ![Prometheus as a DataSource](../images/prometheus-grafana/grafana-5-2020-09-15-19-18-50-Window.png)\n\nTHAT'S IT ! At this point you should see imported dashboard. \n\n\n## References\n\n* [How To Install Prometheus on Ubuntu 16.04](https://www.digitalocean.com/community/tutorials/how-to-install-prometheus-on-ubuntu-16-04)\n* [Build A Monitoring Dashboard by Prometheus + Grafana](https://medium.com/htc-research-engineering-blog/build-a-monitoring-dashboard-by-prometheus-grafana-741a7d949ec2)\n* [Grafana support for Prometheus](https://prometheus.io/docs/visualization/grafana/)\n* [Monitoring Linux host metrics with the node exporter](https://prometheus.io/docs/guides/node-exporter/)\n* [Querying Prometheus](https://prometheus.io/docs/prometheus/latest/querying/basics/)\n* [Visualizing Node Metrics](https://substrate.dev/docs/en/tutorials/visualize-node-metrics/)\n* [Substrate Prometheus Exporter](https://github.com/paritytech/substrate/tree/master/utils/prometheus)\n* [polkadot-dashboard](https://github.com/w3f/polkadot-dashboard)\n* [Polkadot node metric](https://grafana.com/grafana/dashboards/12425)\n* [Node Exporter for Prometheus Dashboard](https://grafana.com/grafana/dashboards/11074)\n* [Grafana ROBONOMICS (XRT) Metrics](https://grafana.com/grafana/dashboards/13015)\n\n"}},{node:{id:"4a7244db5ca97f6d22655107b0c4a99c",title:"Robonomics Liability",path:"/docs/en/robonomics-liability/",content:'\nThe package is responsible for receiving `New Liability` events (`listener` node) and playing topics from `objective` field (`executor` node).\nThe launch file also include `ipfs_channel` node and `signer` node.\n\n## ROS Parameters\n\n### ~web3_http_provider\n\nWeb3 HTTP provider address. The type is `string`, defaults to `http://127.0.0.1:8545`\n\n### ~web3_ws_provider\n\nWeb3 WebSocket provider address. The type is `string`, defaults to `ws://127.0.0.1:8546`\n\n### ~ipfs_http_provider\n\nIPFS HTTP provider address. The type is `string`, defaults to `http://127.0.0.1:5001`\n\n### ~ipfs_swarm_connect_addresses\n\nIPFS nodes to connect to. The type is `string`, defaults to `""`\n\n### ~ipfs_public_providers\n\nA public IPFS node to pin result files. The type is `string`, defaults to `""`\n\n### ~factory_contract\n\nThe name of the liability factory. The type is `string`, defaults to `factory.5.robonomics.eth`\n\n### ~lighthouse_contract\n\nThe name of a lighthouse you are working on. The type is `string`, defaults to `airalab.lighthouse.5.robonomics.eth`\n\n### ~enable_executor\n\nEnable or disable executor node. If it\'s `false`, no topics from objective would be published. The type is `boolean`, defaults to `true`\n\n### ~master_check_interval\n\nPeriod (in seconds) to check master for new topic publications. It\'s necessary for the Recorder, which records all the topics a CPS publishes. The type is `double`, defaults to `0.1`\n\n### ~recording_topics\n\nList of topics name separated by comma. It allows you to specify which topics would be recorded. The type is `string`, defaults to `""`\n\n### ~ens_contract\n\nThe checksumed address of ENS registry. The type is `string`, defaults to `""`\n\n### ~keyfile\n\nPath to keyfile. The type is `string`, defaults to `""`. **Required parameter**\n\n### ~keyfile_password_file\n\nPath to a file with password for the keyfile. The type is `string`, defaults to `""`. **Required parameter**\n\n## Subscribed topics\n\n### /liability/infochan/eth/signing/demand (robonomics_msgs/Demand)\n\n[robonomics_msgs/Demand](/docs/market-messages#demand) message to sign and send further to IPFS channel\n\n### /liability/infochan/eth/signing/offer (robonomics_msgs/Offer)\n\n[robonomics_msgs/Offer](/docs/market-messages#offer) message to sign and send further to IPFS channel\n\n### /liability/infochan/eth/signing/result (robonomics_msgs/Result)\n\n[robonomics_msgs/Result](/docs/market-messages#result) message to sign and send further to IPFS channel\n\n\n## Published topics\n\n### /liability/infochan/incoming/demand (robonomics_msgs/Demand)\n\nContains a [robonomics_msgs/Demand](/docs/market-messages#demand) message which was read from IPFS channel\n\n### /liability/infochan/incoming/offer (robonomics_msgs/Offer)\n\nContains a [robonomics_msgs/Offer](/docs/market-messages#offer) message which was read from IPFS channel\n\n### /liability/infochan/incoming/result (robonomics_msgs/Result)\n\nContains a [robonomics_msgs/Result](/docs/market-messages#result) message which was read from IPFS channel\n\n### /liability/incoming (robonomics_liability/Liability)\n\nContains all the information about the last created [robonomics_liability/Liability](/docs/robonomics-liability-messages#robonomics_liabilityliabilitymsg)\n\n### /liability/ready (robonomics_liability/Liability)\n\nSignals when a [robonomics_liability/Liability](/docs/robonomics-liability-messages#robonomics_liabilityliabilitymsg)is ready for execution\n\n### /liability/complete (robonomics_liability/Liability)\n\nSignals when a [robonomics_liability/Liability](/docs/robonomics-liability-messages#robonomics_liabilityliabilitymsg) has done its job\n\n### /liability/finalized (std_msgs/String)\n\nSignals when a liability has been finalized\n\n## Services\n\n### /liability/start (robonomics_liability/StartLiability)\n\nThe service tells executor to play topics from the objective. It\'s required to pass a liability address ([robonomics_liability/StartLiability](/docs/robonomics-liability-messages#robonomics_liabilitystartliabilitysrv)), which you can get from `/liability/ready` topic\n\n### /liability/finish (robonomics_liability/FinishLiability)\n\nCPS should call the service after performing the task. The input is [robonomics_liability/FinishLiability](/docs/robonomics-liability-messages#robonomics_liabilityfinishiabilitysrv)\n\n### /liability/restart (robonomics_liability/StartLiability)\n\nThe service allows to restart a liability after the system shutdown. The input is [robonomics_liability/StartLiability](/docs/robonomics-liability-messages#robonomics_liabilitystartliabilitysrv)\n\n### /liability/resume (robonomics_liability/StartLiability)\n\nThe service allows to resume a liability from the last timestamp available in the persistence store. The input is [robonomics_liability/StartLiability](/docs/robonomics-liability-messages#robonomics_liabilitystartliabilitysrv)\n\n### /liability/read (robonomics_liability/ReadLiability)\n\nThe service returns all the data about a liability by its address. The input is [robonomics_liability/ReadLiability](/docs/robonomics-liability-messages#robonomics_liabilityreadliabilitysrv)\n'}},{node:{id:"fce34887415c5ceb488e44edf59d3421",title:"Robonomics Liability Messages",path:"/docs/en/robonomics-liability-messages/",content:"\n## robonomics_liability/Liability.msg\n\n| Field        \t| Type                                                                         \t| Description                                    \t|\n|--------------\t|------------------------------------------------------------------------------\t|------------------------------------------------\t|\n| address      \t| [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) \t| The Liability’s address                        \t|\n| model        \t| [ipfs_commom/Multihash](/docs/ipfs-common-messages#ipfs_commonmultihashmsg)         \t| CPS behavioral model Identifier                \t|\n| objective    \t| [ipfs_commom/Multihash](/docs/ipfs-common-messages#ipfs_commonmultihashmsg)         \t| CPS behavioral model parameters in rosbag file \t|\n| result       \t| [ipfs_commom/Multihash](/docs/ipfs-common-messages#ipfs_commonmultihashmsg)         \t| Liability result hash                          \t|\n| promisee     \t| [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) \t| The promisee address                           \t|\n| promisor     \t| [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) \t| The promisor address (usually CPS)             \t|\n| lighthouse   \t| [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) \t| The address of lighthouse your CPS works on    \t|\n| token        \t| [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) \t| Operational token address                      \t|\n| cost         \t| [ethereum_commom/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg) \t| CPS behavioral model implementation cost       \t|\n| validator    \t| [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) \t| Observing network address                      \t|\n| validatorFee \t| [ethereum_commom/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg) \t| Observing network commission                   \t|\n\n## robonomics_liability/StartLiability.srv\n\n**Request**\n\n| Field     | Type              | Description                                           |\n|---------  |-----------------  |-----------------------------------------------------  |\n| address   | std_msgs/String   | The address of Liability you are willing to execute   |\n\n**Response**\n\n| Field     | Type              | Description                               |\n|---------  |-----------------  |------------------------------------------ |\n| success   | std_msgs/Bool     | Weather or not the Liability was started  |\n| msg       | std_msgs/String   | Status of launch                          |\n\n## robonomics_liability/FinishLiability.srv\n\n**Request**\n\n| Field     | Type              | Description                           |\n|---------  |-----------------  |------------------------------------   |\n| address   | std_msgs/String   | The address of Liability to finish    |\n| success   | std_msgs/Bool     | The status of execution               |\n\n**Response**\n\nThe response is empty\n\n## robonomics_liability/ReadLiability.srv\n\n**Request**\n\n| Field     | Type                                                                          | Description                   |\n|---------  |------------------------------------------------------------------------------ |----------------------------   |\n| address   | [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg)  | The address of a liability    |\n\n**Response**\n\n| Field         | Type                                                                  | Description           |\n|-----------    |---------------------------------------------------------------------  |---------------------  |\n| read          | std_msgs/Bool                                                         | Status of execution   |\n| liability     | [robonomics_liability/Liability](#robonomics_liabilityliabilitymsg)   | Liability             |\n"}},{node:{id:"9f53197d65fea5ff3ea4d0b315e078d1",title:"Robonomics-js",path:"/docs/en/robonomics-js/",content:"\n[Robonomics-js](https://github.com/airalab/robonomics-js) is a simple Javascript library for working with Robonomics Network.\n\n## Installation\n\n```\nnpm install robonomics-js --save\n```\n\nor\n\n```\nyarn add robonomics-js\n```\n\n### Dependencies \n\n* [Web3](https://github.com/ethereum/web3.js/) version 1.2.4\n* [Ipfs](https://github.com/ipfs/js-ipfs) version 0.34.0\n\n\n## Usage \n\nCreates a Robonomics instance\n\n```JavaScript\nconst options = {...};\nconst robonomics = new Robonomics(options);\n```\n\n### options\n\nThe object of properties:\n\n```\noptions.web3\n```\n\nAn instance of [web3.js](https://github.com/ethereum/web3.js/):\n\n```JavaScript\n// metamask\nconst options = {\n  web3: new Web3(window.ethereum),\n  ...\n};\n\n// infura\nconst options = {\n  web3: new Web3(\n    new Web3.providers.WebsocketProvider(\n      \"wss://mainnet.infura.io/ws/v3/0b2f2a5026264b57b6d698b480332e89\"\n    )\n  ),\n  ...\n};\n```\n\n```\noptions.messageProvider\n```\n\nThis is an instance of MessageProviderIpfs which uses a [js-ipfs](https://github.com/ipfs/js-ipfs) node with pubsub support\n\n```JavaScript\nconst ipfs = new Ipfs({\n  repo: 'robonomics-example',\n  relay: {\n    enabled: true,\n    hop: {\n      enabled: true\n    }\n  },\n  EXPERIMENTAL: {\n    pubsub: true\n  },\n  config: {\n    Addresses: {\n      Swarm: [\n        '/dns4/ws-star.discovery.libp2p.io/tcp/443/wss/p2p-websocket-star',\n        '/dns4/1.wsstar.aira.life/tcp/443/wss/p2p-websocket-star/',\n        '/dns4/2.wsstar.aira.life/tcp/443/wss/p2p-websocket-star/',\n        '/dns4/3.wsstar.aira.life/tcp/443/wss/p2p-websocket-star/'\n      ]\n    },\n    Bootstrap: [\n      '/dns4/ams-1.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLer265NRgSp2LA3dPaeykiS1J6DifTC88f5uVQKNAd',\n      '/dns4/lon-1.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLMeWqB7YGVLJN3pNLQpmmEk35v6wYtsMGLzSr5QBU3',\n      '/dns4/nyc-1.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLueR4xBeUbY9WZ9xGUUxunbKWcrNFTDAadQJmocnWm',\n      '/dns4/nyc-2.bootstrap.libp2p.io/tcp/443/wss/ipfs/QmSoLV4Bbm51jM9C4gDYZQ9Cy3U6aXMJDAbzgu2fzaDs64',\n      '/dns4/node0.preload.ipfs.io/tcp/443/wss/ipfs/QmZMxNdpMkewiVZLMRxaNxUeZpDUb34pWjZ1kZvsd16Zic',\n      '/dns4/node1.preload.ipfs.io/tcp/443/wss/ipfs/Qmbut9Ywz9YEDrz8ySBSgWyJk41Uvm2QJPhwDJzJyGFsD6',\n      '/dns4/1.pubsub.aira.life/tcp/443/wss/ipfs/QmdfQmbmXt6sqjZyowxPUsmvBsgSGQjm4VXrV7WGy62dv8',\n      '/dns4/2.pubsub.aira.life/tcp/443/wss/ipfs/QmPTFt7GJ2MfDuVYwJJTULr6EnsQtGVp8ahYn9NSyoxmd9',\n      '/dns4/3.pubsub.aira.life/tcp/443/wss/ipfs/QmWZSKTEQQ985mnNzMqhGCrwQ1aTA6sxVsorsycQz9cQrw'\n    ]\n  }\n})\n\nconst options = {\n  messageProvider: new MessageProviderIpfs(ipfs),\n  ...\n};\n```\n\n```\noptions.account\n```\n\nThis is an account object which will be used to sign messages. It's necessary to specify either account address (that one must be unlocked) or a private key (the address will be recovered from the given private key).\n\nOption `isSignPrefix` tells whether or not a prefix must be appended. Default is `true`.\n\n```JavaScript\nconst options = {\n  account: {\n    address: '0x0000000000000000000000000000000000000000',\n    privateKey: '0x0000000000000000000000000000000000000000000000000000',\n    isSignPrefix: true\n  },\n  ...\n};\n```\n\n```\noptions.ens\n```\n\nThis is a `ens` contract object. This one is not required. If it's necessary you may specify `address` of the contract if the network is not set to mainnet. `suffix` may be `sid` for sidechain or `eth` for mainnet. `eth` is default. `version` is the version of Robonomics Network. Default is the latest deployed version.\n\n```JavaScript\nconst options = {\n  ens: {\n    address: '0x314159265dD8dbb310642f98f50C066173C1259b',\n    suffix: 'eth',\n    version: 5\n  },\n  ...\n};\n```\n\n```\noptions.lighthouse\n```\n\nENS name of a lighthouse, not required. Default is `airalab.lighthouse.5.robonomics.eth`. It's possible to specify only the first part of the name, like `airalab`.\n\n```JavaScript\nconst options = {\n  lighthouse: 'airalab.lighthouse.5.robonomics.eth',\n  ...\n};\n```\n\nIt's necessary to wait until full initialization\n\n```JavaScript\nconst options = {...};\nconst robonomics = new Robonomics(options);\nrobonomics.ready().then(() => {\n  console.log('Robonomics instance ready')\n})\n```\n\n## API\n\n### Messages\n\n#### Demand \n\nThe message specification\n\n```JavaScript\nconst demand = {\n  // REQUIRED\n  model: \"QmSt69qQqGka1qwRRHbdmAWk4nCbsV1mqJwd8cWbEyhf1M\",      // ipfs hash of the model \n  objective: \"QmSt69qQqGka1qwRRHbdmAWk4nCbsV1mqJwd8cWbEyhf2M\",  // ipfs hash of the objective\n  token: robonomics.xrt.address,                                // payment token address\n  cost: 1,                                                      // cost\n  deadline: 9999999,                                            // until which block demand is valid\n\n  // NOT REQUIRED \n  lighthouse: \"0x0000000000000000000000000000000000000000\",     // lighthouse address, by default the initialization address\n  validator: \"0x0000000000000000000000000000000000000000\",      // validator address if necessary\n  validatorFee: 0,                                              // validator fee \n  nonce: 1                                                      // index number \n};\n```\n\n`robonomics.sendDemand`\n\nSigning and broadcasting the demand message. A liability is returned as promise\n\n```JavaScript\nrobonomics.sendDemand(demand).then(liability => {\n  console.log(liability.address);\n});\n```\n\n`robonomics.onDemand`\n\nListens to demand messages with a defined model. If model is `null` returns any demand message.\n\n```JavaScript\nrobonomics.onDemand(model, message => {\n  console.log(message);\n});\n```\n\n#### Offer \n\nThe message specification\n\n```JavaScript\nconst offer = {\n  // REQUIRED \n  model: \"QmSt69qQqGka1qwRRHbdmAWk4nCbsV1mqJwd8cWbEyhf1M\",      // ipfs hash of the model \n  objective: \"QmSt69qQqGka1qwRRHbdmAWk4nCbsV1mqJwd8cWbEyhf2M\",  // ipfs hash of the objective\n  token: robonomics.xrt.address,                                // payment token address\n  cost: 1,                                                      // cost \n  deadline: 9999999,                                            // until which block demand is valid\n\n  // NOT REQUIRED\n  lighthouse: \"0x0000000000000000000000000000000000000000\",     // lighthouse address, by default the initialization address\n  lighthouseFee: 0,                                             // lighthouse fee\n  validator: \"0x0000000000000000000000000000000000000000\",      // validator address if necessary\n  nonce: 1                                                      // index number \n};\n```\n\n`robonomics.sendOffer`\n\nSigns and broadcasts an offer message. A liability is returned as promise\n\n```JavaScript\nrobonomics.sendOffer(offer).then(liability => {\n  console.log(liability.address);\n});\n```\n\n`robonomics.onOffer`\n\nListens to offer messages with a defined model. If model is `null` returns any offer message\n\n```JavaScript\nrobonomics.onOffer(model, message => {\n  console.log(message);\n});\n```\n\n#### Result \n\nThe message specification\n\n```JavaScript\nconst result = {\n  // REQUIRED \n  liability: \"0x0000000000000000000000000000000000000000\",  // liability contract address\n  success: true,                                            // status of the task\n  result: \"QmWXk8D1Fh5XFJvBodcWbwgyw9htjc6FJg8qi1YYEoPnrg\"  // ipfs hash of the rosbag log file\n};\n```\n\n`robonomics.sendResult`\n\nSigns and broadcasts a result message\n\n```JavaScript\nrobonomics.sendResult(result).then(() => {\n  console.log(\"ok\");\n});\n```\n\n`robonomics.onResult`\n\nListens to result messages. These results may be not valid. Valid results are stored in a liability contract\n\n```JavaScript\nrobonomics.onResult(result => {\n  console.log(result);\n});\n```\n\n### Smart Contracts \n\n#### Liability \n\n`liability.getInfo`\n\nReturn a property object of the contract\n\n```JavaScript\nliability.getInfo().then(data => {\n  console.log(data);\n  /*\n  {\n    model,\n    objective,\n    result,\n    token,\n    cost,\n    lighthouseFee,\n    validatorFee,\n    demandHash,\n    offerHash,\n    promisor,\n    promisee,\n    lighthouse,\n    validator,\n    isSuccess,\n    isFinalized\n  }\n  */\n});\n```\n\n`liability.onResult`\n\nWaits until a liability is finished. Returns a result\n\n```JavaScript\nliability.onResult().then(result => {\n  console.log(result);\n});\n```\n\n#### Lighthouse \n\n`robonomics.lighthouse.getInfo`\n\nReturns a property object of the contract\n\n```JavaScript\nrobonomics.lighthouse.getInfo().then(data => {\n  console.log(data);\n  /*\n  {\n    minimalStake,\n    timeoutInBlocks,\n    keepAliveBlock,\n    marker,\n    quota\n  }\n  */\n});\n```\n\n`robonomics.lighthouse.getProviders`\n\nReturns a list of providers on the lighthouse\n\n```JavaScript\nrobonomics.lighthouse.getProviders().then(list => {\n  console.log(list);\n});\n```\n\n##### Creation of a new lighthouse\n\n```JavaScript\nconst minimalFreeze = 1000      // Wn\nconst timeout = 25              // blocks\nconst name = 'mylighthouse'     // lighthouse name\nrobonomics.factory.methods.createLighthouse(minimalFreeze, timeout, name).send({ from: robonomics.account.address })\n    .then((tx) => console.log(tx))\n\nrobonomics.factory.onLighthouse((lighthouse) => {\n    console.log(lighthouse.name)\n})\n```\n\n##### Become a provider \n\nPreliminarily you must call `approve` for the tokens `XRT`\n\n```JavaScript\nconst name = \"mylighthouse\";    // lighthouse name\nconst stake = 1000;             // Wn\nrobonomics.lighthouse.methods\n  .refill(stake)\n  .send({ from: robonomics.account.address })\n  .then(tx => console.log(tx));\n```\n\n#### Token \n\n`robonomics.xrt.getInfo`\n\nReturns property object of the token\n\n```JavaScript\nrobonomics.xrt.getInfo().then(data => {\n  console.log(data);\n  /*\n  {\n    name,\n    totalSupply,\n    decimals,\n    symbol\n  }\n  */\n});\n```\n\n##### Check balance \n\n```JavaScript\nrobonomics.xrt.methods\n  .balanceOf(robonomics.account.address)\n  .call()\n  .then(balance => console.log(balance));\n```\n\n##### Check allowance \n\n```JavaScript\nrobonomics.xrt.methods\n  .allowance(robonomics.account.address, robonomics.factory.address)\n  .call()\n  .then(allowance => console.log(allowance));\n```\n\n##### Approve \n\n```JavaScript\nrobonomics.xrt.methods\n  .approve(robonomics.lighthouse.address, 100)\n  .send({\n    from: robonomics.account.address\n  })\n  .then(tx => console.log(tx));\n```\n\n## Links \n\n- [Website](https://robonomics.network/)\n- [Minimal template of dApp](https://github.com/airalab/vue-dapp-robonomics-template)\n- [dApp example](https://codesandbox.io/s/robonomics-vue-template-ewuiw)\n"}},{node:{id:"36b6f6a903dee1ebbb9751409ed0db96",title:"How Robonomics Network Works",path:"/docs/en/robonomics-how-it-works/",content:'\nIn this section we will discuss the Robonomics Network scenario.\n\nThere are few main parts in the Robonomics network:\n\n- IPFS for the messages exchanging\n- the Ethereum blockchain for storing new liability contracts\n- a provider that is responsible for matching messages\n- an agent\n\nLet\'s have a look at the following diagram that describes the scenario without any additional details:\n\n![The main scenario of Robonomics Network](../images/robonomics_network_scenario.jpg "The main scenario of Robonomics Network")\n\nThere are three types of [messages](/docs/market-messages) in IPFS: Demand, Offer, Result.\n\n**Below there is the specification for a Demand message:**\n\n| Field         | Type                      | Description                                       | Example                                           |\n|-------------- |-------------------------  |------------------------------------------------   |------------------------------------------------   |\n| model         | [ipfs_common/Multihash](/docs/robonomics-liability-messages#ipfs_commonmultihashmsg)     | CPS behavioral model Identifier                   | QmfXHZ2YkNC5vRjp1oAaRoDHD8H3zZznfhBPasTu348eWC    |\n| objective     | [ipfs_common/Multihash](/docs/robonomics-liability-messages#ipfs_commonmultihashmsg)     | CPS behavioral model parameters in rosbag file    | QmUo3vvSXZPQaQWjb3cH3qQo1hc8vAUqNnqbdVABbSLb6r    |\n| token         | ethereum_common/Address   | Operational token address                         | 0xbD949595eE52346c225a19724084cE517B2cB735        |\n| cost          | ethereum_common/UInt256   | CPS behavioral model implementation cost          | 1                                                 |\n| lighthouse    | ethereum_common/Address   | Lighthouse address                                | 0xa1b60ED40E5A68184b3ce4f7bEf31521A57eD2dB1       |\n| validator     | ethereum_common/Address   | Observing network address                         | 0x0000000000000000000000000000000000000000        |\n| validatorFee  | ethereum_common/UInt256   | Observing network commission                      | 0                                                 |\n| deadline      | ethereum_common/UInt256   | Deadline block number                             | 6393332                                           |\n| sender        | ethereum_common/Address   | Message sender address                            | 0x0000000000000000000000000000000000000000        |\n| signature     | std_msgs/UInt8[]          | Sender’s digital signature                        | 0x23bc…c617                                       |\n\n\x3c!--\n=============== ============================================================== ================================================ ================================================\n     Field                                   Type                                                Description                                        Example\n=============== ============================================================== ================================================ ================================================\n  model          :ref:`ipfs_common/Multihash <IPFS-Common-Multihash.msg>`       CPS behavioral model Identifier                  QmfXHZ2YkNC5vRjp1oAaRoDHD8H3zZznfhBPasTu348eWC\n  objective      :ref:`ipfs_common/Multihash <IPFS-Common-Multihash.msg>`       CPS behavioral model parameters in rosbag file   QmUo3vvSXZPQaQWjb3cH3qQo1hc8vAUqNnqbdVABbSLb6r\n  token          :ref:`ethereum_common/Address <Ethereum-common-Address.msg>`   Operational token address                        0xbD949595eE52346c225a19724084cE517B2cB735\n  cost           :ref:`ethereum_common/UInt256 <Ethereum-common-UInt256.msg>`   CPS behavioral model implementation cost         1\n  lighthouse     :ref:`ethereum_common/Address <Ethereum-common-Address.msg>`   Lighthouse address                               0xa1b60ED40E5A68184b3ce4f7bEf31521A57eD2dB1\n  validator      :ref:`ethereum_common/Address <Ethereum-common-Address.msg>`   Observing network address                        0x0000000000000000000000000000000000000000\n  validatorFee   :ref:`ethereum_common/UInt256 <Ethereum-common-UInt256.msg>`   Observing network commission                     0\n  deadline       :ref:`ethereum_common/UInt256 <Ethereum-common-UInt256.msg>`   Deadline block number                            6393332\n  sender         :ref:`ethereum_common/Address <Ethereum-common-Address.msg>`   Message sender address                           0x0000000000000000000000000000000000000000\n  signature      std_msgs/UInt8[]                                               Sender\'s digital signature                       0x23bc...c617\n=============== ============================================================== ================================================ ================================================\n--\x3e\n\nAn Offer message has the same fields but instead of `validatorFee` there is a `lighthouseFee` field. This field determines the amount of fee for a lighthouse.\n\nNow let\'s have a look at the following diagram and walk step by step from the moment of publishing messages to a liability finalization.\n\n![Robonomics Network detailed scenario](../images/robonomics_network_detailed_scenario.jpg "Robonomics Network detailed scenario")\n\nA liability contract is created only if the following fields match: `model`, `objective`, `token`, `cost`. A provider of Robonomics Network watches every message and finds those ones that have a match.\nAfter the match is found the provider calls `createLiability(demand, offer)` method from the contract factory where `demand` and `offer` are serialized.\n\nBelow is the package diagram for the Robonomics communication stack:\n\n![Robonomics communication stack](../images/robonomics_network_communication_stack.jpg "Robonomics communication stack")\n\nThe factory deserializes arguments and recovers *promisee* and *promisor* addresses from signatures.\n\nNext step is token transfer. The factory transfers **cost** tokens from the *promisee* address and **validatorFee** and **lighthouseFee** from the *promisor* address to the new liability address.\n\n> - **You should approve sufficient amount of tokens for the factory.**\n> - **It\'s not required to approve tokens from the *promisor* address if fees are null.**\n\nNow the factory emits a NewLiability event with the liability address. An agent gets the address, reads fields, perform a task and at the same time writes a log file in rosbag format.\n\nWhen the work is done the agent sends a Result message with the following fields: hash of the rosbag file, a success flag, a signature. If the **validator** field is not null it means that only validator is able to finalize the liability.\n\nAfter the successful liability finalization the agent gets **cost** tokens. Otherwise, the *promisee* gets tokens back.'}},{node:{id:"a66777c01631c978a37c64e440a5c26b",title:"Robonomics DApp Overview",path:"/docs/en/robonomics-dapp-overview/",content:"\nYou can operate with Robonomics Network using the interface of [Robonomics Network Dapp (decentralized application)](https://dapp.robonomics.network/#/). It is available in browsers with [Metamask extension](https://metamask.io). On the first page you will see the statistics of the network:\n\n![Robonomics DApp's first page](../images/robonomics_dapp_first_page.jpg \"Robonomics DApp's first page\")\n\nLet's have a look at the bottom table \"Robonomics Telemetry\".\n\nEvery time an instance of AIRA is launched it broadcasts a piece of information about itself. Usually it takes some time for the Dapp to receive data from an instance of AIRA.\n\nHave a brief look at the page [\"AIRA installation\"](/docs/aira-installation) to understand where `IPNS` and `Address Eth` came from.\n\n## IPNS\n\nYou can treat it as a unique identifier of your instance in IPFS network. Under that name AIRA publishes metadata about itself.\n\n## Address Eth\n\nBy default AIRA generates new Ethereum address for you (it's [possible](/docs/aira-faq#how-to-change-ethereum-address-of-aira) to generate new one).\n\nIt's mainly used to sign all the outcoming messages.\n\n## Lighthouse\n\nIn Robonomics Network an agent must choose a lighthouse to work on. By default it's `airalab.lighthouse.5.robonomics.eth`.\n\nYou can choose existing one or create your own on [Lighthouses](https://dapp.robonomics.network/#/lighthouse) page.\n\n## Peers\n\nThe amount of IPFS pubsub [peers](/docs/aira-faq#how-to-check-the-quantity-of-ipfs-peers).\n\n## Date\n\nThe date and time of last update\n\n## Network\n\nRobonomics Network officially works in Ethereum Mainnet.\nThere is also [Sidechain](https://github.com/airalab/airalab-sidechain) which is mostly for testing purpose.\n\n\n"}},{node:{id:"ed2fcf8244afd9c0bdfc979b0225ebe1",title:"Contracts deployment",path:"/docs/en/robonomics-contracts-deployment/",content:"\nRobonomics network works on top of the existing Ethereum network. The protocol is implemented by smart contracts. A source code is on [Github](https://github.com/airalab/robonomics_contracts). Airalab team deploys new version of contracts and supports a current one. \n\nIn this lesson we are going to learn more about these contracts. To do this we will deploy our test copy. Also we are going to use these contracts in the future lessons. \n\nYou need a client running Ethereum node. You can use either one of existing network (e.g. Mainnet, Ropsten, Kovan) or your local one. For testing purpose we suggest to use this [docker container](https://github.com/f-o-a-m/cliquebait) \n\n    $ docker run --rm -d -p 9545:8545 -p 9546:8546 foamspace/cliquebait:latest\n\nNext step is obtain a copy of robonomics contracts source code:\n\n    $ git clone --recursive https://github.com/airalab/robonomics_contracts\n\nA file truffle.js contains available networks for migration. We will work with development network. When you are in `robonomics_contracts` directory install dependencies and run a migration:\n\n    npm install // to install dependencies\n    truffle migrate --network development\n\nIt's time to learn how to create a new lighthouse. For more information about Robonomics network and Lighthouse in particular read [white paper](http://static.robonomics.network/docs/book-the-economy-of-robots-1-2017/robonomics.network-book-the-economy-of-robots-1-2017-en.pdf). Briefly lighthouse o distributes the running time of providers. Every lighthouse serves its own broadcast channel. Ask and Bid messages come into this channel. XRT tokens are used as a payment. \n\nWhen XRT contracts was deployed some tokens were issued on our account. Let's check the balance:\n\n    $ truffle --network development console\n    > xrt = XRT.at(XRT.address)\n    > xrt.balanceOf(web3.eth.accounts[0])\n\nAnd that's how we create a lighthouse:\n\n    > factory = LiabilityFactory.at(LiabilityFactory.address)\n    > tx = factory.createLighthouse(1000, 10, \"test\")\n    > tx.then(x => {laddress = x.logs[0].args.lighthouse})\n    > l = LighthouseLib.at(laddress)\n\nInstead of deploying a lighthouse contract every time we need a new one, we ask a factory to do this job. A `l` variable contains lighthouse instance. The lighthouse should be able to spend our tokens. Let's make an approve and check everything went well:\n\n    > xrt.approve(l.address,1000)\n    > xrt.allowance(web3.eth.accounts[0],l.address)\n\nAnd a very important step is become a worker:\n\n    > l.refill(1000)\n\nEach worker has to put a stake. In this case it's 1000 Wn.\n\nBelow is a table of our addresses:\n\n| Contract          | Address                                       | ENS name                          |\n|------------------ |--------------------------------------------   |---------------------------------- |\n| ENSRegistry       | 0x80c77a7de64a15450bb8cf45ece4fbb7bae6fb49    |                                   |\n| XRT               | 0x673583a369eb3a830a5571208cf6eb7ce83987f8    | xrt.3.robonomics.eth              |\n| LiabilityFactory  | 0x1b3190e00c1903266862af1f31714d4b81ef59b2    | factory.3.robonomics.eth          |\n| Lighthouse        | 0xd2b78c032b6c8851a8b6cbf950caa02a77618d8e    | test.lighthouse.3.robonomics.eth  |\n"}},{node:{id:"38460669f3a4268c03596c87a93416ce",title:"Become a Provider",path:"/docs/en/robonomics-become-a-provider/",content:'\nThis page describes how to create a lighthouse and become a provider in the Robonomics network.\n\n## Prepare an address\n\nFirst of all, an Ethereum address is required. You must have access to a private key of the address. In case you don\'t have one, below are steps to create an address via [Parity](https://www.parity.io/ethereum/).\n\n```\n$ sudo snap install parity\n$ parity.ethkey generate random\nsecret:  15abe71557c07b69537bbe4352ed10a057be89037c69d4b35556112519911539\npublic: 38b800bfd90d486c78c646da79bb94b9d038aca8aad221062ce1b148df7764bfef02f6b3cf931786b6997540b798ea226ae60bd201c222d8f702e408a1a5cbff\naddress: c531fa8f141493df3da264a864bdcbec19695b4c\n```\n\nThe `secret` field is a private key, you\'ll need it to run the provider client. Save it to a file:\n\n```\n$ echo \'0x15abe71557c07b69537bbe4352ed10a057be89037c69d4b35556112519911539\' > private.key\n```\n\nThe next step is to deposit some ethers and XRT tokens to the address which is held in the `address` field.\n\n## Create a lighthouse\n\nGo to the lighthouse [dapp](https://dapp.robonomics.network/#/lighthouse) and fill in a name in the right side:\n\n![The Right Side](../images/become_a_provider_1.jpg "The Right Side")\n\nClick on the `Create lighthouse and connect to the network` button and sign a transaction. After a while you should see:\n\n![Success of Creating a Lighthouse](../images/become_a_provider_2.jpg "Success of Creating a Lighthouse")\n\nNow it\'s time to put a stake. Select the new lighthouse and click `Connect to the network`:\n\n![Selecting the Lighthouse](../images/become_a_provider_3.jpg "Selecting the Lighthouse")\n\nOn this page in the `Provider` section click the `Approve` button, sign a transaction. When it\'s mined click the `Refill` button and do the same.\n\n## Install the client\n\nNow you need to install [robonomics-tools](https://github.com/airalab/robonomics-tools) at least 0.4.2 version. You can build from the source or do the following steps:\n\n**Make sure you have Nix and Stack installed:**\n    \n```\n$ curl -sSL https://get.haskellstack.org/ | sh\n$ curl https://nixos.org/nix/install | sh\n```\n\n* Setup Airalab binary cache at [https://aira.cachix.org](https://aira.cachix.org/)\n* Import Airalab channel:\n\n```\n$ nix-channel --add http://aira.life/channels/aira-unstable/ aira\n$ nix-channel --update\n```\n* Install from the binary cache:\n\n```\n$ nix-env -iA aira.robonomics-tools\n```\n* Run the client:\n\n```\n$ xrtd --lighthouse mobilerobotics.lighthouse.5.robonomics.eth --private $(cat private.key)\n```\n\n**Get familiar with the `xrtd` options via `xrtd --help`.**\n\n## Test the provider\n\nTo test your provider go again to the lighthouse [dapp](https://dapp.robonomics.network/#/lighthouse/) and connect to the just created lighthouse.\n\nAt the bottom you should see the `TEST LIGHTHOUSE` section.\n\nClick on the `Demand` button and then on the `Offer` one. You should see something similar to:\n\n![Demand and Offer messages](../images/provider_mobilerobotics_demand_offer.jpg "Demand and Offer messages")\n\nDon\'t forget to sign every message with the MetaMask extension.\n\nFinally you should see a new liability contract created:\n\n![Liability is created](../images/provider_mobilerobotics_liability.jpg "Liability is created")\n'}},{node:{id:"2d12347845d967b80ccebe4a8dac412a",title:"Robonomics IO Overview",path:"/docs/en/rio-overview/",content:"\nThe [crate](https://crates.robonomics.network/robonomics_io/index.html) provides a convenient way to interact with blockchain and includes a set of tools. The latest release can be found [here](https://github.com/airalab/robonomics/releases)\n\n```\n% ./robonomics io\nrobonomics-io 0.21.0\nRobonomics Framework I/O operations\n\nUSAGE:\n    robonomics io [FLAGS] [OPTIONS] <SUBCOMMAND>\n\nFLAGS:\n        --dev        Specify the development chain\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nOPTIONS:\n    -d, --base-path <PATH>        Specify custom base path\n        --chain <CHAIN_SPEC>      Specify the chain specification (one of dev, local, or staging)\n    -l, --log <LOG_PATTERN>...    Sets a custom logging filter. Syntax is <target>=<level>, e.g. -lsync=debug\n\nSUBCOMMANDS:\n    help     Prints this message or the help of the given subcommand(s)\n    read     Read information from device\n    write    Write information into device\n```\n\n## The Pipeline Philosophy \n\nThe tool is designed in order to be included in a pipeline chain of processes. From Unix user experience everyone is familiar with commands like:\n\n```\nps aux | grep robonomics\n```\n\nIt means standard output produced by the `ps` program becomes standard input for the `grep` program. \n\nThe `robonomics io` consists of several subcommands with reading, writing abilities or both. It treats everything as a virtual or physical device ([everything is a file](https://en.wikipedia.org/wiki/Everything_is_a_file))\n\n## Read Overview\n\nIn general `read` means it reads data from a device or a network and prints it in `stdout`.\n\nHow to use it for:\n\n* [ipfs](/docs/rio-ipfs)\n* [launch](/docs/rio-launch)\n\n```\n% ./robonomics io read\nrobonomics-io-read 0.4.0\nRead information from device\n\nUSAGE:\n    robonomics io read <SUBCOMMAND>\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nSUBCOMMANDS:\n    help      Prints this message or the help of the given subcommand(s)\n    ipfs      Download data from IPFS storage\n    launch    Robot launch request events\n    pubsub    Subscribe for broadcasing data\n    sds011    Nova SDS011 particle sensor\n```\n\n## Write Overview\n\nUsually it writes data to blockchain or publishes to pubsub channel. \n\nHow to use it for:\n\n* [datalog](/docs/rio-datalog)\n* [ipfs](/docs/rio-ipfs)\n* [launch](/docs/rio-launch)\n\n```\n% ./robonomics io write\nrobonomics-io-write 0.4.0\nWrite information into device\n\nUSAGE:\n    robonomics io write <SUBCOMMAND>\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nSUBCOMMANDS:\n    datalog    Data blockchainization subsystem command\n    help       Prints this message or the help of the given subcommand(s)\n    ipfs       Upload data into IPFS storage\n    launch     CPS launch subsystem command\n    pubsub     Broadcast data into PubSub topic\n```\n\n## Local Testnet\n\nFor testing purpose it's possible to run the development environment:\n\n```\n% ./robonomics --dev --rpc-cors all\n```\n\n`--rpc-cors all` allows the [Dapp](https://parachain.robonomics.network/) to be connected to local node. After launching the node, go to the dapp, click on Robonomics icon in the upper left corner, choose Development and put node's local address\n\n![Robonomics Dapp Connect to Local Node](../images/robonomics-dapp-connect-local.jpg \"Robonomics Dapp Connect to Local Node\")\n\nFinally click Switch and you should be connected to the local node. Check out Accounts tab. There you can create new accounts and transfer tokens.\n\n"}},{node:{id:"7884b4cc30c48b7ecb83c871b9ada04d",title:"Robonomics IO Launch",path:"/docs/en/rio-launch/",content:'\nA simple way to turn on and off an IoT device or a robot. Basically sending "ON" will result in `true` state for a device, anything else will result in `false`.\n\nFor the examples the development network is used. Check [this](/docs/robonomics-test-network-manual/) out to set it up for yourself.\n\n## Requirements\n\n* `robonomics` [executable](https://github.com/airalab/robonomics/releases)\n* Accounts on parachain\n\nYou can find instructions on how to create an account [here](/docs/create-account-in-dapp)\n\n## Usage\n\nTo see the result of transaction first of all run `read` part:\n\n```\n% ./robonomics io read launch\n```\n\nNow let\'s turn a robot on:\n\n```\n% echo "ON" | ./robonomics io write launch -r 5CiPPseXPECbkjWCa6MnjNokrgYjMqmKndv2rSnekmSK2DjL -s 0xb046fc3c322e91e14a61ad4f08a3809ee0de7092e73aa9b3c2b642a0f476d4d6\n```\n\nThen you should see in the first terminal window:\n\n```\n% ./robonomics io read launch\n5H3iRnX16DH2sb2RLxMM8UhDZTvJjP84EhhKXv3sCiEDq6bH >> 5CiPPseXPECbkjWCa6MnjNokrgYjMqmKndv2rSnekmSK2DjL : true\n```\n\nLet\'s describe all the accounts and options above.\n\n* `-r 5CiPPseXPECbkjWCa6MnjNokrgYjMqmKndv2rSnekmSK2DjL` means robot\'s address\n* `-s 0xb046fc3c322e91e14a61ad4f08a3809ee0de7092e73aa9b3c2b642a0f476d4d6` private key of the account to launch from (must have tokens for a transaction)\n* `5H3iRnX16DH2sb2RLxMM8UhDZTvJjP84EhhKXv3sCiEDq6bH` address that launches a robot\n* `true` turn it on\n\nIf we pass anything else but "ON" the state becomes `false`\n\n## Remote\nIf your local node is configured differently from defaults or you have a remote node, it\'s possible to specify it with `--remote` option\n\n```\n% echo "ON" | ./robonomics io write launch -r 5CiPPseXPECbkjWCa6MnjNokrgYjMqmKndv2rSnekmSK2DjL -s 0xb046fc3c322e91e14a61ad4f08a3809ee0de7092e73aa9b3c2b642a0f476d4d6 --remote https://ipfs.infura.io:5001/\n```\n\nand\n\n```\n% ./robonomics io read launch --remote https://ipfs.infura.io:5001/\n```\n'}},{node:{id:"0968e8bef3bf20db256bc7f5494181d0",title:"Robonomics IO IPFS",path:"/docs/en/rio-ipfs/",content:'\nIt serves downloading and uploading files from/to IPFS network\n\n## Requirements\n\n* `robonomics` [executable](https://github.com/airalab/robonomics/releases)\n* Running [IPFS](https://ipfs.io/#install) daemon \n\n## Write\n\n```\n% echo "Hello Robonomics" | ./robonomics io write ipfs\nQmQAcvgXmcZEjXGibXGFcqdsvvrnWp3BguuubWhzSBZMXy\n```\n\n## Read\n\n```\n% echo QmQAcvgXmcZEjXGibXGFcqdsvvrnWp3BguuubWhzSBZMXy | ./robonomics io read ipfs\nHello Robonomics\n```\n\n## Remote IPFS node\n\nIf your local node is configured differently from defaults or you have a remote node, it\'s possible to specify it with `--remote` option\n\n```\n% echo "Hello Robonomics" | ./robonomics io write ipfs --remote https://ipfs.infura.io:5001/\nQmQAcvgXmcZEjXGibXGFcqdsvvrnWp3BguuubWhzSBZMXy\n```\n\nThe same applies for `read`\n\n'}},{node:{id:"3cca167666ccf714908c2933bef57949",title:"Robonomics IO Datalog",path:"/docs/en/rio-datalog/",content:'\nDatalog module allows you to store any string on blockchain\n\nhttps://www.youtube.com/watch?v=rs67AMyd-gE\n\nFor the examples the development network is used. Check [this](/docs/robonomics-test-network-manual/) out to set it up for yourself.\n\n## Requirements\n\n* `robonomics` [executable](https://github.com/airalab/robonomics/releases)\n* Account on parachain\n\nYou can find instructions on how to create an account [here](/docs/create-account-in-dapp)\n\n## Write\n\nAssuming local node is running:\n\n```\n% echo "Hello Robonomics" | ./robonomics io write datalog -s 0xb046fc3c322e91e14a61ad4f08a3809ee0de7092e73aa9b3c2b642a0f476d4d6\n```\n\nwhere `0xb046fc3c322e91e14a61ad4f08a3809ee0de7092e73aa9b3c2b642a0f476d4d6` is a private key for the account with tokens.\nIn this example the public key is 5H3iRnX16DH2sb2RLxMM8UhDZTvJjP84EhhKXv3sCiEDq6bH. Let\'s go to the [Dapp](https://parachain.robonomics.network/)\nand see what happened.\n\nIn the Dapp go to Developer -> Chain state. In the "selected state query" list choose datalog and below choose your account. Click plus button on the right and you should see the following:\n\n![Robonomics Chain State Datalog](../images/robonomics-dapp-chain-state-datalog.jpg "Robonomics Chain State Datalog")\n\n## Remote\nIf your local node is configured differently from defaults or you have a remote node, it\'s possible to specify it with `--remote` option\n\n```\n% echo "Hello Robonomics" | ./robonomics io write datalog -s 0xb046fc3c322e91e14a61ad4f08a3809ee0de7092e73aa9b3c2b642a0f476d4d6 --remote https://ipfs.infura.io:5001/\n```\n'}},{node:{id:"376c7e94c7eeadf889cc04d7064c4bdf",title:"R&D Based on Robonomics Network",path:"/docs/en/r-and-d-based-on-robonomics-network/",content:'\nFor over 4 years, the Robonomics project participants completed 13 R&D projects in the process of writing the current version of the Robonomics platform, including:\n\n### Launching a drone under the control of a decentralized computer.\n2016 - Successful field test of 3DR X8 drone compatibility with Drone Employee software.\nBelow you can observe a workflow in which a person sends a Drone transaction through the Ethereum Blockchain.\n\nhttps://www.youtube.com/watch?v=V_3rcP2Duv0&t=1s\n\n### Management of a fleet of drones in a decentralized network.\n[Distributed Sky](https://airmarket.io/wp-content/uploads/2018/09/Distributed-Sky-Whitepaper-v3.0.pdf) is the backbone of the Unmanned aircraft system traffic management (UTM). It uses a global network of computers to process and store identities, traffic and other sensitive information, and uses cryptography to make the UTM process secure and scalable.\nBelow is the video of Drone Passport agent in action.\n\nhttps://www.youtube.com/watch?v=yxGTOkGkBJ8\n\n### Tokenization of data from IoT devices.\n\nThe 4th industrial revolution is flying the flag of CPSs’ total integration into mass production and rendering services. Machines do not engage in empty talk, they are honest in their work and can be an independent party supplying information, based on algorithmic analysis of which the network itself can emit new units of any value.\nValues based on the labor of machines will be much more interesting for the new generation than other values, the emission of which is built on any other principle. More information available [here](https://blog.aira.life/tokenization-and-the-4th-industrial-revolution-3208022be747)\n\n### Digital markets for robots.\n\n### Industrial zone management with capital.\n[The article](https://ieeexplore.ieee.org/abstract/document/8525391) presents the architecture of communication protocol for modern industrial processes and business based on cyber-physical systems - Industry 4.0. The main attention is paid to one of the key trends of this concept - to economical autonomous agents i.e. to robots or smart things, which are able to make decisions independently about their economic actions. Agents begin to fully participate in business processes, so it is important to automate the processes and ensure formal and secure communication between multiple heterogeneous agents, taking into account the economic component of the industry. The article shows how to organize economic interaction between agents using a peer-to-peer network based on decentralized Blockchain technology and smart contracts. More information about Industry 4.0 may be found in a video below.\n\nhttps://www.youtube.com/watch?v=yuxOF_z70us\n\n### Drones, sensors, and blockchain for monitoring the quality of water on the Volga.\nAs part of [this river project](https://github.com/airalab/drone_on_volga), the drone offers its services through a web application allowing any user to request the service. Typically, the mission generates parameters such as drone position, travel speed, measured water quality parameters, and other minor requirements.\nThe Robonomics network is used to communicate with the robot. With its help, the robot can offer its services, and citizens or government officials can order them by making a cryptocurrency payment through the website. The Robonomics network is built on the Ethereum blockchain platform and the IPFS protocol, which record the hash of sensor measurements in the public blockchain and thus protect historical data from possible falsification.\nFascinating video about experiments with water drone is below.\n\nhttps://www.youtube.com/watch?v=Mtqm5y6Bolo\n\n### Civilian observatory networks.\nIn August 2018 Airalab with support of Smart Distribution (Libelium distributor in Russia) [set up a measuring network in a living district in Tolyatti, Russia](https://www.libelium.com/libeliumworld/success-stories/preventing-asthsma-sensor-network-air-quality-pm10-dust-in-play-area/).\nThe aim was to create the basis for the implementation of an air quality monitoring network in areas of special vulnerability (schools, playgrounds, nursing homes, hospitals, etc.) that can provide local authorities with information to take measures to protect their citizens.\nAn example of using a sensor is shown in a video below. Also, source code may be found [here](https://github.com/airalab/sensors-connectivity).\n\nhttps://www.youtube.com/watch?v=shqey3tmNUk\n\n### Robot artist Gaka-chu.\nModern technologies make human life more comfortable and more fun, freeing up time for reflection and experimentation.\nIt was a series of reflections on the static nature of the industry that led the development team to the idea of ​​conducting an experiment showing the autonomous transformation of production for a specific type of product.\nSuch an experiment became a [robot artist](https://github.com/airalab/robot_painter/) - a small, clumsy KUKA manipulator living in a large world of serious industrial robots. And his name is Gaka-chu. Why? Because of the love of drawing: "gaka" in Japanese is "artist". And "chu" was added for an inexplicable love for Pokemons.\n\nhttps://youtu.be/xSD_lsrAA0I\n\n### Issuance of green certificates based on the data from renewable energy sources.\nThe conceptual goal of [DAO IPCI](https://ipci.io/ru/) is to provide a common space, common environment, tools and ecosystem that is universal, reliable, easy to use, allowing a variety of stakeholders, including businesses and people, to record quantitative impacts and quantitative commitments, invest in negative impact mitigation projects, offset the carbon footprint, acquire and trade mitigation results, join existing programs or launch new ones. Source code is provided [here](https://github.com/DAO-IPCI/DAO-IPCI).\n\nhttps://www.youtube.com/watch?v=q9plB0TjUnw&list=PLLepqB9oh7WvUVzbeaiwQojrip2tLPA6P\n\n### Roadspace negotiation for autonomous cars.\nOur goal was to develop a [decentralized system](https://github.com/khssnv/mobi_grand_challenge) for road space negotiation where autonomous vehicles can pay for routes and right of way. We believe a market-based approach can be used to alleviate a traffic congestion problem.\n\nhttps://youtu.be/JFQTknMZOYg\n\n### Blockchain in the tasks of the chemical industry.\nOriginally the following task was set: developing a [quality control system](https://github.com/Vourhey/chemistry-quality-control) for the production of a certain chemical product. Why is monitoring the quality so important here? The main active substance of this chemical product is chlorine dioxide. It is hazardous to health in high concentrations. And if the concentration is below normal, then this chemical product is useless.\nAnd what does Blockchain have to do with it? Blockchain helps building trust to the manufacturing company. The consumer knows that no one can change the information in the Blockchain. That means that the manufacturing company can not forge the results of the audit.\n\n### Control of equipment maintenance process by supply chain participants based on IoT data.\n\n### Robot as a service in service robotics.\nRobonomics is the ready-to-work and open-source platform which you can use to connect your robot as a service for end-users, they call it [‘Robot-as-a-Service’](https://blog.aira.life/how-can-you-hire-a-robot-176ba29da565). Robonomics support Web3 technologies that implement the exchange of technical and economic information between humans and machines. Robonomics is a purely technical and open source project.\n\nhttps://www.youtube.com/watch?v=IEgvXcj3nSo'}},{node:{id:"a4ca7d0ebae2846d3b73bee1f0778675",title:"Playground Overview",path:"/docs/en/playground-overview/",content:"\nRobonomics allows to use robots as autonomous agents that receive commands from a human or another robot and do some useful work, storing a report of their actions in Blockchain. The interaction between the robot and the Robonomics platform is quite simple with a [Robonomics IO](/docs/rio-overview).\n## What Robots You Can Control\nThe playground section contains examples of connecting different robots to Robonomics which everyone can try to repeat step by step. In this section you can try to control:\n* [an Unmanned Aerial Vehicle](/docs/iris-drone/)\n* [a Mars Rover](/docs/connect-mars-curiosity-rover-under-robonomics-parachain-control/)\n* [a Manipulator](/docs/kuka/)\n* [an industrial Baxter Robot](/docs/baxter2/)\n\nSince all robots are available as simulation models, you don't need any special hardware. So you can try to connect the robot to Robonomics Network right now.\n## How Do You Control the Robot\nAll of our Demos are launched in a local network, however you can connect a robot to the live networks in the same way.\n\nAll Demos in this section follow a similar scenario. You [create an account](/docs/create-account-in-dapp/) for the robot and send him some units for paying transactions. Then the user sends an `ON/OFF` transaction to the robot's address, the robot receives it and starts working. After the job is done the telemetry is saved in IPFS and the file hash is sent to datalog. So at any time you can see how the robot performed its work.\n## Connect Your Own Robot\nIn addition you can create your own control package for any ROS-compatitable device with [this](/docs/connect-any-ros-compatitable-robot-under-robonomics-parachain-control-1/) instruction.\n\n"}},{node:{id:"3eda88f08d6b104fb3840468555c2abd",title:"Market messages",path:"/docs/en/market-messages/",content:"\nMarket messages is used for exchange **Demand** and **Offer** information. It also used for delivery **Result** messages with liability execution reports.\n\n> This is spec for Robonomics `Generation 5`.\n\n- Currently for message delivery is used [IPFS PubSub](https://ipfs.io/blog/25-pubsub/) broadcaster.\n- IPFS PubSub **topic** is set according to *Lighthouse [ENS](https://ens.domains/) name*.\n\n## Messages content\n\nRobonomics market message use [JSON](https://www.json.org/) data format.\n\n\n### Demand\n\n| Field | ROS Type | Description |\n|-------------- |-------------------------  |------------------------------------------------ |\n| model | [ipfs_common/Multihash](/docs/ipfs-common-messages#ipfs_commonmultihashmsg) | CPS behavioral model identifier |\n| objective | [ipfs_common/Multihash](/docs/ipfs-common-messages#ipfs_commonmultihashmsg) | CPS behavioral model parameters in rosbag file |\n| token | [ethereum_common/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) | Operational token address |\n| cost | [ethereum_common/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg) | CPS behavioral model execution cost |\n| lighthouse | [ethereum_common/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) | Lighthouse contract address |\n| validator | [ethereum_common/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) | Observing network address |\n| validatorFee  | [ethereum_common/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg) | Observing network fee |\n| deadline | [ethereum_common/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg) | Deadline block number |\n| nonce | [ethereum_common/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg) | Robonomics message counter |\n| sender | [ethereum_common/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg) | Message sender address |\n| signature | std_msgs/UInt8[] | Sender’s Ethereum signature |\n\n### Offer\n\n| Field             | ROS Type                  | Description                                       |\n|---------------    |-------------------------  |------------------------------------------------   |\n| model             | [ipfs_commom/Multihash](/docs/ipfs-common-messages#ipfs_commonmultihashmsg)     | CPS behavioral model identifier                   |\n| objective         | [ipfs_commom/Multihash](/docs/ipfs-common-messages#ipfs_commonmultihashmsg)     | CPS behavioral model parameters in rosbag file    |\n| token             | [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg)   | Operational token address                         |\n| cost              | [ethereum_commom/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg)   | CPS behavioral model execution cost               |\n| validator         | [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg)   | Observing network address                         |\n| lighthouse        | [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg)   | Lighthouse contract address                       |\n| lighthouseFee     | [ethereum_commom/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg)   | Liability creation fee                            |\n| deadline          | [ethereum_commom/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg)   | Deadline block number                             |\n| nonce             | [ethereum_commom/UInt256](/docs/ethereum-common-messages#ethereum_commonuint256msg)   | Robonomics message counter                        |\n| sender            | [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg)   | Message sender address                            |\n| signature         | std_msgs/UInt8[]          | Sender’s Ethereum signature                       |\n\n### Result\n\n| Field         | ROS Type                  | Description                       |\n|-----------    |-------------------------  |---------------------------------- |\n| liability     | [ethereum_commom/Address](/docs/ethereum-common-messages#ethereum_commonaddressmsg)   | Liability contract address        |\n| result        | [ipfs_commom/Multihash](/docs/ipfs-common-messages#ipfs_commonmultihashmsg)     | Liability result multihash        |\n| success       | std_msgs/Bool             | Is liability executed successful  |\n| signature     | std_msgs/UInt8[]          | Sender’s Ethereum signature       |\n\n## Messages signing\n\nBefore signing the messages is packed using [abi.encodePacked](https://solidity.readthedocs.io/en/latest/abi-spec.html#non-standard-packed-mode\n) solidity finction and hashed by Keccak_256.\n\n```\n   demandHash = keccak256(abi.encodePacked(\n        _model\n      , _objective\n      , _token\n      , _cost\n      , _lighthouse\n      , _validator\n      , _validator_fee\n      , _deadline\n      , IFactory(factory).nonceOf(_sender)\n      , _sender\n      ));\n```\n\n**`nonce` parameter is counted by factory smart contract and incremented for each created liability smart contract.**\n\nMessage hash are signed using Ethereum ``secp256k1`` [signature](https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign).\n"}},{node:{id:"1728cb019b80fdaa683459a0197ec16c",title:"Control Kuka manipulator with robonomics",path:"/docs/en/kuka/",content:"\nVideo with an example of work can be found here:\n\n[https://youtu.be/Fhf9LIt6zXQ](https://youtu.be/Fhf9LIt6zXQ)\n***\n## Requirements\n* ROS melodic, Gazebo (installation instraction [here](http://wiki.ros.org/melodic/Installation/Ubuntu))\n* Some extra packages\n```bash\nsudo apt-get install ros-melodic-gazebo-ros-control ros-melodic-effort-controllers ros-melodic-joint-state-controller\n```\n* IPFS 0.4.22 (download from [here](https://www.npackd.org/p/ipfs/0.4.22) and install)\n```bash\ntar -xvzf go-ipfs_v0.4.22_linux-386.tar.gz\ncd go-ipfs/\nsudo bash install.sh\nipfs init\n```\n* pip\n```bash\nsudo apt install python-pip\n```\n* ipfshttpclient\n```bash\npip install ipfshttpclient\n```\n* Robonomics node (binary file) (download latest release [here](https://github.com/airalab/robonomics/releases))\n* IPFS browser extension (not necessary)\n***\n## Installation\nInstall Kuka manipulator and control packages\n```bash\ncd catkin_ws/src/\ngit clone https://github.com/orsalmon/kuka_manipulator_gazebo\ngit clone https://github.com/LoSk-p/kuka_controller\ncd ..\ncatkin_make\necho \"source /home/$USER/catkin_ws/devel/setup.bash\" >> ~/.bashrc\n```\n***\n## Running gazebo model\n```bash\nroslaunch manipulator_gazebo manipulator_empty_world.launch\n```\nIn a new window\n```bash\nrosrun manipulator_gazebo move_arm_server\n```\n![model](../images/kuka-demo/gazebo.jpg)\n***\n## Running robonomics\nGo to the folder with robonomics file ad create a local robonomics network:\n```bash\n./robonomics --dev --rpc-cors all\n```\n\n![robonomics](../images/kuka-demo/robonomics.jpg)\n\n**Important!** Before next launches it is necessary to remove a directory `db` with\n\n```\nrm -rf /home/$USER/.local/share/robonomics/chains/dev/db\n```\n\nGo to https://parachain.robonomics.network and switch to local node\n\n![local](../images/kuka-demo/local.jpg)\n\nThen go to Accounts and create KUKA and WORK accounts. Save account's addresses and keys, you will need them later\n\n![acc](../images/kuka-demo/create_account.jpg)\n\n![accs](../images/kuka-demo/accounts.jpg)\n***\n## Running ipfs\nRun ipfs daemon:\n```bash\nipfs daemon\n```\n***\n## Running control package\nIn kuka_control package path you need to edit move_arm_client.py. \n```bash\ncd src/\nnano move_arm_client.py\n```\nChange kuka_address, kuka_key and work_address to you addresses and key, then change robonomics_path to your path to file robonomics.\n\n![code](../images/kuka-demo/code.jpg)\n\nNow you can run control script:\n```bash\npython move_arm_client.py\n```\n![control](../images/kuka-demo/control.jpg)\n\nThen in a new window send a transaction to make Kuka move:\n```bash\necho \"ON\" | ./robonomics io write launch -r <KUKA_ADDRESS> -s <WORK_KEY>\n```\nWhere <KUKA_ADDRESS> and <WORK_KEY> are address and key from your accounts:\n\n![transaction](../images/kuka-demo/transaction.jpg)\n\nIn the window with kuka_control package you will see:\n\n![done](../images/kuka-demo/done.jpg)\n\nThen go Developer/Chain state on the Robonomics portal, select datalog in query and add KUKA datalog with button '+':\n\n![datalog](../images/kuka-demo/datalog.jpg)\n\nNow you can find Kuka's telemetry using this hash in IPFS Companion:\n\n![ipfs](../images/kuka-demo/ipfs.jpg)\n\n![telemetry](../images/kuka-demo/telemetry.jpg)\n\n## Troubleshooting\n\nIf `catkin_make` doesn't work with the message that it can't find MoveArm.h, try to remove last four lines in CMakeLists.txt in kuka_manipulator_gazebo package:\n```\ninclude_directories(include ${catkin_INCLUDE_DIRS})\n\nadd_executable(move_arm_server src/move_arm_server.cpp)\ntarget_link_libraries(move_arm_server ${catkin_LIBRARIES})\nadd_dependencies(move_arm_server beginner_tutorials_gencpp)\n```\nDo `catkin_make` without these lines, then returm them and do `catkin_make` again.\n\n\n\n\n"}},{node:{id:"8ef04d7a6ebb48a483aa351b739426cd",title:"Drone control with robonomics",path:"/docs/en/iris-drone/",content:'\n**Drone starts moving after transcation and store file with the coordinates in IPFS. The control script is based on the [GAAS demo script](https://github.com/generalized-intelligence/GAAS)**  \n\nhttps://youtu.be/4CwtGAX1OwM\n\n## Requirements\n* dependencies for control:\n``` sh\nsudo apt install -y \\\n\tpython3-pip \\\n\tninja-build \\\n\texiftool \\\n\tpython-argparse \\\n\tpython-empy \\\n\tpython-toml \\\n\tpython-numpy \\\n\tpython-yaml \\\n\tpython-dev \\\n\tpython-pip \\\n\tninja-build \\\n\tprotobuf-compiler \\\n\tlibeigen3-dev \\\n\tgenromfs\n```\n```sh \npip3 install \\\n\tpandas \\\n\tjinja2 \\\n\tpyserial \\\n\tcerberus \\\n\tpyulog \\\n\tnumpy \\\n\ttoml \\\n\tpyquaternion\n```\n* ROS Melodic + Gazebo [installation tutorial](http://wiki.ros.org/melodic/Installation)\n* extra packages: \n``` bash \nsudo apt-get install ros-melodic-gazebo-ros-control ros-melodic-effort-controllers ros-melodic-joint-state-controller\nsudo apt-get install python-jinja2\nsudo apt-get install python-catkin-pkg\nsudo apt-get install python3-catkin-pkg-modules\n```\n* IPFS verson 0.4.22\n```bash\nwget https://dist.ipfs.io/go-ipfs/v0.4.22/go-ipfs_v0.4.22_linux-amd64.tar.gz\ntar -xvzf go-ipfs_v0.4.22_linux-amd64.tar.gz\ncd go-ipfs\nsudo bash install.sh\nipfs init\n```\n* ipfshttpclient\n```sh\npip3 install ipfshttpclient\n```\n* Robonomics node (binary file) (download latest release [here](https://github.com/airalab/robonomics/releases))\n## Environment Setup\n```bash \nsudo apt-get install ros-melodic-mavros ros-melodic-mavros-extras\nwget https://raw.githubusercontent.com/mavlink/mavros/master/mavros/scripts/install_geographiclib_datasets.sh\nsudo ./install_geographiclib_datasets.sh\ncd ~/catkin_ws/src\ngit clone https://github.com/PX4/Firmware.git\ncd Firmware\ngit checkout v1.9.0\nbash ./Tools/setup/ubuntu.sh\n```\n```bash\ncd ~/catkin_ws/src\ngit clone https://github.com/generalized-intelligence/GAAS.git\ncp -r ~/catkin_ws/src/GAAS/simulator/models/* ~/catkin_ws/src/Firmware/Tools/sitl_gazebo/models/\ncp -r ~/catkin_ws/src/GAAS/simulator/worlds/* ~/catkin_ws/src/Firmware/Tools/sitl_gazebo/worlds/\ncp -r ~/catkin_ws/src/GAAS/simulator/posix-config/* ~/catkin_ws/src/Firmware/posix-configs/SITL/init/ekf2/\n```\n\nModifying your `.bashrc` file, adding the following lines to the bottom:  \n\n`source ~/catkin_ws/devel/setup.bash `  \n`source ~/catkin_ws/src/Firmware/Tools/setup_gazebo.bash ~/catkin_ws/src/Firmware/ ~/catkin_ws/src/Firmware/build posix_sitl_default `   \n`export GAZEBO_MODEL_PATH=:~/catkin_ws/src/simulator/models`  \n`export ROS_PACKAGE_PATH=$ROS_PACKAGE_PATH:~/catkin_ws/src/Firmware`  \n`export ROS_PACKAGE_PATH=$ROS_PACKAGE_PATH:~/catkin_ws/src/Firmware/Tools/sitl_gazebo`  \n`export GAZEBO_MODEL_PATH=:~/catkin_ws/src/simulator/models:~/catkin_ws/src/GAAS/simulator/models`  \n\n  \n## Control Package Installation\nIn a new Terminal:\n```bash\ncd catkin_ws/src\ngit clone https://github.com/tubleronchik/robonomics_drone_sim.git\ncd ..\ncatkin build\n```\n## Robonomics Network\nTo create a local robonomics network go to the folder with the robonomic binary file and run:  \n`./robonomics --dev --rpc-cors all`  \n\nAdd robonomic\'s path to `config.py`\n\n![IPFS](../images/iris-drone-demo/IPFS.jpg)\n\nGo to the [Robonomics Portal](https://parachain.robonomics.network) and switch to local node.\n![localNode](../images/iris-drone-demo/localNode.jpg)\n\nGo to **Accounts** and create **DRONE** and **EMPLOYER** accounts. Save the account names and keys and path to **robonomics** to `~/catkin_ws/src/drone_sim/src/config.py`. Transfer some money into the accounts.\n\n![accounts](../images/iris-drone-demo/addingAcc.jpg)\n\n## Running Simulation\nRun IPFS daemon\n```bash\ncd go-ipfs\nipfs daemon\n```\nIn another terminal launch the simulation:\n```bash\nroslaunch px4 mavros_posix_sitl.launch\ncd ~/catkin_ws/src/robonomics_drone_sim/src\npython3 takeoff.py\n```\nWaiting till "Waiting for payment" \n\n![launch](../images/iris-drone-demo/launch.jpg)\n\nTo send a transaction run in another window:\n`echo "ON" | ./robonomics io write launch -r <drone_addres> -s <employer_key>` - where **<drone_address>** and **<employer_key>** should be replaced with the strings from `config.py` accordingly.\n\nAfter data was pushed to IPFS, go to the **Chain State** in [Robonomics Portal](https://parachain.robonomics.network). Select **datalog** in query and add DRONE datalog using `+` button.\n\n![datalog](../images/iris-drone-demo/datalog.jpg)\n\nYou can find drone\'s telemetry running `https://gateway.ipfs.io/ipfs/<hash>` inserting the hash from above.\n\n![output](../images/iris-drone-demo/output.jpg)\n\nIt\'s important to remove `db` derictory before next launches using  \n` rm -rf ~/.local/share/robonomics/chains/dev/db`\n'}},{node:{id:"a0c236441cc3a242f9f97b670461cd82",title:"IPFS Common",path:"/docs/en/ipfs-common/",content:'\nThe package handle IPFS connections, provides useful services for working with IPFS Network. \nIt\'s included in `robonomics_liability` launch file\n\n## ROS Parameters\n\n### ~lighthouse_contract\n\nThe name of a lighthouse you are working on. The type is `string`, defaults to `airalab.lighthouse.5.robonomics.eth`\n\n### ~ipfs_http_provider\n\nIPFS HTTP provider address. The type is `string`, defaults to `http://127.0.0.1:5001`\n\n### ~ipfs_public_providers\n\nA public IPFS node to pin result files. The type is `string`, defaults to `""`\n\n### ~ipfs_file_providers\n\nA list of public nodes to pin result files. The type is `list of strings`, defaults to `[ipfs_public_providers]`\n\n### ~ipfs_swarm_connect_addresses\n\nIPFS nodes to connect to. The type is `string`, defaults to `""`\n\n### ~ipfs_swarm_connect_to\n\nA list of IPFS nodes to connect to. The type is `list of strings`, defaults to `[ipfs_swarm_connect_addresses]`\n\n## Subscribed topics'}},{node:{id:"1c97dab403b722084f63508eb05f6cad",title:"IPFS Common Messages",path:"/docs/en/ipfs-common-messages/",content:"\n## ipfs_common/Filepath.msg\n\n| Field         | Type                  | Description           |\n|------------   |-------------------    |--------------------   |\n| filepath      | std_msgs/String       | A path to a file      |\n\n## ipfs_common/Multihash.msg\n\n| Field         | Type              | Description                               |\n|-----------    |-----------------  |------------------------------------------ |\n| multihash     | std_msgs/String   | A wrapper for model and objective fields  |\n\n## ipfs_common/IpfsDownloadFile.srv\n\n**Request**\n\n| Field         | Type                                                  | Description               |\n|-------------- |---------------------------------------------------    |------------------------   |\n| ipfs_address  | [ipfs_common/Multihash](#ipfs_commonmultihashmsg)     | IPFS hash of a file       |\n| file          | [ipfs_common/Filepath](#ipfs_commonfilepathmsg)       | Where to save the file    |\n\n**Response**\n\n| Field         | Type              | Description           |\n|-----------    |-----------------  |---------------------  |\n| success       | std_msgs/Bool     | Status of execution   |\n| error_msg     | std_msgs/String   | Error message         |\n\n## ipfs_common/IpfsUploadFile.srv\n\n**Request**\n\n| Field     | Type                                              | Description                               |\n|-------    |-------------------------------------------------  |---------------------------------------    |\n| file      | [ipfs_common/Filepath](#ipfs_commonfilepathmsg)   | Path to a file to be uploaded to IPFS     |\n\n**Response**\n\n| Field         | Type                                                  | Description                   |\n|-------------- |---------------------------------------------------    |----------------------------   |\n| success       | std_msgs/Bool                                         | Status of execution           |\n| error_msg     | std_msgs/String                                       | Error message                 |\n| ipfs_address  | [ipfs_common/Multihash](#ipfs_commonmultihashmsg)     | IPFS hash of uploaded file    |\n"}},{node:{id:"b4733a1540607e49d90436d8e511eb7b",title:"IoT Sensors Connectivity",path:"/docs/en/iot-sensors-connectivity/",content:"\nRobonomics Network allows you to communicate with any sensor you wish and get data from the sensor all around the world. This data can be transferred to different destinations.\n\nOn this page you'll find step-by-step instructions to connect an ESP board to the connectivity server provided by AiraLab.\n\n## Requirements\n\n* ESP8266/ESP32 like board with WiFi\n\n## 1. Get the software\n\n### On Windows\n\nInstall [WSL](https://docs.microsoft.com/en-us/windows/wsl/install-win10).\n\nInstall Ubuntu via Windows Store:\n\n![Windows Store](../images/windows_store.jpg \"Windows Store\")\n\nand clone the [package](https://github.com/airalab/sensors-connectivity)\n\n```\ngit clone https://github.com/airalab/sensors-connectivity\n```\n\nThe next step is to install python and dependencies:\n\n```\nsudo apt update && sudo apt install python3-pip\ncd sensors-connectivity\npip3 install -r requirements.txt\n```\n\n### On Ubuntu\n\n```\nsudo apt update && sudo apt install python3-pip git\ngit clone https://github.com/airalab/sensors-connectivity\ncd sensors-connectivity\npip3 install -r requirements.txt\n```\n\n> You can ignore such warnings:\n>\n> ```\n> The script ... is installed in '...' which is not on PATH.\n> Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.\n> ```\n\n### On NixOS\n\n```\ngit clone https://github.com/airalab/sensors-connectivity\ncd sensors-connectivity\nnix build -f release.nix\nsource result/setup.bash\n```\n"}},{node:{id:"fff9d591d3f996937214bf3be77a45a1",title:"IoT Firmware Upload",path:"/docs/en/iot-firmware-upload/",content:"\nThere are few firmwares for ESP like boards:\n\n* [Ping](https://github.com/airalab/sensors-connectivity/tree/master/boards/esp/ping)\n* [TCP](https://github.com/airalab/sensors-connectivity/tree/master/boards/esp/tcp)\n* [Mobile GPS](https://github.com/airalab/sensors-connectivity/tree/master/boards/esp/mobile_gps)\n\nThere is a script to upload a firmware for each one, called `flash_firmware.py`. It's located in the root of the repository\n\n> **Requirements**\n> In order to install all dependencies run in the root of the repository folder:\n>\n> ```\n> pip install -r requirements.txt\n> ```\n>\n> Python3 is required!\n\nUsually in order to upload a firmware to your board follow these steps:\n\n1. Assemble the board and connect it to PC\n2. Edit a `config.yaml` in a corresponding folder (e.g. `boards/esp/tcp/config.yaml`)\n3. Run `python flash_firmware.py -s PATH_TO_FOLDER -c PATH_TO_CONFIG` where `PATH_TO_FOLDER` is a path to the desired firmware (e.g. `boards/esp/ping`) and `PATH_TO_CONFIG` is a path to the configuration file (e.g. `boards/esp/ping/config.yaml`)\n\n"}},{node:{id:"52a7121211bf409d61c95b51c3b8949c",title:"Interact with AIRA",path:"/docs/en/interact-with-aira/",content:'\nAt this point you should be familiar with a [DApp](/docs/get-weather-on-fuji-mountain/) and how to launch [AIRA image](/docs/aira-installation-on-vb/).\nNow you are ready to do more complicated stuff like installing a package and interacting with it via DApp.\n\n> **Important:**\n> Make sure you have covered previous lessons before you continue.\n\n\n> **Tip:**\n> During the lesson you will type a few commands in terminal. AIRA image doesn\'t support clipboard, so to make life easier have a look at [Connect via SSH](/docs/aira-connecting-via-ssh/) and log in via SSH to the VM.\n\nWalkthrough video:\n\nhttps://www.youtube.com/embed/QM06l07_wuA\n\n## Package installation\n\nAfter you launched AIRA and logged in using your terminal do the following:\n\n```\nsu liability && cd\ngit clone https://github.com/vourhey/hello_aira\ncd hello_aira\nnix build -f release.nix\nsource result/setup.bash\nrosrun hello_aira hello_aira\n```\n\nRun one by one commands above. After the last one you should see a link to DApp generated specifically for your instance.\n\n![Terminal with AIRA](../images/aira_hello_terminal.jpg "Terminal with AIRA")\n\nClick on the link, the DApp should be shown.\n\n## DApp \n\nConnect [MetaMask](http://metamask.io/) if prompted and click on the button\n\n![Request connection in Robonomics Dapp](../images/aira_hello_dapp.jpg "Request connection in Robonomics Dapp")\n\nSign the message as usual and wait for the result\n\n![Wait for Result of request](../images/aira_hello_dapp_2.jpg "Wait for Result of request")\n\nMeanwhile have a look at the terminal. You should see the greeting\n\n![AIRA greeting in terminal](../images/aira_hello_terminal_2.jpg "AIRA greeting in terminal")\n\nIn the end the greeting will appear in the DApp\n\n![Robonomics DApp Greeting for AIRA](../images/aira_hello_dapp_3.jpg "Robonomics DApp Greeting for AIRA")\n\n## Troubleshooting\n\n### You click "Request current values" but see no greeting\n\nProbably you have just launched AIRA and IPFS hasn\'t finished initialization. Wait a minute or so and try again.\n\n### I see response hash but the data doesn\'t appear\n\nAgain most probably the issue comes from IPFS connection. Click and the hash and you\'ll see the result. It\'s not necessary to download the file.\n\n## Home Task (optional)\n\nIf you are familiar with [Python](https://www.python.org/) change the shown text to something different and complete the lesson with your version of `hello_aira`\n\n- Make a fork of the [repository](https://github.com/vourhey/hello_aira)\n- The output text is located [here](https://github.com/Vourhey/hello_aira/blob/master/scripts/hello_aira#L45)\n'}},{node:{id:"ab2093f71a4c16ea6bc1e5fbdd3a6ec4",title:"Passing dynamic parameters",path:"/docs/en/hardware-passing-dynamic-parameters/",content:'\nIn [previous](/docs/connect-simple-cps/) example we discussed how to create a simple CPS with Arduino. Our first CPS is able to do only one task: to blink a led. We suggest you to get through the first lesson. Now let\'s expand the example and teach our board to blink blue or red led depending on objective parameter.\n\n> The source code of this lesson is [here](https://github.com/airalab/robonomics_tutorials/tree/master/arduino_with_args).\n\n\n## Arduino\n\nThe only difference in Arduino source code is instead of subscribing to one topic now we subscribe to `/blink_red` and `/blink_blue` topics\n\n```c\n  #include <ros.h>\n  #include <std_msgs/Empty.h>\n\n  ros::NodeHandle nh;\n\n  void blink(int led, int mil) {\n\n    digitalWrite(led, HIGH);\n    delay(mil);\n    digitalWrite(led, LOW);\n    delay(mil);\n\n  }\n\n  void blinkRedCb(const std_msgs::Empty& msg) {\n    blink(13, 500);\n    blink(13, 500);\n    blink(13, 500);\n  }\n\n  void blinkBlueCb(const std_msgs::Empty& msg) {\n    blink(12, 500);\n    blink(12, 500);\n    blink(12, 500);\n  }\n\n  ros::Subscriber<std_msgs::Empty> subRed("blink_red", &blinkRedCb);\n  ros::Subscriber<std_msgs::Empty> subBlue("blink_blue", &blinkBlueCb);\n\n  void setup()\n  {\n    pinMode(13, OUTPUT);\n    pinMode(12, OUTPUT);\n\n    nh.initNode();\n    nh.subscribe(subRed);\n    nh.subscribe(subBlue);\n  }\n\n  void loop()\n  {\n    nh.spinOnce();\n    delay(1);\n  }\n```\n\n\x3c!-- Here is the diagram of all connections:\n\n.. image:: ../img/6.png\n  :alt: Arduino schema\n  :align: center --\x3e\n\n\n## ROS\n\nWe can pass arguments via objective which points to rosbag file. Have a look at `blink.py` script. The main difference is `blink()` method:\n\n```python\ndef blink(self, data):\n  if data.data == "blue":\n      rospy.loginfo("Blinking blue...")\n      self.blink_blue.publish(Empty())\n\n  if data.data == "red":\n      rospy.loginfo("Blinking red...")\n      self.blink_red.publish(Empty())\n\n  rospy.wait_for_service(\'/liability/finish\')\n  fin = rospy.ServiceProxy(\'/liability/finish\', FinishLiability)\n  fin(FinishLiabilityRequest(address=self.liability, success=True))\n  rospy.loginfo("Finished")\n```\n\nNow `/blink` topic has a `String` type. You can find prepared rosbags in `rosbag` folder.\n\n## AIRA\n\nConnect to AIRA client via SSH as described [here](/docs/aira-connecting-via-ssh/). Do not forget to add `COM1` port in settings. Run the following command:\n\n```\n$ rosrun arduino_with_args blink.py\n```\n\nAlso we need to add rosbag files to IPFS:\n\n```\n$ ipfs add rosbag/blink_blue.bag\n$ ipfs add rosbag/blink_red.bag\n```\n\n**Before the next step you should approve XRT tokens on the Factory.**\n\nThe last step is to build Dapp and launch. Take a look at the previous [lesson](/docs/connect-simple-cps/). To make Arduino blink the blue led send blue demand and blue offer messages. For the red one send corresponding messages.\n\nThat\'s it! Now you are able to pass dynamic parameters to your cyber-physical system agent!'}},{node:{id:"71ce4de05ec97c5fa9ac243461be10aa",title:"Connect an Air Pollution Sensor",path:"/docs/en/hardware-connect-sensor/",content:"\nIn this lesson you are going to learn how to connect your sensor to the network and make it publish data. You will see how it is easy to become a member of a global sensor network!\n\nSource code is located [here](https://github.com/airalab/robonomics_tutorials/tree/master/sensor_city).\n\nIn this section we are not going to create a liability contract. Instead we will teach Arduino with sensors to publish the data by a request. All measurements will be published as a Result message.\n\n## Arduino\n\nLet's begin with an Arduino circuit. You need the following components:\n\n* Arduino Uno\n* Optical Dust Sensor Sharp GP2Y1010AU0F\n* Gas Sensor MQ-2\n* Gas Sensor MQ-7\n* Resistor 150 Ohm\n* Capacitor 220 uF\n* Wires\n\nConnect all parts as described below:\n\n\x3c!-- .. image:: ../img/7.png\n  :alt: Arduino schema\n  :align: center --\x3e\n\nA firmware for Arduino Uno is in `sensor_city/scetches` folder. In order to upload it to the board use [Arduino IDE](https://www.arduino.cc/en/Main/Software).\n\n\x3c!-- .. image:: ../img/8.png\n   :alt: Arduino IDE\n   :align: center\n --\x3e\n\n## Aira\n\nThe following steps are performed in Aira client. You can download the latest image from [this page](https://github.com/airalab/aira/releases). It's convenient to [connect via SSH](/docs/aira-connecting-via-ssh/).\n\nAfter you have imported the image to VirtualBox, connect Arduino via USB to your PC and enable serial port forwarding. You should check `Enable Serial Port` and assign `/dev/ttyACM0` in `Path/Address`. Inside the virtual machine `/dev/ttyS0` refers to your external Arduino.\n\n\x3c!-- .. image:: ../img/9.png\n   :alt: Set a port\n   :align: center --\x3e\n\nFinally launch the image and run these command:\n\n```\n$ roslaunch sensor_city publish_data.launch\n```\n\n**Check out the source code to learn how it works under the hood!**\n\nNow Aira patiently waits for a signal to publish the measurements. Go to [Dapp](https://dev.aira.life/smart-city/#/) and click on `Broadcast signal`. You should see the data!"}},{node:{id:"1c1695f9d703a32d45c7a45bc01a23e7",title:"Glossary",path:"/docs/en/glossary/",content:'\n## Agent\n\nIn terms of Robonomics Network agent is a program module that uses IPFS or blockchain or both interfaces of the network and does some actual work.\nUsually it\'s represented as a ROS package and it may connect (but not necessarily) a real cyber-physical system to the Robonomics Network.\n\n## Cyber-physical system\n\nIt is a combination of a physical mechanism that is usually called a robot and a program algorithm that controls the behavior of the mechanism.\n\n## Dapp\n\nIt is a short form for Decentralized application. Usually it is a single page web based application that helps to interact with an agent.\n\n## IPFS\n\nAccording to the official [documentation](https://docs.ipfs.io/introduction/) "IPFS is a distributed system for storing and accessing files, websites, applications, and data".\nFor more detail how it works go to the official website.\n\n## Lighthouse\n\nA lighthouse is an autonomous workflow that allows us to distribute the running time of providers that serve a single broadcast channel.\n\nFor more information read [Robonomics Whitepaper](https://static.robonomics.network/docs/whitepaper/Robonomics-whitepaper-en.pdf) section 5.2.\n\n## Sidechain\n\nEthereum based blockchain network with Proof-of-Authority consensus owned by Airalab.\n\n'}},{node:{id:"ca118dfbaef7821221f7dc42a4727336",title:"Getting Started",path:"/docs/en/",content:'\n## What is Robonomics\n\nRobonomics platform provides tools for working with the robot economy network. Robonomics allow designers of smart cities and industry 4.0 zones to build trust among the [autonomous robots services](/docs/glossary#cyber-physical-system), provide [direct user access via dapp](/docs/glossary#dapp) for ordering products from autonomous factories and services of urban sensor networks. This in turn will allow us to put in place a decentralized system that globally monitors the activities of cyber physical systems.\n\nFind more in [Robonomics whitepaper](https://github.com/airalab/robonomics_specs/blob/master/pdf/whitepaper_en.pdf)\n\nThe following chart describes what place Robonomics takes in the scenario:\n\n![Robonomics Chart](../images/robonomics_network_basic_scheme.jpg "Robonomics Network scenario")\n\n## What the documentation contains\n\n### Robonomics Network quick start\nStart with quick example of what Robonomics is able to do within 5 minutes: [DEMO "Get Weather on Fuji Mountain"](/docs/get-weather-on-fuji-mountain).\n\n### I\'m interested in using Robonomics services\n\nTake a look at the [Robonomics Dapp](https://dapp.robonomics.network/#/). Get familiar with the statistic, average miner reward etc.\nTry out existing [services](https://dapp.robonomics.network/#/services)\n\n### I\'m a Dapp developer\n\n- [Robonomics-js on GitHub](https://github.com/airalab/robonomics-js) - simple Javascript SDK for Robonomics Network dApp developers.\n- [dApp template](https://github.com/airalab/vue-dapp-robonomics-template) - uses Vue.js\n- [Wiki documentation](/docs/robonomics-js/)\n\n### I\'m a robotics engineer\n\nCheck out [cases](/docs/iot-sensors-connectivity/) section and start developing by [examples](/docs/agent-development-examples).\n\n'}},{node:{id:"d73aa38a7f017fe2315a5b2972ed5782",title:'DEMO "Get Weather on Fuji Mountain"',path:"/docs/en/get-weather-on-fuji-mountain/",content:'\n**Let\'s start from a quick example of what Robonomics is able to do within 5 minutes. Requirements: [Metamask extension](https://metamask.io/)**\n\nTo get the weather from sensor on Fuji Mountain, please, open the page of [Fuji Weather sensor](https://dapp.robonomics.network/#/sensors/airalab/QmbQT8cj9TJKfYVaidfShnrEX1g14yTC9bdG1XbcRX73wY/0x4D8a26e1f055c0b28D71cf1deA05f0f595a6975d/) in Robonomics dApp and follow instructions below.\n\nHere\'s a walkthrough video:\n\nhttps://www.youtube.com/embed/t098NlMELk4\n\n## 1. Open the Dapp\n\nIn case you don\'t have MetaMask extension you\'ll see the picture below. Go to the link provided above and install one.\n\n!["Robonomics dApp if no MetaMask installed"](../images/sensor-demo/sensor-demo-1.png "Robonomics dApp if no MetaMask installed")\n\n## 2. Allow connection to the extension\n!["Connection to Robonomics dApp via Metamask"](../images/sensor-demo/sensor-demo-2.png "Connection to Robonomics dApp via Metamask")\n\n## 3. Press "Request current values"\n!["Request sensor\'s data in Robonomics network via dApp"](../images/sensor-demo/sensor-demo-3.png "Request sensor\'s data in Robonomics network via dApp")\n\n## 4. Sign a message. No token or ether are needed\n!["Sign a message in Robonomics network via dApp"](../images/sensor-demo/sensor-demo-4.png "Sign a message in Robonomics network via dApp")\n\n## 5. Wait until the agent collects the data and sends it back\n!["Wait for response of the agent in Robonomics network via dApp"](../images/sensor-demo/sensor-demo-5.png "Wait for response of the agent in Robonomics network via dApp")\n\n## 6. Wait until the Dapp downloads the result file from IPFS\n!["Wait for IPFS file with results in Robonomics network via dApp"](../images/sensor-demo/sensor-demo-6.png "Wait for IPFS file with results in Robonomics network via dApp")\n\n## 7. Look at the weather data on Fuji Mountain\n!["The results of sensor network in Robonomics via dApp"](../images/sensor-demo/sensor-demo-7.png "The results of sensor network in Robonomics via dApp")\n\nJust now you have broadcasted a demand message and got a result from an autonomous agent! The result file is stored in IPFS, the result message is signed with the agent\'s private key.\n'}},{node:{id:"3d839af62c929db90b9c1cf4369b14a2",title:"Gaka-Chu setup and software Installation",path:"/docs/en/gaka-chu/",content:"\nhttps://www.youtube.com/watch?v=GxlYxaykqTU\n\n**In this article we will go through some installation and launching steps to set up a robot-painter. Requirements:**\n- KUKA KR6 R900 sixx with KRC4 and a SmartPad;\n- Intel NUC with [ROS melodic](http://wiki.ros.org/melodic/Installation/Ubuntu) installed;\n- Table, paint, brush, water.\n\n## Software installation on KRC4\nEKI interface is required on both, KRC4 and NUC. Detailed information on how to set it up on KRC4 is presented [here](https://github.com/AlexeiOvcharov/kuka_experimental/tree/a915bf4e932990379c84164713e7ae11a24a2a13/kuka_eki_hw_interface/krl). Launch it on robot's controller.\n\n## Software installation on NUC\nCreate a catkin workspace:\n```\nmkdir -p ~/catkin_ws/src\ncd ~/catkin_ws/\ncatkin build\n```\nDownload ROS packages. All the scripts are stored [here](https://github.com/airalab/robot_painter/tree/test_branch). Clone the repository:\n```\ncd src\ngit clone --branch test_branch https://github.com/airalab/robot_painter\ncd robot_painter\nrm -rf scenes\nmv * ../\ncd ..\nrmdir robot_painter\n```\nYou may need some header files and libraries to make it all work correctly. Download them:\n```\ncd ~\ngit clone https://github.com/PaTara43/kuka_moveit_webots\ncd kuka_moveit_webots\nsudo mv -r headers/* usr/include/c++/7/\nsudo mv libs/* usr/local/lib/\ncd ~\nsvn checkout https://github.com/PX4/Matrix/trunk/matrix\nmv matrix -r /usr/include/c++/7/\nsudo apt-get install ros-melodic-brics-actuator\ncd ~/catkin_ws\ncatkin build\n```\nAdd source command to `.bashrc` file:\n```\necho “source ~/catkin_ws/devel/setup.bash” >> ~/.bashrc\nsource ~/.bashrc\n```\nUp to now. you should be able to launch the scripts. If something goes wrong, try some [troubleshooting](https://github.com/airalab/robot_painter/issues)\n\n## Filling in constants\nFirst of all, the robot needs to know canvas location and orientation as well as the paint tin position. All of this is specified in `fake_painter_enviroment_tf/src/tf_broadcaster.cpp`. Let's take a look into it.\n```\n// Plane constants\nconst double A = -0.0641;\nconst double B = 0.0214;\nconst double C = 0.9977;\nconst double D = -0.2198;\n\n// Canvas transform\nconst double px = 0.52;\nconst double py = -0.24;\nconst double qx = -0.011;\nconst double qy = -0.032;\nconst double qz = 0.0;\nconst double qw = 0.999;\n```\nThese are the plane equation constants which specify canvas position in 3-D space. They are to be obtained during a calibration process described below. Next goes the paint.\n```\ncolorTransform.transform.translation.x = 0.5;\ncolorTransform.transform.translation.y = 0.2;\ncolorTransform.transform.translation.z = 0.258;\n```\nThese are paint tin coordinates. They also may be specified while calibrating. Canvas size is specified in\n```\ncanvas.width = 0.5;\ncanvas.height = 0.4;\n```\nSeveral more important constants are stored in `local_task_planner/src/Drawing.cpp`:\n```\nconst double COLOR_BOTLE_HEIGHT = 0.06;\nconst double COLOR_HEIGHT = 0.045;\nconst double HEIGHT_OFFSET = COLOR_BOTLE_HEIGHT - COLOR_HEIGHT + 0.02;\nconst double BRUSH_HEIGHT = 0.01;\nconst double BRUSH_WIDTH = 0.01;\n```\nTheir names say it all, so fill them in according to the situation.\n\n## Calibrating Gaka-Chu\nThe calibration process itself is pretty simple.\n\n1) Start EKI interface on the KRC4:\n\nLog in in 'AUT' mode, turn on drivers and launch the script `eki_hw_interface`\n\n2) Start EKI interface on the NUC\n```\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\n```\nIt should output endless logs.\n\n3) Start RViz\n```\nroslaunch kuka_moveit_config demo.launch\n```\nYou should see the following:\n\n![KUKA in RViz](../images/kuka-real/kuka_rviz.png \"KUKA in RViz\")\n\nTry moving the end effector and clicking 'Plan and Execute'. The robot should move. On SmartPad go to **Display -> Actual position** and observe end effector's coordinate. Place a canvas horizontally to the robot base. Plug a brush into the brush holder and carefully move it till it barely touches the canvas. At this position, save end effector's coordinates. Repeat 12-15 times. Also, save the coordinates of the canvas center and paint tin.\nWhen you have a set of coordinates, use [these](https://github.com/nakata5321/Matlab_scripts_gaka-chu) Matlab scripts to resolve the missing constants and quaternion. Paste them. Rebuild your workspace with\n```\ncd ~/catkin_workspace\nrm -rf build logs devel\ncatkin build\n```\n\n## Testing Gaka-Chu calibration\nWhen calibrated, Gaka-Chu needs to be tested by drawing the borders of canvas. To make him do so execute each in new terminal:\n```\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\nroslaunch kuka_moveit_config demo.launch\nrosrun fake_painter_enviroment_tf tf_broadcaster\nrosrun local_task_planner draw_workspace\n```\nAfter this, you should see a canvas contour in RViz:\n\n![KUKA in RViz canvas](../images/kuka-real/kuka_rviz_canvas.png \"KUKA in RViz canvas\")\n\nIn terminal press \"S\" to perform testing. Robot's end effector should move right above the borders of the canvas and the brush should gently touch the canvas during the entire movement. If not so, try recalibrating. If the canvas model is rotated wrong, you can rotate it by changing quaternion in Matlab.\n\n## Making art\nYou need 6 basic modules to make it all work:\n- EKI interface;\n- MOVEit + RViz;\n- Environment frames broadcasting;\n- Picture converter service;\n- Trajectories drawing module;\n- Starting trigger.\n\nLet's launch them one by one.\n\n### Eki interface\nOn KRC4 launch `eki_hw_interface`, on NUC in a new terminal do:\n```\nroslaunch kuka_eki_hw_interface test_hardware_interface.launch\n```\n\n### RViz and MOVEit\nYou need a planner and a simulation. Launch them with\n```\nroslaunch kuka_moveit_config demo.launch\n```\n\n### Environment\nTell the robot where the paint tin and the canvas are. Note that it is not necessary to launch `draw workspace` node, the `tf_broadcaster` shares the canvas size. It just doesn't show it in RViz.\n```\nrosrun fake_painter_enviroment_tf tf_broadcaster\n```\n\n### Pictures processor\nAll incoming pictures need to be processed. Launch the service.\n```\nrosrun picture_preprocessing TextConverter.py\n```\nWhen it receives the call, it processes a picture with a HP filter and creates a rosbag file with trajectories.\n\n### Trajectories drawer\nThe mainest script here is the trajectories drawer itself. It waits for the picture, calls TextConverter service and draws the painting.\n```\nrosrun local_task_planner trajectory_drawing\n```\n\n## Send the robot a picture to draw\nThe robot listens to a specific ROS-topic where you need to pass the path to a desired picture. The picture should be square (width equals height) and made of lines. Send the path:\n```\nrostopic pub /run std_msgs/String \"data: '<path_to_picture>'\"\n```\nAfter that. Two windows pop up showing the contours and the tracks. Close them and see Gaka-Chu drawing. Watch out for safety and alwasy be ready to press emergency stop button.\nWhen Gaka-Chu finishes his art, you can send another path to picture and painter repeats the whole process.\n"}},{node:{id:"1743989f5302eda3f85683b806b9ea10",title:"Connect an Amazon FreeRTOS Device to Robonomics by MQTT",path:"/docs/en/freertos-mqtt/",content:"\nHere's the demonstration of how a microcontroller running [Amazon Web Services FreeRTOS](https://aws.amazon.com/freertos/) may be connected to Robonomics Network via MQTT. Please check [this repository](http://github.com/khssnv/freertos_mqtt_robonomics_example) for the project source code.\n\nWe use [ESP32 DevKitC](https://devices.amazonaws.com/detail/a3G0L00000AANtjUAH/ESP32-WROOM-32-DevKitC/) with FreeRTOS distribution and MQTT implementation provided by [Espressif IoT Development Framework](https://github.com/espressif/esp-idf) while Espressif is a vendor of the microcontroller used.\n\nAlso there is a [PMS-3003](http://www.plantower.com/en/content/?107.html) sensor for demonstration purposes. Sensor measures presence of particulated matter in the air and one may use it to estimate air quality.\n\nAir quality is not a topic of the article, you may find more about it at WHO's website: [Ambient (outdoor) air pollution](https://www.who.int/news-room/fact-sheets/detail/ambient-(outdoor)-air-quality-and-health). A goal of the system is to publish sensor measurements to Airalab's Robonomics network.\n\n## Hardware setup\n\nWe connect PMS3003 TXD PIN5 to ESP32 DevKitC IO17 to transfer measurements by UART.\nAlso both devices require power and common ground.\n\n![Wiring Diagram](../images/freertos-mqtt/wiring.png)\n\n## Data Flow\n\nIn order to deliver sensor measurements to Robonomics network, on a firmware level our goal is to get data from a sensor by embedded communication protocol it supports (UART in our case) and pass it to AIRA instance by MQTT / TCP.\n\n![Sending](../images/freertos-mqtt/send.svg)\n\nIn our example we use AIRA cloud deployment available by public IP address and domain name assigned.\nOn AIRA instance we setup `mosquitto` MQTT broker and subscribe to `/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4` topic to get messages from MQTT.\n\nThen we pass messages to `robonomics io` writer by pipe.\n\n![Receiving](../images/freertos-mqtt/recv.svg)\n\nNow data available in Robonomics Network and we can be read it with `robonomics io` again.\n\n## Firmware\n\nWe use [ESP-MQTT sample application with TCP transport](https://github.com/espressif/esp-idf/tree/master/examples/protocols/mqtt/tcp) as a basis.\n\nWe only modify `main/app_main.c` for UART connection to the sensor, SNTP time synchronization and periodic MQTT publisher routine.\n\nIf you are trying to repeat the project, and it's your first ESP IDF based project, at first please follow [Espressif's ESP-IDF Programming guide](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/index.html#installation-step-by-step) introduction in order to familiarize with firmware operations like configuration, build and upload with `idf.py` tool.\n\n### Wi-Fi Configuration\n\nIn order to communicate with AIRA instance deployed in cloud, our microcontroller requires Internet connection.\nWe use ESP32's Wi-Fi for it.\nEspressif provides utilities to configure on-board Wi-Fi.\nIn our example we use development environment with Ubuntu 20.04 GNU/Linux.\nTo configure Wi-Fi we go to project folder and run SDK configuration tool.\n\n```console\ncd freertos_mqtt_robonomics_example/firmware\nidf.py menuconfig\n```\n\nThen we set Wi-Fi access point SSID and password in `Example Connection Configuration` section.\n\n![Menuconfig Wi-Fi](../images/freertos-mqtt/menuconfig-wi-fi.png)\n\n### MQTT Endpoint Configuration\n\nThere are two things to configure for MQTT.\nThe first is a MQTT broker address.\nIt is configurable with SDK configuration tool.\n\n```console\ncd freertos_mqtt_robonomics_example/firmware\nidf.py menuconfig\n```\n\nSet `Broker URL` in `Example Configuration` section.\n\n![Menuconfig MQTT](../images/freertos-mqtt/menuconfig-mqtt.png)\n\nThe second thing is a MQTT topic.\nWe set it in the firmware with the project name prefix followed with our ESP32 MAC address.\nIt gives us `/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4` for our particular microchip.\n\n## From MQTT to Robonomics\n\nAt first let's check we receive data by MQTT.\nWe can subscribe to our Mosquitto MQTT broker topic device publish to.\n\n```console\n$ nix-shell -p mosquitto --run \"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\"\nts=1615651809, PM1=2, PM2.5=6, PM10=3\n```\n\nHere we bring `mosquitto` package into our environment to use `mosquitto_sub` utility.\nThen we subscribe to the topic set in the firmware.\nWe got our measurements that means AIRA receives data by MQTT correctly.\nNow let's pipe these messages to Robonomics Network.\n\n```console\nnix-shell -p mosquitto --run \"mosquitto_sub -h localhost -t '/freertos_mqtt_robonomics_example/98:F4:AB:72:23:C4'\" | robonomics io write pubsub --bootnodes=/ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\n```\n\nHere we use `robonomics` utility to publish messages in pubsub channel `/freertos_mqtt_robonomics_example`.\nWe specify `bootnodes` to ensure at least one connection established.\n\nNow we are read these messages from the same pubsub channel.\n\n```console\n$ robonomics io read pubsub --listen /ip4/127.0.0.1/tcp/34333 /freertos_mqtt_robonomics_example\n2021-03-27 15:15:51  Generated random peer id: 12D3KooWB2nym5E6c3aPpnPKK5wB9Z6n9eZzcXSpyUBozxhi6dam\n2021-03-27 15:15:51  Subscribed to topic: _robonomics_pubsub_peer_discovery\n2021-03-27 15:15:51  Subscribed to topic: /freertos_mqtt_robonomics_example\n2021-03-27 15:15:56  New peer connected: PeerId(\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\")\n2021-03-27 15:15:56  GRAFT: Mesh link added for peer: PeerId(\"12D3KooWRPLCioD2b9XLZTZJQELSAuQAyTrHUKzRktrQHtTSs6kS\") in topic: TopicHash { hash: \"_robonomics_pubsub_peer_discovery\" }\nts=1616843855, PM1=3, PM2.5=4, PM10=3\n```\n\n## Original Resources Used\n\n* ESP32 DevKitC pinout from GoJimmy's blog https://gojimmypi.blogspot.com/2017/03/jtag-debugging-for-esp32.html\n* PSM3003 data structure and decoder from OpenAirProject https://github.com/openairproject/sensor-esp32\n\n**Thank you all!**\n"}},{node:{id:"8d5cbb73dee00b6714f5533465ab2e39",title:"Ethereum Common",path:"/docs/en/ethereum-common/",content:'\nThe packages contains two launch files: `erc20.launch` and `signer.launch`. The last one is included in [Robonomics Liability](/docs/robonomics-liability).\n\nBelow is the description for `erc20` node which contains utils for convenient work with Ethereum accounts and XRT token.\n\n## ROS Parameters\n\n###  ~web3_http_provider\n\nWeb3 HTTP provider address. The type is `string`, defaults to `http://127.0.0.1:8545`\n\n### ~erc20_token\n\nERC20 token to work with. Type is `string`, defaults to `xrt.5.robonomics.eth`\n\n### ~factory_contract\n\nThe name of the liability factory. The type is `string`, defaults to `factory.5.robonomics.eth`\n\n### ~ens_contract\n\nThe checksumed address of ENS registry. The type is `string`, defaults to `""`\n\n### ~keyfile\n\nPath to keyfile. The type is `string`, defaults to `""`. **Required parameter**\n\n### ~keyfile_password_file\n\nPath to a file with password for the keyfile. The type is `string`, defaults to `""`. **Required parameter**\n\n## Published topics\n\n### /eth/event/transfer (ethereum_common/TransferEvent)\n\nThe event [ethereum_common/TransferEvent](/docs/ethereum-common-messages#ethereum_commontransfereventmsg) is emitted after the transfer of tokens was made\n\n### /eth/event/approval (ethereum_common/ApprovalEvent)\n\nThe event [ethereum_common/ApprovalEvent](/docs/ethereum-common-messages#ethereum_commonapprovaleventmsg) is emitted after the approval of tokens was made\n\n## Services\n\n### /eth/accounts (ethereum_common/Accounts)\n\nList of available Ethereum accounts. See [ethereum_common/Accounts](/docs/ethereum-common-messages#ethereum_commonaccountssrv)\n\n### /eth/account_eth_balance (ethereum_common/AccountBalance)\n\nReturns the balance of the given address in Wei. See [ethereum_common/AccountBalance](/docs/ethereum-common-messages#ethereum_commonaccountbalancesrv)\n\n### /eth/eth_balance (ethereum_common/Balance)\n\nReturns the balance of the default address. See :ref:`Ethereum-common-Balance.srv`\n\n### /eth/current_block (ethereum_common/BlockNumber)\n\nReturns current block number. See :ref:`Ethereum-common-BlockNumber.srv`\n\n### /eth/transfer (ethereum_common/Transfer)\n\nTransfers tokens from the default account to a given one. See :ref:`Ethereum-common-Transfer.srv`\n\n### /eth/transfer_from (ethereum_common/TransferFrom)\n\nTransfers tokens from a given account to another one. See :ref:`Ethereum-common-TransferFrom.srv`\n\n### /eth/approve (ethereum_common/Approve)\n\nApproves tokens from the default account to a given one. See :ref:`Ethereum-common-Approve.srv`\n\n### /eth/account_xrt_balance (ethereum_common/AccountBalance)\n\nReturns the XRT balance of a given account. See :ref:`Ethereum-common-AccountBalance.srv`\n\n### /eth/xrt_balance (ethereum_common/Balance)\n\nReturn the XRT balance of the default account. See :ref:`Ethereum-common-Balance.srv`\n\n### /eth/account_xrt_allowance (ethereum_common/AccountToAddressAllowance)\n\nReturns how much one account is allowed to spend from another account. See :ref:`Ethereum-common-AccountToAddressAllowance.srv`\n\n### /eth/xrt_allowance (ethereum_common/Allowance)\n\nReturns how much the Factory is allowed to spend from the default account. See :ref:`Ethereum-common-Allowance.srv`'}},{node:{id:"f74bdcea89d2c7bde07f3baad0b0bcd9",title:"Ethereum Common Messages",path:"/docs/en/ethereum-common-messages/",content:"\n## ethereum_common/Address.msg\n\n| Field   \t| Type            \t| Description                    \t|\n|---------\t|-----------------\t|--------------------------------\t|\n| address \t| std_msgs/String \t| Address in Ethereum blockchain \t|\n\n## ethereum_common/UInt256.msg\n\n| Field   \t| Type            \t| Description                \t|\n|---------\t|-----------------\t|----------------------------\t|\n| uint256 \t| std_msgs/String \t| A wrapper for big integers \t|\n\n## ethereum_common/TransferEvent.msg\n\n| Field      \t| Type                                                  \t| Description      \t|\n|------------\t|-------------------------------------------------------\t|------------------\t|\n| args_from  \t| [ethereum_common/Address](#ethereum_commonaddressmsg) \t| Sender address   \t|\n| args_to    \t| [ethereum_common/Address](#ethereum_commonaddressmsg) \t| Receiver address \t|\n| args_value \t| [ethereum_common/UInt256](#ethereum_commonuint256msg) \t| Amount of tokens \t|\n\n## ethereum_common/ApprovalEvent.msg\n\n| Field        \t| Type                                                  \t| Description      \t|\n|--------------\t|-------------------------------------------------------\t|------------------\t|\n| args_owner   \t| [ethereum_common/Address](#ethereum_commonaddressmsg) \t| Owner address    \t|\n| args_spender \t| [ethereum_common/Address](#ethereum_commonaddressmsg) \t| Spender address  \t|\n| args_value   \t| [ethereum_common/UInt256](#ethereum_commonuint256msg) \t| Amount of tokens \t|\n\n## ethereum_common/AccountBalance.srv\n\n**Request**\n\n| Field   \t| Type                                                  \t| Description      \t|\n|---------\t|-------------------------------------------------------\t|------------------\t|\n| account \t| [ethereum_common/Address](#ethereum_commonaddressmsg) \t| Ethereum address \t|\n\n**Response**\n\n| Field   \t| Type                                                  \t| Description    \t|\n|---------\t|-------------------------------------------------------\t|----------------\t|\n| balance \t| [ethereum_common/UInt256](#ethereum_commonuint256msg) \t| Balance in Wei \t|\n\n## ethereum_common/AccountToAddressAllowance.srv\n\n**Request**\n\n| Field   \t| Type                                                  \t| Description      \t|\n|---------\t|-------------------------------------------------------\t|------------------\t|\n| account \t| [ethereum_common/Address](#ethereum_commonaddressmsg) \t| Ethereum address \t|\n| to      \t| [ethereum_common/Address](#ethereum_commonaddressmsg) \t| Ethereum address \t|\n\n**Response**\n\n| Field  \t| Type                                                  \t| Description   \t|\n|--------\t|-------------------------------------------------------\t|---------------\t|\n| amount \t| [ethereum_common/UInt256](#ethereum_commonuint256msg) \t| Balance in Wn \t|\n\n## ethereum_common/Accounts.srv\n\n**Request**\n\nRequest is empty\n\n**Response**\n\n| Field     | Type                                                      | Description                   |\n|---------- |-------------------------------------------------------    |----------------------------   |\n| accounts  | [ethereum_common/Address[]](#ethereum_commonaddressmsg)     | List of available accounts    |\n\n## ethereum_common/Allowance.srv\n\n**Request**\n\nRequest is empty\n\n**Response**\n\n| Field     | Type                                                      | Description                                       |\n|--------   |-------------------------------------------------------    |-----------------------------------------------    |\n| amount    | [ethereum_common/UInt256](#ethereum_commonuint256msg)     | Amount of XRT the Factory is allowed to spend     |\n\n## ethereum_common/Approve.srv\n\n**Request**\n\n| Field     | Type                                                      | Description                   |\n|---------  |-------------------------------------------------------    |-----------------------------  |\n| spender   | [ethereum_common/Address](#ethereum_commonaddressmsg)     | Who is allowed to spend       |\n| value     | [ethereum_common/UInt256](#ethereum_commonuint256msg)     | How much tokens are allowed   |\n\n**Response**\n\n| Field     | Type                  | Description       |\n|--------   |--------------------   |------------------ |\n| txhash    | std_msgs/Uint8[32]    | Transaction hash  |\n\n## ethereum_common/Balance.srv\n\n**Request**\n\nRequest is empty\n\n**Response**\n\n| Field     | Type                                                      | Description                       |\n|---------  |-------------------------------------------------------    |--------------------------------   |\n| balance   | [ethereum_common/UInt256](#ethereum_commonuint256msg)     | The balance of default account    |\n\n## ethereum_common/BlockNumber.srv\n\n**Request**\n\nRequest is empty\n\n**Response**\n\n| Field     | Type              | Description           |\n|--------   |-----------------  |---------------------- |\n| number    | std_msgs/Uint64   | Current block number  |\n\n## ethereum_common/Transfer.srv\n\n**Request**\n\n| Field     | Type                                                      | Description           |\n|-------    |-------------------------------------------------------    |---------------------- |\n| to        | [ethereum_common/Address](#ethereum_commonaddressmsg)     | Ethereum address      |\n| value     | [ethereum_common/UInt256](#ethereum_commonuint256msg)     | The amount of tokens  |\n\n**Response**\n\n| Field     | Type                  | Description       |\n|--------   |--------------------   |------------------ |\n| txhash    | std_msgs/Uint8[32]    | Transaction hash  |\n\n## ethereum_common/TransferFrom.srv\n\n**Request**\n\n| Field     | Type                                                      | Description           |\n|-------    |-------------------------------------------------------    |---------------------- |\n| owner     | [ethereum_common/Address](#ethereum_commonaddressmsg)     | Owner's address       |\n| to        | [ethereum_common/Address](#ethereum_commonaddressmsg)     | Another account       |\n| value     | [ethereum_common/UInt256](#ethereum_commonuint256msg)     | The amount of tokens  |\n\n**Response**\n\n| Field     | Type                  | Description       |\n|--------   |--------------------   |------------------ |\n| txhash    | std_msgs/Uint8[32]    | Transaction hash  |\n"}},{node:{id:"e62b3364b04000dee581dd55448c6a57",title:"How to edit WIKI",path:"/docs/en/edit-wiki/",content:'\n**Robonomics WIKI is open source. Any corrections are welcome: fixing errors, typos, some unclear or outdated information, translation into any language. You\'ll need a [GitHub](https://github.com/) account.**\n\n## Edit existing doc\n\n1. Choose page\n2. Click button "Edit page" marked with the Github logo on the page you want to edit\n3. Clicking on the button will take you to the .md file.\n4. Please, follow common rules for editing [Markdown files](https://en.wikipedia.org/wiki/Markdown), bearing in mind a few features of the WIKI stack:\n\n### Frontmatter\nDocs in Robonomics WIKI contain frontmatter block. It must be at the top of the Markdown file, and must take the form of valid YAML set between triple-dashed lines. Between the triple-dashed lines, you can set or edit folowing options:\n\n```YAML\n---\ntitle: How to contribute # Title for the page, you do not need to duplicate it in text\ncontributors: [positivecrash] # Main contributors (who actively curates this page). GitHub nickname required, without any additional symbols\ntranslated: true # "true" if it has been translated in current language (see locale folder name of doc)\n---\n```\n\n### Images\n1. Upload image in folder `/docs/images/url-of-your-doc`\n* If image needs to be localized, insert all of them in one folder\n* Use locale appendix in name of images if it\'s localized, e.g. `image_en.jpg`\n* Make sure your image is web optimised and at the same time it looks good\n2. Insert images standart way for Markdown files.\n\n### YouTube videos\nYou can embed any YouTube video in doc by inserting share link as separate paragraph without any additional quotes or tags, e.g.: `https://youtu.be/kQaSwNYHJQ8`\n\n### Asciinema\nRobonomics WIKI has support for Asciinema. To insert Asciinema, please, follow these instructions:\n* Import component after frontmatter block `import Asciinema from \'~/components/Asciinema.vue\'`\n* Insert as separate paragraph `<Asciinema vid="WCFcx8C6M8e52UKDNei1xZloU"/>`, where is vid is ID of specific asciicast\n\n> You can get the widget script for a specific asciicast by clicking on “Embed” link on asciicast page.\n> It looks like this:\n> `<script src="https://asciinema.org/a/14.js" id="asciicast-14" async><\/script>`\n[Asciinema docs](https://asciinema.org/docs/embedding)\n\nIn the example above vid is 14.\n\n## Add new doc\n\nIf you need to add new page in docs of Robonomics WIKI, please, follow these steps:\n\n1. Find the folder with the locale that matches the language of the article you are adding, e.g. `/docs/en/`\n2. Create .md file, using in name latin characters and follow common rules for [url structure](https://developers.google.com/search/docs/advanced/guidelines/url-structure)\n3. Edit file as described above\n4. Duplicate file to other locale folders, even if you do not plan to translate them. Do not forget mark in frontmatter not translated pages as `translated: false`\n5. Add doc in menu:\n* Open file `/data/sidebar_docs.yaml`\n* Decide where to place your doc\n* If you want to create new section, provide title with locale appendix, using only locales your section is translated\n* Add doc with link. The link must be only one, and must not contain locale characters. Correct is `/docs/url-of-your-doc`, not correct is `/docs/en/url-of-your-doc`\n* Use valid YAML for `/data/sidebar_docs.yaml` and rely on the existing file structure\n\n## Submit Pull Request\n\n[Make pull request](https://docs.github.com/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request) for any content you changed including typos, translations, outdated information or broken links.\n\nDecisions about individual PRs made by Robonomics core team. Special grants in [XRT](https://robonomics.network/community#token) are also possible for extended contribution 🤖💙💛💚💎🍭🎉🔌'}},{node:{id:"ba7e780dec2105ea2ef04fd61ee5e6c8",title:"Cross-chain Message",path:"/docs/en/cross-chain-messages/",content:"\nXCM (Cross-chain Message) allows sending messages between parachains. You can send launchXcm transaction to run/stop your robot or datalogXcm transaction to save data to blockchain.\n\nhttps://www.youtube.com/watch?v=a6XrqoaYhK8&feature=emb_logo\n\n## Create Account\n\nLets try to send message from Earth to Mars.\nGo to [parachain.robonomics.network](https://parachain.robonomics.network/#/explorer) and choose `Airalab Rococo` testnet:\n\n![testnets](../images/cross-chain/testnet.jpg)\n\nIn `Network/Parachains` you will see two parachains with their id:\n\n![ids](../images/cross-chain/Parachains_id.jpg)\n\nThen go to Earth parachain and [create](https://wiki.robonomics.network/docs/create-account-in-dapp/) two accounts (for example `ROBOT` and `EMPLOYER`). In a new tab go to Mars parachain.\n\n## LaunchXcm\n\nIn Earth parachain go to `Developer/Extrinsics` and choose your `EMPLOYER` account and launchXcm. Then write Mars parachain id (2000) and choose the `ROBOT` account:\n\n![launch](../images/cross-chain/launch.jpg)\n\nNow press `Submit Transaction`.\n\nTo see your transaction in Mars parachain go to `Network/Explorer` and look at Recent Events.\n\n![recent_launch](../images/cross-chain/recent_launch.jpg)\n\n## DatalogXcm\n\nIn Earth parachain go to `Developer/Extrinsics` and choose your `ROBOT` account and datalogXcm. Write Mars parachain id (2000) and the message:\n\n![datalog](../images/cross-chain/datalog.jpg)\n\nNow press `Submit Transaction`.\n\nYou can see your transaction in Recent Events in Mars parachain:\n\n![recent_datalog](../images/cross-chain/recent_datalog.jpg)\n\n\n"}},{node:{id:"a1f1e016f084066b5dcb33ea4ab3b7e1",title:"Create digital identity run by Ethereum",path:"/docs/en/create-digital-identity-run-by-ethereum/",content:'\nOne of the Robonomics services is [Digital Passport Registration](https://dapp.robonomics.network/#/passport/) for arbitrary data. The service allows you to create a digital identity saving the hashes of the data to the public blockchain and assigning a unique address.\n\nYou may find "Digital passport registration" service in [Robonomics DApp](https://dapp.robonomics.network/) in the "Services" section or just follow this [direct link](https://dapp.robonomics.network/#/passport/).\n\n\n## Video walkthrough\n\nThe following video shows a progress of Robonomics Whitepaper registration:\n\nhttps://www.youtube.com/embed/E8R6VbZvf9w\n\n## Step-by-step in pictures\n\n### 1. Open the service\n\n![Digital passport registration applying form](../images/case_digital_passport_1.jpg "Digital passport registration applying form")\n\n### 2. Add necessary information and files\n\nPlease note, it is possible to add multiple images.\n\n![Filled Form](../images/case_digital_passport_2.jpg "Filled Form")\n\n### 3. Sign the demand\n\n![Sign the demand for digital passport creation](../images/case_digital_passport_3.jpg "Sign the demand for digital passport creation")\n\n\n### 4. Approve tokens\n\nThe service charges a small fee. But first you must approve the required amount of tokens to be spent from your account.\n\n![Approve Tokens](../images/case_digital_passport_4.jpg "Approve Tokens")\n\n\n### 5. Accept the offer and sign the message again\n\n![Send Order](../images/case_digital_passport_5.jpg "Send Order")\n\n### 6. Have a look at the created passport\n\n![The Digital Identity](../images/case_digital_passport_6.jpg "The Digital Identity") \n\nThe process of registration takes some time. In the end you will see a link to the created identity.\n'}},{node:{id:"de3944de0e02f8e3752a0a0f8ebd24d2",title:"Create an Account on Robonomics Portal",path:"/docs/en/create-account-in-dapp/",content:'\n**In order to be able to complete all the playground tutorials below, one should have several accounts on Robonomics portal. These accounts do not contain any personal data, neither they are anyhow valuable (if you play on a local dev network or on a self-owned test one). But still their keys, both public and private, are necessary for launching any demo.**\n\n## 1. Choose your network and navigate to Robonomics portal\nGlobally, there are 3 different ways to work with Robonomics:\n- Launch your own local network with [robonomics binary](https://github.com/airalab/robonomics/releases/) by `./robonomics --dev`. This method is used in all playground tutorials. (_tip: to avoid failures on next launches clean chain data by `rm -rf /home/$USER/.local/share/robonomics/chains/dev/db` after each session_)\n- Launch your own test network following [this](/docs/robonomics-test-network-manual/) manual\n- Connect to an existing network on a portal (more information on this below)\n\nRegardless of method chosen, go to [parachain.robonomics.network](https://parachain.robonomics.network) and draw your attention to the top-left corner:\n\n![Portal top-left](../images/creating-an-account/portal-top-left.jpg "Portal top-left")\n\nPress on the current network icon and choose you network:\n- **Development -> Local Node** if you have launched local network\n- **Custom Endpoint -> insert endpoint** if you have created a test network on a remote server\n- **Live Networks** or **Test Networks** if you are operating in a public one\nDon\'t forget to press `Switch` button to confirm network choice. In all the playgrounds we will use local networks.\n\n![Choosing local network](../images/creating-an-account/choosing-local-node.jpg "Choosing local network")\n\n## 2. Create accounts\nNow that you have chosen your network, go to **Accounts -> Accounts** and press `Add account` button\n\n![Accounts page](../images/creating-an-account/accounts-page.jpg "Accounts page")\n\nYou should see the following panel:\n\n![Add account panel](../images/creating-an-account/add-account-panel.jpg "Add account panel")\n\n- *Name* is just you account\'s name in this exact browser. It makes no sense but convenience.\n- *Seed*. Each transaction must be signed by account\'s unique seed. It has two forms: *Mnemonic* (human-readable) and *Raw* (a sequence of digits and letters). Change *Mnemonic* to *Raw* and copy the seed. **It\'s very important to store it somewhere securely** since secret seeds are used for transactions in [Robonomics IO](/docs/rio-overview/) module. If you have created an account before, you can insert its secret seed here to restore its balance and history.\n- *Password* is used to sign transactions on a portal (in GUI). Create one and remember it.\n\nClick `Save`, `Create and backup account`. A downloaded JSON-file is another way to restore account\'s data on the portal.\n\n## 3. Manage your accounts\nNow you can fully operate with your fresh-created account. Send and receive tokens, messages, write datalog and more. You can forget this account for this exact browser by clicking three dots in opposite of your account\'s name and choosing *Forget this account*. Feel free to explore all the features of portal. To copy your account\'s address simply click on its icon, address will be copied to clipboard.\n\n## 4. Some notes before proceeding to playground\nMost of the playground demos require "Control" account and one or several "Worker" accounts. Transfer units to both before starting, since "Control" needs to send "ON"/"OFF" transactions and "Worker" publishes datalog. Also, each "ON"/"OFF" transaction requires target address, so don\'t forget to copy it from the portal.\n'}},{node:{id:"789283347c200026f4ddc94febc1b3c6",title:"How to contribute",path:"/docs/en/contributing/",content:"\nRobonomics network is an open-source project built by core maintainers from Airalab and contributors. We want to make it easy for anyone to contribute. You may contribute to core, suggest changes, improve documentation or write a blog post. Please, read some rules and suggestions for contributing.\n\n## Main Airalab repositories \n\n- [aira](https://github.com/airalab/aira) - AIRA client for Robonomics network. \n- [robonomics_comm](https://github.com/airalab/robonomics_comm) - Robonomics communication stack\n- [robonomics_contracts](https://github.com/airalab/robonomics_contracts) - smart contracts of Robonomics network\n\n## Bugs and proposals for improvements\n\nIf you find a bug in AIRA client, Robonomics repositories, this documentation or would like to propose an improvement, please, open a new issue in the same repository, that you want to contribute.\n\n### Rules for reporting\n\nWhen opening a new issue, do not forget about a few basic rules for reporting:\n\n1. Choose exact repository, that you want to submit an issue.\n\n2. If you are reporting bug, make sure the bug was not already reported.\n\n3. Be sure to include title and clear description, as much relevant information as possible.\n\n4. Please prefix your issue with one of the following: `[BUG]`, `[PROPOSAL]`, `[QUESTION]`.\n\n\n## Pull requests\n\nAny Airalab repository or this documentation may be subject to pull requests or changes by contributors where you believe you have something valuable to add or change. Please, do not forget about basic rules for contributors.\n\n### Rules for contributing\n\n1. Pull requests are preferred to issues, if you have some fixes, especially for small changes such as typos.\n\n2. Make sure the PR description clearly describes the problem and the solution. Include the relevant issue number if applicable.\n\n3. Please, do not fix whitespace, format code, or make a purely cosmetic patch.\n\n4. Please, attempt to adhere to the prevailing Markdown style, language, and layout.\n\n\n"}},{node:{id:"993217b532ab3f29860c89e6128507b0",title:"Connect the simplest CPS",path:"/docs/en/connect-simple-cps/",content:'\nIn this section we will build the simplest real cyber-physical system!\n\nWe will buy a "wink" from Arduino, e.g. make Arduino blink with its onboard led. The lesson is tested on Arduino Uno, but any other board with a led will do the job.\n\n> The source code of this lesson is [here](https://github.com/airalab/robonomics_tutorials/tree/master/arduino_blink).\n\n## Arduino\n\nThe firmware for the board is located in [arduino_blink/misc/arduino/arduino.ino](https://github.com/airalab/robonomics_tutorials/blob/master/arduino_blink/misc/arduino/arduino.ino). Use [Arduino IDE](https://www.arduino.cc/en/Main/Software) to load the code to your Arduino board.\n\nIn the code we subscribe for the ``/blink_led`` topic and set a callback. The type of the topic is ``Empty``, so the board waits until someone publishes to the topic and performs the LED blinking.\n\n```\n  #include <ros.h>\n  #include <std_msgs/Empty.h>\n\n  ros::NodeHandle  nh;\n\n  void blink(int led, int mil) {\n\n    digitalWrite(led, HIGH);\n    delay(mil);\n    digitalWrite(led, LOW);\n    delay(mil);\n\n  }\n\n  void messageCb( const std_msgs::Empty& toggle_msg){\n    blink(LED_BUILTIN, 500);\n    blink(LED_BUILTIN, 500);\n    blink(LED_BUILTIN, 500);\n  }\n\n  ros::Subscriber<std_msgs::Empty> sub("blink_led", &messageCb );\n\n  void setup()\n  {\n    pinMode(LED_BUILTIN, OUTPUT);\n    nh.initNode();\n    nh.subscribe(sub);\n  }\n\n  void loop()\n  {\n    nh.spinOnce();\n    delay(1);\n  }\n```\n\n\n## AIRA client\n\n> You can download the latest release from [here](https://github.com/airalab/aira/releases).\n\nSet up the COM port forwarding. You should forward your `/dev/ttyUSB0` or `/dev/ttyACM0` port (depending on the system) to `COM1`. In the client `/dev/ttyS0` will represent the board. After this launch the virtual machine.\n\n## ROS\n\nWhen new liability is created it goes to `/liability/ready` topic. We have to remember the address and call `/liability/start` service to get the data from objective.\n\n```\n  def newliability(l):\n    self.liability = l.address\n    rospy.loginfo("Got new liability {}".format(self.liability))\n\n    prefix = "/liability/eth_" + self.liability\n    rospy.Subscriber(prefix + \'/blink\', Empty, self.blink)\n\n    rospy.wait_for_service("/liability/start")\n    rospy.ServiceProxy(\'/liability/start\', StartLiability)(StartLiabilityRequest(address=self.liability))\n  rospy.Subscriber("/liability/ready", Liability, newliability)\n```\n\nA message in the `/blink` topic come from the objective field. Have a look at [Basic usage](/docs/aira-basic-usage) page.\n\n## AIRA\n\nConnect to AIRA client via SSH as described [here](/docs/aira-connecting-via-ssh). All tutorials are pre-installed. To launch the ros package run the following command:\n\n```\n$ rosrun arduino_blink blink.py\n```\n\nAlso we need to add a rosbag file to IPFS::\n\n```\n$ ipfs add rosbag/blink.bag\n```\n\n> Before the next step you should approve XRT tokens on the Factory.\n\nOn your host system build and launch an Dapp for the lesson:\n\n```\n$ git clone https://github.com/airalab/robonomics_tutorials/\n$ cd robonomics_tutorials/arduino_blink_dapp\n$ npm i && npm run dev\n```\n\nOpen [http://localhost:8000/](http://localhost:8000/) and press "Demand" then "Offer" buttons. Wait until a new liability is created and you should see the board blinking. Congratulations on the first agent!\n'}},{node:{id:"dd1924ac9e7e8fee3662b1696b86a7c3",title:"Connect Sensor To Robonomics Network",path:"/docs/en/connect-sensor-to-robonomics/",content:'\n## Requiremets\n* ESP8266 Node MCU v3\n* particle sensor SDS011\n* micro USB cable\n* connecting wires\n\n## Assembling\n### Connection Diagram\n\n![scheme](../images/sensors-connectivity/schema.jpg)\n\n### Connecting SDS011\n\n* Pin 1 (TX) -> (RX) Pin D1 (GPIO5)\n* Pin 2 (RX) -> (TX) Pin D2 (GPIO4)\n* Pin 3 (GND) -> GND\n* Pin 4 (2.5m) -> unused\n* Pin 5 (5V) -> VU\n* Pin 6 (1m) -> unused\n\nSensor is shipped with a USB adapter and connection wires. You don\'t need USB adapter, so disconnect wires from it.\n\n![disconnect](../images/sensors-connectivity/2_assembly_usb.jpg)\n\nYou may connect it to ESP via connecting wires "Female-Male":\n\n![f-m](../images/sensors-connectivity/3_conn.jpg)\n\nAnd connect them to your ESP according to the connection diagram.\n\nOr you can use wires from USB adapter. Disconnect one wire: push on it with some sharp object and carefully pull the wire:\n\n![extreme_con](../images/sensors-connectivity/4_assembly_wires.jpg)\n\nInsert it to last connector:\n\n![extr](../images/sensors-connectivity/5_wires1.jpg)\n\nThen cut the connector in the middle:\n\n![cut](../images/sensors-connectivity/6_assembly_wires2.jpg)\n\nAnd connect them to ESP according to the diagram:\n\n![esp_con](../images/sensors-connectivity/6_esp_con.jpg)\n\n### Connecting DHT22\n\n\n* Pin 1 => 3V3\n* Pin 2 => Pin D7 (GPIO13)\n* Pin 3 => unused\n* Pin 4 => GND\n\n### Connecting BME280/HTU21D\n\n* VCC -> Pin 3V3\n* GND -> Pin GND\n* SCL -> Pin D4 (GPIO2)\n* SDA -> Pin D3 (GPIO0)\n\n\n## Device Firmware\nDownload `airrohr-flasher` from the [latest release](https://github.com/airalab/sensors-connectivity/releases) for your OS. \nConnect ESP to computer via micro-USB and run flasher. \n\n### For Linux:\nFirstly you need to add the user to `dialout` group:\n```bash\nsudo usermod -a -G dialout $USER\n```\nThen logout and login or restart computer.\n\nNow you can run flasher (don\'t forget to give it permission to execute):\n```bash\nchmod +x airrohr-flasher-linux\n./airrohr-flasher-linux\n```\n\n### For Windows:\nUnpack flasher and run it with double click.\nYou need to install drivers for the USB2serial chipset (Windows 10 should be able to automatically download these):\n\n* Drivers for NodeMCU v3 (CH340): [Windows](http://www.wch.cn/downloads/file/5.html) ([2018/09/04 v3.4 mirror](https://d.inf.re/luftdaten/CH341SER.ZIP))\n\n\n### For MacOS\nDownload flasher and run it.\nYou need to install drivers for the USB2serial chipset: \n* Drivers for NodeMCU v3 (CH340): [MacOS](http://www.wch.cn/downloads/file/178.html) ([2018/09/04 v1.4 mirror](https://d.inf.re/luftdaten/CH341SER_MAC.ZIP))\n\n\nChoose firmware (English or Russian) and press upload. It will take a few minutes.\n\n![flasher](../images/sensors-connectivity/7_flasher.jpg)\n\n\n## Configuration\nReboot your ESP (simply reconnect USB to computer).\nThen connect to airRohr--xxxxxxx Wi-Fi network and in your browser write address 192.168.4.1:\n\n![menu](../images/sensors-connectivity/8_menu1.jpg)\n\nGo to Configuration -> Wi-Fi Settings and add the information about your Wi-Fi network:\n\n![config](../images/sensors-connectivity/9_W-fi.jpg)\n\nThen press "Save configuration and restart" and ESP will be connected to the provided Wi-Fi network.\n\n![save](../images/sensors-connectivity/10_save.jpg)\n\n\nThen find ESP in local network (for that your computer and ESP must be in one network). You can do it using airrohr-flasher. Run it, go to the Discovery tab and press Refresh, then you\'ll be able to see the address.\n\n![addr](../images/sensors-connectivity/11_flaser2.jpg)\n\n\n\nOpen ESP local address in your browser, go to `APIs` tab in  `Configuration` and click `Robonomics`. \n\n![robonomics](../images/sensors-connectivity/12_APIrobonomics.jpg)\n\n> If you want to send data to your own server, enable `Custom API` and write your address and port \n\nThen go to `Sensors` tab, enable GPS and put in your coordinates. Also enable the sensors you connected:\n\n![gps](../images/sensors-connectivity/13_gps.jpg)\n\nThen press `Save configuration and restart`.\n\n\n\n## Results\nGo to [sensors.robonomics.network](https://sensors.robonomics.network/#/), and you will see your sensor on the map.\n\n![map](../images/sensors-connectivity/14_map.jpg)\n'}},{node:{id:"5d69df7948e0bf05939bcb1f3c3dc507",title:"Connect Mars Curiosity rover under Robonomics parachain control",path:"/docs/en/connect-mars-curiosity-rover-under-robonomics-parachain-control/",content:'\n**Let\'s see how Robonomics Parachain control allows to make Mars Curiosity rover move. Requirements:**\n- Ubuntu 18.04 LTS\n- ROS Melodic + Gazebo + RViz (installation manual [here](http://wiki.ros.org/melodic/Installation))\n- extra packages:\n```shell\nsudo apt-get install ros-melodic-gazebo-ros-control ros-melodic-effort-controllers ros-melodic-joint-state-controller\n```\n- IPFS 0.4.22 (download from [here](https://dist.ipfs.io/go-ipfs/v0.4.22/go-ipfs_v0.4.22_linux-386.tar.gz) and install)\n- Python dependencies:\n```\npip install ipfshttpclient\n```\n- Robonomics node (binary file) (download latest release [here](https://github.com/airalab/robonomics/releases))\n- IPFS browser extension (optional)\n\nHere is the video showing successful launch:\n\nhttps://youtu.be/pl3eIEC_T2o\n\n## 1. Set up a simulation\nDownload Curiosity rover package:\n```\nmkdir -p robonomics_ws/src\ncd robonomics_ws/src\ngit clone https://bitbucket.org/theconstructcore/curiosity_mars_rover/src/master/\ncd ..\n```\nWe need to adjust starting conditions to make our rover spawn smoothly:\n- Go to\n\n`/robonomics_ws/src/master/curiosity_mars_rover_description/worlds` and change line 14 of the file` mars_curiosity.world` to\n`<pose>0 0 9 0 0 0</pose>`.\n\n- Go to\n\n`/robonomics_ws/src/master/curiosity_mars_rover_description/launch` and change line 4 of the file `mars_curiosity_world.launch` to\n`<arg name="paused" default="false"/>`.\n\nDon’t forget to add source command to `~/.bashrc`:\n```\necho "source /home/$USER/robonomics_ws/devel/setup.bash" >> ~/.bashrc\n```\n\n## 2. Download controller package\nIn terminal do the following. This will download a sample script used in the demo:\n```\ncd ~/robonomics_ws/src\ngit clone https://github.com/PaTara43/robonomics_sample_controller\ncd ../..\ncatkin build\n```\n\n## 3. Manage accounts in DAPP\nSince we are testing, let\'s create a local robonomics network node with robonomics binary file:\n```\n./robonomics --dev --rpc-cors all\n```\n**Important!** Before next launches it is necessary to remove a directory `db` with\n\n```\nrm -rf /home/$USER/.local/share/robonomics/chains/dev/db\n```\n\nAfter a successful launch create accounts for the rover and for it\'s employer following [this](/docs/create-account-in-dapp) manual. **Do not forget to save each account\'s seed (RAW SEED) and address! You will need them for transactions**. Add these addresses, seeds and path to robonomics binary file to file `config.config` in `robonomics_ws/src/robonomics_sample_controller/src`. Transfer some money (units) to these accounts:\n\n![Config](../images/curiosity-demo/config.jpg "Config")\n\n![Balances](../images/curiosity-demo/balances.jpg "Balances")\n\n## 4. Start Robonomics\nUp to now the **only thing running** should be the robonomics local node.\nIn a separate terminal launch IPFS:\n```\nipfs init # you only need to do this once\nipfs daemon\n```\nIn another separate terminal launch Curiosity simulation:\n```\nroslaunch curiosity_mars_rover_description main_real_mars.launch\n```\nWait till it stays still and after that in another terminal launch the controller:\n```\nrosrun robonomics_sample_controller sample_controller.py\n```\n\n![Curiosity](../images/curiosity-demo/curiosity.jpg "Curiosity")\n\nNow you can send a transaction triggering the Rover to start moving and collecting data. To do so, you should use the [Robonomics IO](https://wiki.robonomics.network/docs/rio-overview/)  `write` subcommand of robonomics binary file:\n```\necho "ON" | ./robonomics io write launch -r <CURIOSITY ADDRESS> -s <EMPLOYER’S KEY>\n```\nWhere `<CURIOSITY ADDRESS>`  and `<EMPLOYER’S KEY>` are replaced with  previously saved strings accordingly.\nYou should see the log `"Arming..."` and the robot should start moving its camera and arm. Later, when the job is done (there is a log informing user when the program has finished), on the Robonomics portal go to `Developer` -> `Chain state` and add a CURIOSITY datalog using `“+”` button with selected `datalog` as state query:\n\n![Datalog](../images/curiosity-demo/hash_in_chain.jpg "Datalog")\n\nThe IPFS hash of the telemetry has been saved in the blockchain. To see the data simply copy the hash and add it to the local [gateway](https://gateway.ipfs.io/ipfs/QmeYYwD4y4DgVVdAzhT7wW5vrvmbKPQj8wcV2pAzjbj886/docs/getting-started/) address `localhost:8080/ipfs/`:\n\n![Voila](../images/curiosity-demo/datalog.jpg "Voila")\n\n## Troubleshooting\n\nIf due to some reason addresses in IO module and on the portal are displayed unequally (e.g. `5...` and `4...`) and the program outputs "Not my job is paid", fill in configuration file with address of the same type as in IO module.\n'}},{node:{id:"032f7e6a77a98034800adac67d330b05",title:"Connect any ROS-compatitable robot under Robonomics parachain control. Part 2, IPFS",path:"/docs/en/connect-any-ros-compatitable-robot-under-robonomics-parachain-control-2/",content:'\n**In this article we will continue using Robonomics tools to make a drone be controlled by a parachain. This time we will add sending data to IPFS and hash storing in chain options. Below is the instruction and code snippets. Requirements:**\n- [**Part 1 of this tutorial**](/docs/connect-any-ros-compatitable-robot-under-robonomics-parachain-control-1)\n- Ubuntu 18.04 LTS\n- ROS Melodic + Gazebo + RViz (installation manual [here](http://wiki.ros.org/melodic/Installation))\n- IPFS 0.4.22 (download from [here](https://dist.ipfs.io/go-ipfs/v0.4.22/go-ipfs_v0.4.22_linux-386.tar.gz) and install)\n- Robonomics node (binary file) (download latest release [here](https://github.com/airalab/robonomics/releases))\n- Python dependencies:\n```\npip install cv_bridge ipfshttpclient\n```\nThe entire process of coding this part of demo is presented in a video below.\n\nhttps://www.youtube.com/watch?v=dliLb6GHgpo&feature=youtu.be\n\n\n## 1. Add dependencies\nIf we launch a simulation and look at the topic list (see previous tutorial), we will see, that there is one topic containing front camera data and using `sensor_msgs/Image` message type:\n\n![front_camera](../images/drone-demo/front_camera.jpg "front_camera")\n\nLet\'s try to take a picture every 1 second and after the flight publish these photos to IPFS. If you have completed the first tutorial, you don\'t need to download anything else. It\'s the `drone_sample_controller_pictures.py` script.\n## 2. Manage accounts in DAPP\nAs done in a previous tutorial, create a local robonomics network node with robonomics binary file:\n```\n./robonomics --dev\n```\n**Important!** Before next launches it is necessary to remove a directory `db` with\n```\nrm -rf /home/$USER/.local/share/robonomics/chains/dev/db\n```\nAfter a successful launch create accounts following [this](/docs/create-account-in-dapp) manual. **Do not forget to save each account\'s seed and address! You will need them for transactions**. Add these addresses, seeds and path to robonomics binary file to file `config.config` in `robonomics_ws/src/robonomics_sample_controller/src`. Transfer some money (units) to these accounts:\n\n![balances](../images/drone-demo/balances.jpg "balances")\n## 3. Launch\nUp to now the **only thing running** should be the robonomics local node. In a separate terminal launch drone simulation:\n```\nroslaunch sjtu_drone simple.launch\n```\nIn another one launch ipfs daemon:\n```\nifps init # you only need to do this once\nipfs daemon\n```\nRun the script:\n```\nrosrun drone_simulator_controller drone_sample_controller_pictures.py\n```\nNow you can send a transaction triggering the drone to start flying and taking pictures. To do so, you should use the Robonomics IO `write` subcommand of robonomics binary file:\n```\necho "ON" | ./robonomics io write launch -r <DRONE_ADDRESS> -s <EMPLOYER’S_KEY>\n```\nWhere `<DRONE_ADDRESS>`  and `<EMPLOYER’S_KEY>` are replaced with  previously saved strings accordingly.\nYou should see the log `"Taking Off"` and the drone should start flying and taking pictures:\n\n![flying_picturing](../images/drone-demo/flying_picturing.jpg "flying_picturing")\n\nLater, when the job is done, on the Robonomics portal go to `Developer` -> `Chain state` and add a `DRONE` datalog using `“+”` button with selected `datalog` as state query. The IPFS hash of the telemetry has been saved in the blockchain. To see the data simply copy the hash and add it to the local [gateway](https://gateway.ipfs.io/ipfs/QmeYYwD4y4DgVVdAzhT7wW5vrvmbKPQj8wcV2pAzjbj886/docs/getting-started/) address `localhost:8080/ipfs/`:\n\n![Voila](../images/drone-demo/datalog.jpg "Voila")\n'}},{node:{id:"17287566c793a5c31aa439d1ef13b60b",title:"Connect ROS-compatibale Drone To Robonomics Parachain. Part 1. Launch by Transaction",path:"/docs/en/connect-any-ros-compatitable-robot-under-robonomics-parachain-control-1/",content:'\n**In this article we will show that with the help of Robonomics tools you can control any ROS-compatitable device. We will find a random drone simulation package on the web and adjust it to run with Robonomics.**\n**Requirements:**\n- Ubuntu 18.04 LTS\n- ROS Melodic + Gazebo + RViz (installation manual [here](http://wiki.ros.org/melodic/Installation))\n- Robonomics node (binary file) (download latest release [here](https://github.com/airalab/robonomics/releases))\n\nThe entire process of coding this part of demo is presented in a video below.\n\nhttps://www.youtube.com/watch?v=fDpwhBasQ5o&feature=youtu.be\n\n## 1. Find a simulation\nLet\'s surf the web. Google for `ROS drone simulator`. The first link will mostly likely show you the `tum_simulator` page on [http://wiki.ros.org/tum_simulator](http://wiki.ros.org/tum_simulator)\n\n![tum_simulator](../images/drone-demo/tum_simulator.jpg "tum_simulator")\n\nIt\'s pretty outdated, so we better find a fork for our system. Google for `tum_simulator Ubuntu 18 Gazebo 9 fork`. The first result is a GitHub [repo](https://github.com/tahsinkose/sjtu-drone) with an appropriate package. Dowload it\n```\nmkdir -p drone_simulator_ws/src\ncd drone_simulator_ws/src\ngit clone https://github.com/tahsinkose/sjtu-drone\ncd ..\ncatkin build\n```\nDon’t forget to add source command to `~/.bashrc`:\n```\necho "source /home/$USER/drone_simulator_ws/devel/setup.bash" >> ~/.bashrc\nsource "~/.bashrc"\n```\nNow we can run the simulation to see what do we need to do to take the drone under parachain control.\n```\nroslaunch sjtu_drone simple.launch\n```\n\n## 2. Inspect ROS topics\nWhen the simulation is runnung, in a new tab run the following command to see the list of topics used by the drone:\n```\nrostopic list\n```\nLet\'s take a look at `/cmd_vel`, `/drone/takeoff` and `/drone/land`:\n```\nrostopic info /cmd_vel\nrostopic info /drone/takeoff\nrostopic info /drone/land\n```\n\n![topics_info](../images/drone-demo/topics_info.jpg "topics_info")\n\nAs may be seen, there should be messages of `Twist` and `Empty` types, they are parts of `std_msgs` and `geometry_msgs`, we\'ll use this in the controller. Shut the simulation for a while.\n## 3. Download controller package\nGlobally, the main difference from the casual ROS robot controller is a block of code, which checks all the transactions in the network using [Robonomics IO](https://wiki.robonomics.network/docs/rio-overview/). The package itself is available on GitHub. Download it and build the workspace:\n```\ncd ~/drone_simulator_ws/src\ngit clone https://github.com/PaTara43/drone_simulator_controller\ncd drone_simulator_controller/src\nchmod +x *.py\ncd ~/drone_simulator_ws/src\ncatkin build\n```\n## 4. Manage accounts in DAPP\nSince we are testing, let\'s create a local robonomics network node with robonomics binary file:\n```\n./robonomics --dev\n```\n**Important!** Before next launches it is necessary to remove a directory `db` with\n\n```\nrm -rf /home/$USER/.local/share/robonomics/chains/dev/db\n```\nAfter a successful launch create accounts following [this](/docs/create-account-in-dapp) manual. **Do not forget to save each account\'s seed and address! You will need them for transactions**. Add these addresses, seeds and path to robonomics binary file to file `config.config` in `robonomics_ws/src/robonomics_sample_controller/src`. Transfer some money (units) to these accounts:\n\n![balances](../images/drone-demo/balances.jpg "balances")\n## 5. Launching the drone under parachain control\nUp to now the **only thing running** should be the robonomics local node. In a separate terminal launch drone simulation:\n```\nroslaunch sjtu_drone simple.launch\n```\nRun the script:\n```\nrosrun drone_simulator_controller drone_sample_controller.py\n```\n\n![launched_drone](../images/drone-demo/launched_drone.jpg "launched_drone")\n\nNow you can send a transaction triggering the drone to start flying. To do so, you should use the Robonomics IO `write` subcommand of robonomics binary file:\n```\necho "ON" | ./robonomics io write launch -r <DRONE_ADDRESS> -s <EMPLOYER’S_KEY>\n```\nWhere `<DRONE_ADDRESS>`  and `<EMPLOYER’S_KEY>` are replaced with  previously saved strings accordingly.\nYou should see the log `"Taking Off"` and the drone should start flying:\n\n![flying](../images/drone-demo/flying.jpg "flying")\n\nThat\'s how any ROS-compatitable robot can be controlled by Robonomics parachain control. Proceed to [part 2](/docs/connect-any-ros-compatitable-robot-under-robonomics-parachain-control-2) to learn more\n'}},{node:{id:"b925fa1f52f5f979217b930315a898eb",title:"Configuration Options Description",path:"/docs/en/configuration-options-description/",content:'\nBasically, you can think of the package as a black box with one input (sensor data) and many outputs.\nFor now only SDS011 sensor is supported, but if you are familiar with Python it\'d be easy to add other sensors as well.\n\nHave a look at [configuration](https://github.com/airalab/sensors-connectivity/blob/master/config/default.json) file:\n\n```json\n{\n   "general":{\n      "publish_interval":30\n   },\n   "comstation":{\n      "enable":false,\n      "port":"/dev/ttyUSB0",\n      "work_period":300,\n      "geo":"",\n      "public_key":""\n   },\n   "httpstation":{\n      "enable":true,\n      "port":8001\n   },\n   "mqttstation": {\n      "enable": true,\n      "host": "connectivity.robonomics.network",\n      "port": 1883\n   },\n   "luftdaten":{\n      "enable":true\n   },\n   "robonomics":{\n      "enable":true,\n      "ipfs_provider":"/ip4/127.0.0.1/tcp/5001/http",\n      "ipfs_topic":"airalab.lighthouse.5.robonomics.eth"\n   },\n   "datalog":{\n      "enable":false,\n      "path":"",\n      "suri":"",\n      "remote":"wss://substrate.ipci.io",\n      "dump_interval":3600,\n      "temporal_username":"",\n      "temporal_password":""\n   },\n   "dev":{\n      "sentry":""\n   }\n}\n```\nAt the moment it\'s possible to publish data to [Luftdaten](https://luftdaten.info/), [Robonomics Network](https://robonomics.network/) and [Datalog](https://github.com/airalab/robonomics).\nThe last one is experimental!\n\n> DO NOT edit `config/default.json` file. Instead make a copy\n\nPlay around with the configuration!\n\nExplanation of options:\n\n| Field                         | Description                                                                                                                                                                                                                                           |\n|------------------------------    |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------    |\n| `general/publish_interval`         | integer number from 1 and above. Tells how often send measurements. Keep in mind that if measurements from sensors come less often than this number connectivity sends last data      |\n| `comstation/enable`                | true/false. Enabling/disabling the station      |\n| `comstation/port`                  | valid path to com port, for example `/dev/ttyUSB0`. It is where a sensor is connected to      |\n| `comstation/work_period`           | integer from 0 to 1800. For SDS011 sensor 0 means continuous work. Recommended period is 300 seconds     |\n| `comstation/geo`                   | `lat,lon` a string with two floats separated by a comma. It represents latitude and longitude of a sensor     |\n| `comstation/public_key`            | Ed25519 verifying key in hex format. If not provided connectivity generates a new one      |\n| `httpstation/enable`                | true/false. Enabling/disabling the station   |\n| `httpstation/port`                  | what port listen to      |\n| `mqttstation/enable`                | true/false. Enabling/disabling the station   |\n|`mqttstation/host`                   | the hostname or IP address of the remote broker |\n|`mqttstation/port`                   | the network port of the server host to connect to |\n| `luftdaten/enable`                 | true/false. Whether or not publish data to [Luftdaten](https://devices.sensor.community/). Don\'t forget to register the sensor\'s mac address on the site         |\n| `robonomics/enable`                | true/false. Whether or not publish data to IPFS topic according to Robonomics communication protocol      |\n| `robonomics/ipfs_proveder`         | an endpoint for IPFS daemon. By default it\'s `/ip4/127.0.0.1/tcp/5001/http` that means local daemon. The endpoint must by in multiaddr format. For example for [Infura.io](https://infura.io/) it would be `/dns/ipfs.infura.io/tcp/5001/https`       |\n| `robonomics/ipfs_topic`            | IPFS topic\'s name. If you want to use [DApp](https://sensors.robonomics.network) provided by Robonomics team leave it untouched                 |\n| `datalog/enable`                   | true/false. Enable/Disable saving log to [Robonomics on Substrate chain](https://ui.ipci.io/)    |\n| `datalog/path`                     | full path to `robonomics` executable file. You can find the latest release on [this](https://github.com/airalab/robonomics/releases) page  |\n| `datalog/suri`                     | a private key from substrate chain account  |\n| `datalog/remote`                   | an endpoint to substrate instance                                                           |\n| `datalog/dump_interval`            | specify a period of time for collecting log in seconds                                      |\n| `datalog/temporal_username`        | set username to upload files to [Temporal.Cloud](https://temporal.cloud/) (Optional)                  |\n| `detalog/temporal_password`        | set password to upload files to [Temporal.Cloud](https://temporal.cloud/) (Optional)                  |\n| `dev/sentry`                       | for development purpose. If you have a [Sentry.io](https://sentry.io/) account you can put sentry\'s credentials in here   |\n\n## Scenario #1: Connect SDS011 to serial port\n\nThe easiest and the most straightforward way to connect your sensor to the network is using the serial port\n\nConnect you SDS011 sensor to a USB port, let\'s assume it got `/dev/ttyUSB0` address\n\n```json\n{\n   "general":{\n      "publish_interval":30            \n   },\n   "comstation":{\n      "enable":true,\n      "port":"/dev/ttyUSB0",\n      "work_period":300,\n      "geo":"59.944954,30.294534",\n      "public_key":""\n   },\n   "httpstation":{\n      "enable":false,\n      "port":8001\n   },\n   "luftdaten":{\n      "enable":true\n   },\n   "robonomics":{\n      "enable":true,\n      "ipfs_provider":"/ip4/127.0.0.1/tcp/5001/http",\n      "ipfs_topic":"airalab.lighthouse.5.robonomics.eth"\n   },\n   "datalog":{\n      "enable":false,\n      "path":"",\n      "suri":"",\n      "remote":"wss://substrate.ipci.io",\n      "dump_interval":3600,\n      "temporal_username":"",\n      "temporal_password":""\n   },\n   "dev":{\n      "sentry":""\n   }\n}\n```\n\n## Scenario #2: Connect SDS011 via HTTP\n\n### Connectivity Configuration\n\n```json\n{\n   "general":{\n      "publish_interval":30            \n   },\n   "comstation":{\n      "enable":false,\n      "port":"/dev/ttyUSB0",\n      "work_period":300,\n      "geo":"59.944954,30.294534",\n      "public_key":""\n   },\n   "httpstation":{\n      "enable":true,\n      "port":8001\n   },\n   "luftdaten":{\n      "enable":true\n   },\n   "robonomics":{\n      "enable":true,\n      "ipfs_provider":"/ip4/127.0.0.1/tcp/5001/http",\n      "ipfs_topic":"airalab.lighthouse.5.robonomics.eth"\n   },\n   "datalog":{\n      "enable":false,\n      "path":"",\n      "suri":"",\n      "remote":"wss://substrate.ipci.io",\n      "dump_interval":3600,\n      "temporal_username":"",\n      "temporal_password":""\n   },\n   "dev":{\n      "sentry":""\n   }\n}\n```\n\n> Do not forget to open the port in system firewall\n>\n> On NixOS you can do:\n> ```\n> networking.firewall.allowedTCPPorts = [ 31313 ];\n> ```\n\n## Scenario #3: Connect SDS011 via MQTT\n\n### Connectivity Configuration\n\n```json\n{\n   "general":{\n      "publish_interval":30\n   },\n   "comstation":{\n      "enable":false,\n      "port":"/dev/ttyUSB0",\n      "work_period":300,\n      "geo":"",\n      "public_key":""\n   },\n   "httpstation":{\n      "enable":true,\n      "port":8001\n   },\n   "mqttstation": {\n      "enable": true,\n      "host": "connectivity.robonomics.network",\n      "port": 1883\n   },\n   "luftdaten":{\n      "enable":true\n   },\n   "robonomics":{\n      "enable":true,\n      "ipfs_provider":"/ip4/127.0.0.1/tcp/5001/http",\n      "ipfs_topic":"airalab.lighthouse.5.robonomics.eth"\n   },\n   "datalog":{\n      "enable":false,\n      "path":"",\n      "suri":"",\n      "remote":"wss://substrate.ipci.io",\n      "dump_interval":3600,\n      "temporal_username":"",\n      "temporal_password":""\n   },\n   "dev":{\n      "sentry":""\n   }\n}\n```\n\n## Scenario #4: Connect Multiple Sensors and Publish to Datalog\n\n### Install Robonomics\n\nFrom `root` user do:\n\n```\necho "https://github.com/airalab/airapkgs/archive/nixos-unstable.tar.gz nixos" > /root/.nix-channels\nnix-channel --update\n```\n\nThen edit `/etc/nixos/configuration.nix` and add:\n\n```\n...\n  environment.systemPackages = with pkgs; [\n        substrate-node-robonomics-bin\n  ];\n...\n```\n\nRun rebuild and find out where `robonomics` is:\n```\nnixos-rebuild switch\nwhereis robonomics\n```\n\nLet\'s assume you got the following path: `/nix/store/2gz2ik17w5xad8w819bsb05a23pbjbya-system-path/bin/robonomics`\n\n### Configuration\n\n```json\n{\n   "general":{\n      "publish_interval":30            \n   },\n   "comstation":{\n      "enable":false,\n      "port":"/dev/ttyUSB0",\n      "work_period":300,\n      "geo":"59.944954,30.294534",\n      "public_key":""\n   },\n   "httpstation":{\n      "enable":true,\n      "port":8001\n   },\n   "luftdaten":{\n      "enable":true\n   },\n   "robonomics":{\n      "enable":true,\n      "ipfs_provider":"/ip4/127.0.0.1/tcp/5001/http",\n      "ipfs_topic":"airalab.lighthouse.5.robonomics.eth"\n   },\n   "datalog":{\n      "enable":true,\n      "path":"/nix/store/2gz2ik17w5xad8w819bsb05a23pbjbya-system-path/bin/robonomics",\n      "suri":"0x...",\n      "remote":"wss://substrate.ipci.io",\n      "dump_interval":3600,\n      "temporal_username":"temporaluser",\n      "temporal_password":"temporalpass"\n   },\n   "dev":{\n      "sentry":""\n   }\n}\n```\n\n\n'}},{node:{id:"1e80f2902469c07db9a76d4634eb9973",title:"Community",path:"/docs/en/community/",content:"\n**Here you can learn how to get involved in the Robonomics Network Community.**\n\nThere are many ways to contribute to Robonomics Network: you can contribute directly based on your skills and professional background, you can attend an event, join the conversation online or watch for our latest news and release.\n\n## For Developers\n\n- [Robonomics' code base and new releases on GitHub](https://github.com/airalab)\n- [Ask your technical question on Riot](https://riot.im/app/#/room/#robonomics:matrix.org)\n\n## For Researchers & Academics\n\n- [Read Robonomics White Paper and our scientific articles](https://robonomics.network/community/#science)\n\nIf you have a background in mathematics, cryptography, or economics you might be interested for collaboration with us, write us to [research@aira.life](mailto:research@aira.life)\n\n## For All, even non-technical\n\n- [Get familiar with Robonomics services and statistics in dApp - open in browser with Metamask](https://dapp.robonomics.network)\n- [Read our blog](https://blog.aira.life)\n- [Stay tuned by following us on Twitter](https://twitter.com/AIRA_Robonomics)\n\nIf you are not a developer or a researcher, you can start with other suggestions for getting involeved in Robonomics Network Community. If you want to organize a meetup in your city, write content about Robonomics, translate Robonomics content into your native language, write to [community@aira.life](mailto:community@aira.life)\n"}},{node:{id:"7ce7403be7eef85384c10e1616d88aa6",title:'Say "Hello Baxter!" with robonomics',path:"/docs/en/baxter2/",content:'\nExample of how it works is available [here][db1].\n\n## Requirements:\n - Ubuntu 18.04\n - ROS Melodic + Gazebo (installation manual [here][db2])  \n - extra packages:\n```sh\nsudo apt-get install ros-melodic-qt-build ros-melodic-driver-common ros-melodic-gazebo-ros-control ros-melodic-gazebo-ros-pkgs ros-melodic-ros-control ros-melodic-control-toolbox ros-melodic-realtime-tools ros-melodic-ros-controllers ros-melodic-xacro python-wstool ros-melodic-tf-conversions ros-melodic-kdl-parser python-wstool python-catkin-tools qt4-default\n```\n\n- IPFS 0.4.22 (download from [here][db3] and install)\n- pip:\n```sh\nsudo apt install python-pip\n```\n\n- ipfshttpclient\n```sh\npip install ipfshttpclient\n```  \n\n\n - Robonomics node (binary file) (download latest [release][db4] here)\n - Create __Baxter__ and __Employer__ accounts  on **Robonomics Portal**  \n (you can find tutorial ["Create an Account on Robonomics Portal"][db8] here).\n - IPFS browser extension (not necessary)\n\n## 1. Download Baxter model\nDownload packages:\n```sh\ncd ~\nmkdir -p robot_ws/src\ncd robot_ws/src/\nwstool init .\nwstool merge https://raw.githubusercontent.com/RethinkRobotics/baxter_simulator/master/baxter_simulator.rosinstall\nwstool update\ngit clone https://github.com/nakata5321/Baxter_simulation_controller.git\n```\nThis packages were created for ROS indigo. We have to change some files to run them on ROS melodic.\nWe will use **patch** files.\n```sh\npatch ./baxter_simulator/baxter_sim_io/include/baxter_sim_io/qnode.hpp ./Baxter_simulation_controller/patch/qnode_patch\npatch ./baxter_simulator/baxter_sim_kinematics/src/arm_kinematics.cpp ./Baxter_simulation_controller/patch/arm_patch\n```\nAnd let\'s build  all our packages:\n```sh\ncd ..\ncatkin build\n```\nDont forget to add source command:\n```sh\necho "source /home/$USER/robot_ws/devel/setup.bash" >> ~/.bashrc\nsource ~/.bashrc\n```  \n__Important!__ At the end save *Robonomics node (binary file)* in **robot_ws** directory.\n\n## 2. Start simulation\nFirst of all copy and edit `baxter.sh`\n```sh\ncp src/baxter/baxter.sh .\n```\n\nFind your local ip adress with command:\n```\nip a\n```\n![ip_a][im14]\n\nEdit the following values in `baxter.sh` :\n```\nnano baxter.sh\n```\n\nEdit the following values in `baxter.sh` :\n\n- your_ip - put your local ip address. See `ip a`\n- ros_version - for example "melodic"\n\n![baxtersh][im15]\n\nRun the baxter shell script with sim specified:\n```sh\n./baxter.sh sim\nroslaunch baxter_gazebo baxter_world.launch\n```\nYou can put some models in front of our baxter. It will be more intresting.\n![baxter][im2]\n\n## 3.Manage accounts in DAPP\n\nSince we are testing, let us create a local robonomics network with robonomics binary file. Go to folder with robonomics file and run:\n```sh\n./robonomics --dev --rpc-cors all\n```\n![robonomics][im3]\n\nDon\'t forget to remove `db` folder after every launch:\n```sh\nrm -rf /home/$USER/.local/share/robonomics/chains/dev/db\n```\n\nGo to [https://parachain.robonomics.network][db5] and switch to local node\n![local node][im4]\n\nGo to Accounts and transfer some money to __Baxter__ and __Employer__ accounts.\n\nYou can find The manual "Create an Account on Robonomics Portal" [here.][db8]\n\n\nAdd Baxter\'s secret key and adress to `config.yaml` in `robot_ws/src/Baxter_simulation_controller/config/`\n\n## 4.Beginning of work\n\nIn new window run:\n```sh\nifps init #you only need to do this once\nipfs daemon\n```\nOpen separate terminal and start *controller package*:\n```sh\nrosrun robot_controller robot_control.py\n```\n![waiting][im7]\n\nReturn to the first terminal, open new window and send command to [**robonomics io**][db6]. This command will turn ON your robot:\n```sh\necho "ON" | ./robonomics io write launch -r <BAXTER ADDRESS> -s <EMPLOYER’S KEY>\n```\nWhere `<BAXTER ADDRESS>`  and `<EMPLOYER’S KEY>` are replaced with previously saved strings accordingly.\n\n![rob_message][im8]\n\nYou should see the following:\n\n![working][im9]\n\nwhen the work is over go to the Robonomics Portal to `Developer > Chain state`. Choose *datalog* in **state query** and add Baxter datalog message using "+" button.\n\n![datalog][im10]\n\nNow the IPFS hash of the telemetry and photos is saved in the blockchain. To see the data simply copy the hash and insert it in the search bar with URL: `gateway.ipfs.io/ipfs/<put your hash here>`\n\n\nThat\'s all!\n\n![result1][im12]\n![result2][im13]\n\n[db1]: <https://youtu.be/2AQGFVzkGdg>\n[db2]: <http://wiki.ros.org/melodic/Installation>\n[db3]: <https://dist.ipfs.io/go-ipfs/v0.4.22/go-ipfs_v0.4.22_linux-386.tar.gz>\n[db4]: <https://github.com/airalab/robonomics/releases>\n[db8]: </docs/create-account-in-dapp>\n[im1]: <../images/baxter_demo/empty_world.jpg>\n[im2]: <../images/baxter_demo/baxter_simulation.jpg>\n[im3]: <../images/baxter_demo/robonomics.jpg>\n[db5]: <https://parachain.robonomics.network>\n[im4]: <../images/baxter_demo/local_node.jpg>\n[im7]: <../images/baxter_demo/waiting.jpg>\n[im8]: <../images/baxter_demo/rob_message.jpg>\n[im9]: <../images/baxter_demo/working.jpg>\n[im10]: <../images/baxter_demo/datalog.jpg>\n[im11]: <../images/baxter_demo/ipfs.jpg>\n[im12]: <../images/baxter_demo/result1.jpg>\n[im13]: <../images/baxter_demo/result2.jpg>\n[db6]: </docs/rio-overview>\n[im14]:<../images/baxter_demo/ip_a.png>\n[im15]:<../images/baxter_demo/baxter_sh.jpg>\n'}},{node:{id:"d9860973577427c52e0252080d6e5de0",title:"Control Baxter robot with robonomics",path:"/docs/en/baxter/",content:'\nExample of how it works:\n\nhttps://youtu.be/AeufQmaNRWk\n\n## Requirements:\n - Ubuntu 18.04\n - ROS Melodic + Gazebo (installation manual [here][db2])  \n - extra packages:\n```sh\nsudo apt-get install ros-melodic-gazebo-ros-control ros-melodic-effort-controllers ros-melodic-joint-state-controller\n```\n- IPFS 0.4.22 (download from [here][db3] and install)\n- pip:\n```sh\nsudo apt install python-pip\n```\n\n- ipfshttpclient:\n```sh\npip install ipfshttpclient\n```\n\n\n - Robonomics node (binary file) (download latest [release][db4] here)\n - Create __Baxter__ and __Employer__ accounts  on **Robonomics Portal**  \n (you can find tutorial ["Create an Account on Robonomics Portal"][db6] here).\n - IPFS browser extension (not necessary)\n\n## 1. Download Baxter model and controller packages\nDownload packages:\n```sh\ncd ~\nmkdir -p robot_ws/src\ncd robot_ws/src\ngit clone https://github.com/nakata5321/Baxter_simulation_controller.git\ncd Baxter_simulation_controller\ngit checkout old_version\ncd ../..\ncatkin build\n```\nDont forget to add source command:\n```sh\necho "source /home/$USER/robot_ws/devel/setup.bash" >> ~/.bashrc\nsource ~/.bashrc\n```\n\n## 2. Create simulation world\nLet\'s start gazebo world and put our baxter in it:\n```sh\nroslaunch gazebo_ros empty_world.launch\n```\n![empty world][im1]\n\nOpen one more window in terminal:\n```sh\nrosrun gazebo_ros spawn_model -file `rospack find baxter_description`/urdf/baxter.urdf -urdf -z 1 -model baxter\n```\nYou can put some models in front of our baxter. It will be more intresting.\n![baxter][im2]\n\n## 3.Manage accounts in DAPP\n\nSince we are testing, let us create a local robonomics network with robonomics binary file. Go to folder with robonomics file and run:\n```sh\n./robonomics --dev --rpc-cors all\n```\n![robonomics][im3]\n\nDon\'t forget to remove `db` folder after every launch:\n```sh\nrm -rf /home/$USER/.local/share/robonomics/chains/dev/db\n```\n\nGo to [https://parachain.robonomics.network][db5] and switch to local node\n![local node][im4]\n\nGo to Accounts and transfer some money to __Baxter__ and __Employer__ accounts.\n\nYou can find The manual "Create an Account on Robonomics Portal" [here.][db6]\n\nAdd Baxter\'s secret key and adress to `configuration.txt` in `robot_ws/src/robot_controller/src/`\n\n## 4.Start simulation\n\nIn new window run:\n```sh\nifps init #you only need to do this once\nipfs daemon\n```\nOpen separate terminal and start *controller package*:\n```sh\nrosrun robot_controller robot_control.py\n```\n![waiting][im7]\n\nReturn to the first terminal, open new window and send command to [**robonomics io**][db7]. This command will turn ON your robot:\n```sh\necho "ON" | ./robonomics io write launch -r <CURIOSITY ADDRESS> -s <EMPLOYER’S KEY>\n```\nWhere `<CURIOSITY ADDRESS>` and `<EMPLOYER’S KEY>` are replaced with previously saved strings accordingly\n\n![rob_message][im8]\n\nYou should see the following:\n\n![working][im9]\n\nwhen the work is over go to the Robonomics Portal to `Developer > Chain state`. Choose *datalog* in **state query** and add Baxter datalog message using "+" button.\n\n![datalog][im10]\n\nNow the IPFS hash of the telemetry and photos is saved in the blockchain. To see the data simply copy the hash and insert it in IPFS Companion:\n\n![ipfs][im11]\n\nClick  __View on Gateway__ and that\'s all!\n\n![result1][im12]\n![result2][im13]\n\n[db2]: <http://wiki.ros.org/melodic/Installation>\n[db3]: <https://dist.ipfs.io/go-ipfs/v0.4.22/go-ipfs_v0.4.22_linux-386.tar.gz>\n[db4]: <https://github.com/airalab/robonomics/releases>\n[im1]: <../images/baxter_demo/empty_world.jpg>\n[im2]: <../images/baxter_demo/baxter_simulation.jpg>\n[im3]: <../images/baxter_demo/robonomics.jpg>\n[db5]: <https://parachain.robonomics.network>\n[im4]: <../images/baxter_demo/local_node.jpg>\n[im7]: <../images/baxter_demo/waiting.jpg>\n[db6]: </docs/create-account-in-dapp>\n[im8]: <../images/baxter_demo/rob_message.jpg>\n[im9]: <../images/baxter_demo/working.jpg>\n[im10]: <../images/baxter_demo/datalog.jpg>\n[im11]: <../images/baxter_demo/ipfs.jpg>\n[im12]: <../images/baxter_demo/result1.jpg>\n[im13]: <../images/baxter_demo/result2.jpg>\n[db7]: </docs/rio-overview>\n'}},{node:{id:"cd746379fa5a86f0030a2f8f1fc33d86",title:"AIRA Overview",path:"/docs/en/aira-overview/",content:"\n## Introduction\n\nAIRA stands for \"Autonomous Intelligent Robot Agent\". It implements the standard of economic interaction between human-robot and robot-robot. AIRA makes it possible to connect a variety of different robots under decentralized computer's control (currently supported Ethereum and Polkadot/Substrate).\n\nBasically it is the client for Robonomics Network developed by [Airalab](https://aira.life).\n\nAIRA is NixOS based operating system and officially supports the following architectures: x86, Raspberry Pi 3 B+ and Raspberry Pi 4.\n\nThe most simple way to get familiar with AIRA is to try installing AIRA as a [virtual machine](/docs/aira-installation-on-vb/).\n\nAIRA comes with a few preinstalled and configured services to help you focus on [agent](/docs/glossary#agent) development.\n\nMeanwhile it's highly customizable, but it's recommended to understand [NixOS](http://nixos.org/) and [Nix](https://nixos.org/nix/) language.\n\n## What's included? \n\nThe following services are included in the default distribution:\n\n* [Robonomics communication stack](https://github.com/airalab/robonomics_comm)\n* [IPFS](https://ipfs.io/)\n* OpenSSH\n* [cjdns](https://github.com/cjdelisle/cjdns)\n* [Yggdrasil-go](https://yggdrasil-network.github.io/)\n\nBesides at the first launch AIRA [generates](/docs/aira-installation-on-vb#launch-the-machine) for you new Ethereum address and IPNS identifier.\n\nIt's possible to use AIRA as a virtual machine or install as a main operating system. Also you can install only the services you need.\n"}},{node:{id:"f181f28f3ec5920cdb3001ccef3fd75d",title:"AIRA Installation",path:"/docs/en/aira-installation/",content:"\n- [**How to launch AIRA on VirtualBox**](/docs/aira-installation-on-vb/)\n\n- **The installation on Raspberry Pi** is as simple as writing an image of AIRA on SD card using `dd` or [Etcher](https://www.balena.io/etcher/), for example.\n\n\n"}},{node:{id:"10b1bb8045334d3bde42d2cdfc70e341",title:"AIRA Installation on VirtualBox",path:"/docs/en/aira-installation-on-vb/",content:'\nAIRA stands for "Autonomous Intelligent Robot Agent". It is the client for Robonomics Network developed by [Airalab](https://aira.life). It is an operating system based on [NixOS](https://nixos.org/). With AIRA you can  turn any cyber-physical system in an economic agent, where robots operate as a services for the reasonable payments. [More theory about AIRA here](/docs/aira-overview).\n\nIt\'s possible to install AIRA on a x86_64 PC. Also there are images for Raspberry Pi 3 and 4 supported by the team.\n\nThe best way to try AIRA is to start from installing it as a virtual machine on [VirtualBox](https://www.virtualbox.org/).\n\n## Requirements\n\n* VirtualBox\n* [VirtualBox Extension Pack](https://www.virtualbox.org/wiki/Downloads#VirtualBox6.1.2OracleVMVirtualBoxExtensionPack)\n* 2Gb of RAM for the machine\n* 40Gb of free disk space\n\n## Obtain the image\n\nAIRA has [stable](https://aira.life/channels/aira-stable/) and [unstable](https://aira.life/channels/aira-unstable/) channels.\n\nTo get stable image download the file with `.ova` extension.\n\tThe link for stable image is [here](https://releases.aira.life/channels/aira/stable/862-aira-stable/nixos-20.03pre-git-x86_64-linux.ova)\n\nDon\'t forget to compare checksum of the downloaded image with the last column `SHA-256 hash` on the [download page](https://aira.life/channels/aira-stable/). It must be equal to the output of the following command (it is an example, please check the name of downloaded by you .ova file first):\n\n```\nsha256sum nixos-20.03pre-git-x86_64-linux.ova\n```\n\nYou may wish to check out the walkthrough video:\n\nhttps://www.youtube.com/embed/cDcaypYPBhI\n\n## Troubleshooting\n\nIf you have fresh installed VirtualBox, you need to install the [extension](https://www.virtualbox.org/wiki/Downloads) pack or disable USB 2.0 controller.\n\nAlso VirtualBox may show a warning about `Display settings`. Consider switching `Graphics Controller` in settings of the VM to `VMSVGA`.\n\n## Import to VirtualBox\n\nOpen VirtualBox and press `Ctrl+I` or go to `File > Import Applicance...`\n\n![AIRA import VB image](../images/aira-installation/aira_import_vb_image.jpg "AIRA import VB image")\n\nAt this moment the next step is not necessary but it will help you to connect to the VM via SSH easily.\n\nFirst add `Host-Only` adapter in VirtualBox menu `File > Host Network Manager...` or by pressing `Ctrl+H`\n\n![Host Only](../images/aira-installation/host_only_adapter.jpg "Host Only")\n\nThen go to the image\'s settings, Network and add the second network adapter\n\n![Second adapter](../images/aira-installation/add_second_adapter.jpg "Second adapter")\n\nFor more details look at the standalone [lesson](/docs/aira-connecting-via-ssh/).\n\nOptionally you can increase the amount of video memory and switch `Graphics Controller` to `VMSVGA`.\n\n## Launch the machine\n\nFinally press Start and you\'ll see AIRA welcoming you with generated Ethereum address and IPFS identifier\n\n![AIRA image ready, Welcome screen](../images/aira-installation/aira_image_ready.jpg "AIRA image ready, Welcome screen")\n\nAt the very first initialization AIRA generates new Ethereum address and IPNS identifier for you.\n\n'}},{node:{id:"e822ab468fea96f049f1777e70537497",title:"Frequently Asked Questions about AIRA",path:"/docs/en/aira-faq/",content:"\n## How to see logs from main services?\n\nIPFS in real time:\n\n    journalctl -u ipfs -f\n\nand Liability::\n\n    journalctl -u liability -f\n\n## How to check the quantity of IPFS peers?\n\n    ipfs pubsub peers \n\n## IPFS can't connect to the daemon, what should I do?\n\nTry to specify `--api` option\n\n    ipfs swarm peers --api=/ip4/127.0.0.1/tcp/5001/\n\n## How to change ethereum address of AIRA?\n\nDelete `keyfile` and `keyfile-psk` in `/var/lib/liability` and restart the service\n\n```\nsystemctl restart liability\n```\n\n## IPFS daemon doesn't start\n\nThe error mostly occurs on single-board computers like Raspberry Pi or LattePanda after unexpected electricity lost.\n\nUsually the file `/var/lib/ipfs/api` is corrupted and one may see error:\n\n```\nError: Failed to parse '/var/lib/ipfs/api' file.\n  error: failed to parse multiaddr \"\": empty multiaddr\nIf you're sure go-ipfs isn't running, you can just delete it.\nOtherwise check:\n  ps aux | grep ipfs\n```\n\nYou can delete `/var/lib/ipfs/api` file and restart the service\n\n"}},{node:{id:"c516ac9b4e9b1c44b1df63ac5effd436",title:"Connecting AIRA via SSH",path:"/docs/en/aira-connecting-via-ssh/",content:'\nIt is more convenient to work with virtual machine via ssh connection. In this section we will configure VM.\n\n> **It\'s required to have your ssh public key on Github. In case you don\'t have one, please follow the [link](https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/)**\n\nBelow is the walkthrough video:\n\nhttps://www.youtube.com/embed/R6waDG5iwm0\n\n## Add Host Adapter\n\nGo to `File` -> `Host Network Manager...` or press `Ctrl+H`\n\n![VirtualBox Network Manager](../images/virtualbox_network_manager.png "VirtualBox Network Manager")\n\nClick `Create` button.\n\n## Add the Second Adapter to the VM\n\nSelect imported VM and click `Settings`. Go to `Network` tab and enable the second adapter\n\n![Add Second Adapter](../images/add_second_adapter_to_vm.png "Add Second Adapter")\n\n## Populate Authorized Keys\n\nLaunch the VM and run the following command replacing `<username>` with your Github user name:\n\n```\nmkdir .ssh\nchmod 700 .ssh\ncurl -sSL https://github.com/<username>.keys >> .ssh/authorized_keys\n```\n\nFind out the VM\'s IP address by running:\n\n```\nip a\n```\n\nYou should look for an address which starts with `192.168.xx.xx`\n\n## Log in via SSH\n\nNow open your terminal and log in via SSH as usual using the address from the previous step:\n\n```\nssh root@192.168.xx.xx\n```\n'}},{node:{id:"57dfc372142c3201a7d8f9427ea22d4f",title:"Basic usage of AIRA",path:"/docs/en/aira-basic-usage/",content:"\nTo get familiar with AIRA, let's see what is under the hood.\n\nOnce you launch the client several ros nodes will already be on the run. Here's a list of robonomics communication stack nodes:\n\n```bash\n$ rosnode list\n/eth/erc20_token\n/eth/eth_node\n/graph/aira_graph\n/liability/executor\n/liability/infochan/eth/signer\n/liability/infochan/ipfs_channel\n/liability/persistence\n/liability/listener\n/rosout\n```\n\n- `/eth/erc20_token`, `/eth/eth_node` - proved services for Ethereum blockchain and ERC20 tokens\n- `/graph/aira_graph` - service node for exploring other AIRA instances\n- `/liability/executor` - gets rosbag file from IPFS and plays it\n- `/liability/infochan/ipfs_channel` - is responsible for offer, demand and result messages. It catches messages from the channel and sends signed messages back\n- `/liability/infochan/eth/signer` - offers services for signing offer, demand and result messages\n- `/liability/listener` - watches for a new liability contracts. When the event is received the node calls executor node\n- `/liability/persistence` - helps to store incoming liabilities and restart them after shutdown\n\nAnd here's a list of robonomics stack topics.\n\n```bash\n$ rostopic list\n/eth/event/approval\n/eth/event/transfer\n/graph/greetings\n/liability/complete\n/liability/finalized\n/liability/incoming\n/liability/infochan/eth/sending/demand\n/liability/infochan/eth/sending/offer\n/liability/infochan/eth/sending/result\n/liability/infochan/eth/signing/demand\n/liability/infochan/eth/signing/offer\n/liability/infochan/eth/signing/result\n/liability/infochan/incoming/demand\n/liability/infochan/incoming/offer\n/liability/infochan/incoming/result\n/liability/persistence/add\n/liability/persistence/del\n/liability/persistence/update_timestamp\n/liability/ready\n/liability/result\n/rosout\n/rosout_agg\n```\n\nThe most important topics for us are:\n\n- `/liability/incoming` - when a new liability is created, this topic publishes Ethereum address of the contract\n- `/liability/result` - this topic is for publishing results. But don't publish a result directly to this topic! Use a service instead\n- `/liability/infochan/incoming/*` - a CPS gets information about offer, demand or result from corresponding topics\n- `/liability/infochan/eth/signing/*` - a CPS sends offer, demand or result messages to corresponding topics\n\nFor the details check out the [API page](/docs/robonomics-liability/).\n\nLet's start with greetings - say hello to AIRA!\n\nYou should just launch a pre-installed package `hello_aira`:\n\n```\n$ rosrun hello_aira hello_aira\n```\n\nWe've launched our agent. It will wait for a demand message. Now it's time to send the message. Go to [dapp](https://airalab.github.io/robonomics_tutorials/) and press Order.\nNow go back to the console and see the result!"}},{node:{id:"d32c76ebc4a70fe87b9d61fae18909cd",title:"Agent development examples",path:"/docs/en/agent-development-examples/",content:"\nUseful pieces of code and a few scenarios. All source code is [here](https://github.com/vourhey/robonomics_tutorials).\n\n1. [Broadcast Demand](https://github.com/Vourhey/robonomics_tutorials/tree/master/01_broadcast_demand/)\n2. [Broadcast Offer](https://github.com/Vourhey/robonomics_tutorials/tree/master/02_broadcast_offer/)\n3. [Trader](https://github.com/Vourhey/robonomics_tutorials/tree/master/03_trader/)\n4. [Trader with ACL](https://github.com/Vourhey/robonomics_tutorials/tree/master/04_trader_with_acl/)\n5. [Open Sensor Data](https://github.com/Vourhey/robonomics_tutorials/tree/master/05_open_sensor_data/)\n\n"}}]}},c=function(n){var e=n.options;e.__staticData?e.__staticData.data=r:(e.__staticData=s.a.observable({data:r}),e.computed=i({$static:function(){return e.__staticData.data}},e.computed))},l=Object(a.a)(t,(function(){var n=this,e=n.$createElement,o=n._self._c||e;return o("div",{staticClass:"search-container",class:n.toggleClasses,attrs:{tabindex:"0"},on:{focusin:n.focusIn,focusout:n.focusOut}},[o("input",{directives:[{name:"model",rawName:"v-model",value:n.search,expression:"search"}],attrs:{type:"search","aria-label":n.$st("Search",n.$store.state.locale),placeholder:n.$st("Search",n.$store.state.locale)},domProps:{value:n.search},on:{input:function(e){e.target.composing||(n.search=e.target.value)}}}),n.searchResults.length>0?o("div",{staticClass:"searchresults",attrs:{role:"listbox"}},[o("div",{staticClass:"layout__content"},[o("div",{staticClass:"search-msg-count",attrs:{"aria-hidden":"true"}},[n._v(n._s(n.$st("Search Found",n.$store.state.locale))+": "+n._s(n.searchResults.length))]),o("nav",n._l(n.searchResults,(function(e){return o("g-link",{key:e.node.id,attrs:{to:e.node.path},on:{focusout:n.SearchLinksNextFocus}},[n._v(n._s(e.node.title))])})),1)])]):n._e()])}),[],!1,null,null,null);"function"==typeof c&&c(l);e.default=l.exports}}]);